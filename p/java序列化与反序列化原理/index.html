<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="起因还是之前逛到一些网站，发现关键参数都是用base64编码后的序列化数据，所以序列化了解一下。 从java出发，让我们吹起反序列化的号角吧！"><title>Java序列化与反序列化原理</title>
<link rel=canonical href=https://selfsolo.com/p/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Java序列化与反序列化原理">
<meta property="og:description" content="起因还是之前逛到一些网站，发现关键参数都是用base64编码后的序列化数据，所以序列化了解一下。 从java出发，让我们吹起反序列化的号角吧！">
<meta property="og:url" content="https://selfsolo.com/p/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/">
<meta property="og:site_name" content="Sera Wang">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Java"><meta property="article:published_time" content="2018-08-24T21:14:23+08:00"><meta property="article:modified_time" content="2018-08-24T21:14:23+08:00">
<meta name=twitter:title content="Java序列化与反序列化原理">
<meta name=twitter:description content="起因还是之前逛到一些网站，发现关键参数都是用base64编码后的序列化数据，所以序列化了解一下。 从java出发，让我们吹起反序列化的号角吧！">
<link rel="shortcut icon" href=https://ser4wang.oss-cn-beijing.aliyuncs.com/IMG_3605.JPG>
</head>
<body class=article-page>
<script>(function(){const a='StackColorScheme';localStorage.setItem(a,"dark")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
on-phone--column compact">
<aside class="sidebar left-sidebar sticky">
<button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box>
<span class=hamburger-inner></span>
</span>
</button>
<header class=site-info>
<figure class=site-avatar>
<img src=https://ser4wang.oss-cn-beijing.aliyuncs.com/20210731222602.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</figure>
<h1 class=site-name><a href=https://selfsolo.com>Sera Wang</a></h1>
<h2 class=site-description>Le vent se lève, il faut tenter de vivre.</h2>
</header>
<ol class=menu id=main-menu>
<li>
<a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span>
</a>
</li>
<li>
<a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span>
</a>
</li>
<li>
<a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span>
</a>
</li>
<li>
<a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span>
</a>
</li>
</ol>
</aside>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<h2 class=article-title>
<a href=/p/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/>Java序列化与反序列化原理</a>
</h2>
<h3 class=article-subtitle>
起因还是之前逛到一些网站，发现关键参数都是用base64编码后的序列化数据，所以序列化了解一下。 从java出发，让我们吹起反序列化的号角吧！
</h3>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 24, 2018</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
6 min read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h1 id=基本>基本</h1>
<p>java序列化数据，是通过ObjectOutputStream和ObjectInputStream这两个类来实现的，</p>
<p>举个例子:</p>
<blockquote>
<p>要序列化的对象data1</p>
</blockquote>
<pre><code>public class data1 implements Serializable {

    private int id;
    private String name;
    private String pwd;
    private String pwd2;

    public int getId(){ return id; }
    public void setId(int id){ this.id = id; }

    public String getName(){ return name; }
    public void setName(String name){ this.name = name; }

    public String getPwd(){ return pwd; }
    public void setPwd(String pwd){ this.pwd = pwd; }

    public String getPwd2(){ return pwd2; }
    public void setPwd2(String pwd2){ this.pwd2 = pwd2; }
}
</code></pre><blockquote>
<p>序列化操作类SerializeTest</p>
</blockquote>
<pre><code>public class SerializeTest {
    public void serialize() throws Exception{
        data1 d = new data1();
        d.setId(1036);
        d.setName(&quot;data1&quot;);
        d.setPwd(&quot;pwd1&quot;);
        d.setPwd2(&quot;pwd2&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;d:/project/serial/data1&quot;);
        ObjectOutputStream oos = new ObjectOutputStream(fos); //创建Object输出流对象
        oos.writeObject(d); //向data1文件中写入序列化数据data1类
        fos.close();
        oos.close();
        System.out.println(&quot;序列化完成&quot;);
    }
    public data1 deSerialize() throws Exception{
        FileInputStream fis = new FileInputStream(&quot;d:/project/serial/data1&quot;);
        ObjectInputStream ois = new ObjectInputStream(fis); //创建Object输入流对象
        data1 d = (data1)ois.readObject(); //从data1文件中反序列化出data1类数据
        ois.close();
        fis.close();
        return d;
    }

    public static void main(String[] args) throws Exception{
        SerializeTest s = new SerializeTest();
        s.serialize();
        data1 d = s.deSerialize();
        System.out.println(&quot;id:&quot;+d.getId());
        System.out.println(&quot;name:&quot;+d.getName());
        System.out.println(&quot;pwd:&quot;+d.getPwd());
    }
}
</code></pre><p>执行后会发现 序列化成功，输出文件data1，同时反序列化成功，我们可以从data1文件中反序列化出data1类，能够获取其中的信息。</p>
<p>我们看看data1文件,notepad打开它长这样</p>
<p><img src=http://p6jpvwsnk.bkt.clouddn.com/18-8-24/51128411.jpg alt=img></p>
<p>再按十六进制打开看看，</p>
<p><img src=http://p6jpvwsnk.bkt.clouddn.com/18-8-24/82094575.jpg alt=img></p>
<p>是的，这就是序列化。</p>
<p>有些字符是能看懂的，比如说data1，id，name，这无疑暴露了很多信息，变量键值对都暴露了，所以网站一般不可能就如此把关键信息这样放进去，应该会有加密，但我们现在首先得知道原理！</p>
<p>和我开始的设想一样，反序列化就是要将这串二进制流按某种编码规则编码。 具体怎么编码，就得要读读源码才能搞明白了。</p>
<h1 id=序列化源码解析><strong>序列化源码解析</strong></h1>
<ol>
<li>
<p>初始化ObjectOutputStream</p>
<p>序列化靠的是ObjectOutputStream，我们先看它初始化的结果，</p>
<blockquote>
<p>构造参数</p>
</blockquote>
<pre><code> public ObjectOutputStream(OutputStream out) throws IOException {
    verifySubclass();
    bout = new BlockDataOutputStream(out);
    handles = new HandleTable(10, (float) 3.00);
    subs = new ReplaceTable(10, (float) 3.00);
    enableOverride = false;
    writeStreamHeader();
    bout.setBlockDataMode(true);
    if (extendedDebugInfo) {
        debugInfoStack = new DebugTraceInfoStack();
    } else {
        debugInfoStack = null;
    }
}
</code></pre><p>初始化的代码中，bout是底层字节数据容器</p>
<p>有行writeStreamHeader()，代码如下：</p>
<pre><code>protected void writeStreamHeader() throws IOException {
    bout.writeShort(STREAM_MAGIC);
    bout.writeShort(STREAM_VERSION);
}
</code></pre><p>writeShort是往容器里写两个字节，这里初始化写入了4个字节(一个STREAM_MAGIC ，一个 STREAM_VERSION)</p>
<pre><code>/**
 * Magic number that is written to the stream header.
 */
final static short STREAM_MAGIC = (short)0xaced;

/**
 * Version number that is written to the stream header.
 */
final static short STREAM_VERSION = 5;
</code></pre><p>即 ac ed 00 05，表示声明使用序列化协议以及说明序列化版本</p>
</li>
<li>
<p>开始序列化 writeObject()</p>
<pre><code>public final void writeObject(Object obj) throws IOException {
    if (enableOverride) {
        writeObjectOverride(obj);
        return;
    }
    try {
        writeObject0(obj, false);
    } catch (IOException ex) {
        if (depth == 0) {
            writeFatalException(ex);
        }
        throw ex;
    }
}
</code></pre><p>一般会直接调用writeObject0()</p>
<pre><code>private void writeObject0(Object obj, boolean unshared)
    throws IOException
{
    boolean oldMode = bout.setBlockDataMode(false);
    depth++;
    try {
        // handle previously written and non-replaceable objects
        int h;

        ...省略代码

        if (obj instanceof ObjectStreamClass) {
            writeClassDesc((ObjectStreamClass) obj, unshared);
            return;
        }

        // check for replacement object
        Object orig = obj;
        Class&lt;?&gt; cl = obj.getClass();
        ObjectStreamClass desc;
        for (;;) {
            // REMIND: skip this check for strings/arrays?
            Class&lt;?&gt; repCl;
            desc = ObjectStreamClass.lookup(cl, true);
            if (!desc.hasWriteReplaceMethod() ||
                (obj = desc.invokeWriteReplace(obj)) == null ||
                (repCl = obj.getClass()) == cl)
            {
                break;
            }
            cl = repCl;
        }

        // remaining cases
        if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            if (extendedDebugInfo) {
                throw new NotSerializableException(
                    cl.getName() + &quot;\n&quot; + debugInfoStack.toString());
            } else {
                throw new NotSerializableException(cl.getName());
            }
        }
    } finally {
        depth--;
        bout.setBlockDataMode(oldMode);
    }
}
</code></pre><p>后面那些判断，容易看出，根据对象的不同类型，按不同方法写入序列化数据，这里如果对象实现了Serializable接口，就调用writeOrdinaryObject()方法。</p>
<p>然后发现这个方法还传入了一个desc，这是在此函数之前的一个for(;;)循环里，创建的用来描述该对象类信息的，ObjectStreamClass类。</p>
<blockquote>
<p>然后看writeOrdinaryObject()</p>
</blockquote>
<pre><code>private void writeOrdinaryObject(Object obj,
                                 ObjectStreamClass desc,
                                 boolean unshared)
    throws IOException
{
    if (extendedDebugInfo) {
        debugInfoStack.push(
            (depth == 1 ? &quot;root &quot; : &quot;&quot;) + &quot;object (class \&quot;&quot; +
            obj.getClass().getName() + &quot;\&quot;, &quot; + obj.toString() + &quot;)&quot;);
    }
    try {
        desc.checkSerialize();

        bout.writeByte(TC_OBJECT);
        writeClassDesc(desc, false);
        handles.assign(unshared ? null : obj);
        if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {
            writeExternalData((Externalizable) obj);
        } else {
            writeSerialData(obj, desc);
        }
    } finally {
        if (extendedDebugInfo) {
            debugInfoStack.pop();
        }
    }
}
</code></pre><p>先是writeByte()，写入了一个字节的TC_OBJECT标志位(十六进制 73)，然后调用writeClassDesc(desc)，把之前生成的该类信息写入，</p>
<blockquote>
<p>跟进看writeClassDesc()</p>
</blockquote>
<pre><code>private void writeClassDesc(ObjectStreamClass desc, boolean unshared)
    throws IOException
{
    int handle;
    if (desc == null) {
        writeNull();
    } else if (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -1) {
        writeHandle(handle);
    } else if (desc.isProxy()) {
        writeProxyDesc(desc, unshared);
    } else {
        writeNonProxyDesc(desc, unshared);
    }
}
</code></pre><p>isProxy()判断类是否是动态代理类，没了解过动态代理（先mark），这里因为不是动态代理类，所以会调用writeNonProxyDesc(desc)</p>
<blockquote>
<p>跟进writeNonProxyDesc(desc)</p>
</blockquote>
<pre><code>private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared)
    throws IOException
{
    bout.writeByte(TC_CLASSDESC);
    handles.assign(unshared ? null : desc);

    if (protocol == PROTOCOL_VERSION_1) {
        // do not invoke class descriptor write hook with old protocol
        desc.writeNonProxy(this);
    } else {
        writeClassDescriptor(desc);
    }

    Class&lt;?&gt; cl = desc.forClass();
    bout.setBlockDataMode(true);
    if (cl != null &amp;&amp; isCustomSubclass()) {
        ReflectUtil.checkPackageAccess(cl);
    }
    annotateClass(cl);
    bout.setBlockDataMode(false);
    bout.writeByte(TC_ENDBLOCKDATA);

    writeClassDesc(desc.getSuperDesc(), false);
}    
</code></pre><p>发现writeByte写入了一个字节的TC_CLASSDESC(16进制 72)</p>
<p>然后下面一个判断是true进入writeNonProxy()</p>
<blockquote>
<p>writeNonProxy()</p>
</blockquote>
<pre><code>void writeNonProxy(ObjectOutputStream out) throws IOException {
    out.writeUTF(name);
    out.writeLong(getSerialVersionUID());

    byte flags = 0;
    if (externalizable) {
        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;
        int protocol = out.getProtocolVersion();
        if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) {
            flags |= ObjectStreamConstants.SC_BLOCK_DATA;
        }
    } else if (serializable) {
        flags |= ObjectStreamConstants.SC_SERIALIZABLE;
    }
    if (hasWriteObjectData) {
        flags |= ObjectStreamConstants.SC_WRITE_METHOD;
    }
    if (isEnum) {
        flags |= ObjectStreamConstants.SC_ENUM;
    }
    out.writeByte(flags);

    out.writeShort(fields.length);
    for (int i = 0; i &lt; fields.length; i++) {
        ObjectStreamField f = fields[i];
        out.writeByte(f.getTypeCode());
        out.writeUTF(f.getName());
        if (!f.isPrimitive()) {
            out.writeTypeString(f.getTypeString());
        }
    }
}
</code></pre><p>调用writeUTF()写入了类名，这个writeUTF()函数，在写入十六进制类名前，会先写入两个字节的类名长度，</p>
<p>然后再调用writeLong，写入序列化UID</p>
<p>然后下面有个判断，会判断类接口的实现方式，调用writeByte()写入一个字节的标志位。</p>
<blockquote>
<p>下面是所有标志位</p>
</blockquote>
<pre><code>/**
 * Bit mask for ObjectStreamClass flag. Indicates Externalizable data
 * written in Block Data mode.
 * Added for PROTOCOL_VERSION_2.
 *
 * @see #PROTOCOL_VERSION_2
 * @since 1.2
 */
final static byte SC_BLOCK_DATA = 0x08;

/**
 * Bit mask for ObjectStreamClass flag. Indicates class is Serializable.
 */
final static byte SC_SERIALIZABLE = 0x02;

/**
 * Bit mask for ObjectStreamClass flag. Indicates class is Externalizable.
 */
final static byte SC_EXTERNALIZABLE = 0x04;

/**
 * Bit mask for ObjectStreamClass flag. Indicates class is an enum type.
 * @since 1.5
 */
final static byte SC_ENUM = 0x10;
</code></pre><p>然后调用writeShort写入两个字节的域长度（比如说有3个变量，就写入 00 03 ）</p>
<p>接下来是一个循环，准备写入这个类的变量名和它对应的变量类型了</p>
<p><strong>每轮循环</strong>:</p>
<ol>
<li>
<p>writeByte写入一个字节的变量类型;</p>
</li>
<li>
<p>writeUTF()写入变量名</p>
</li>
<li>
<p>有个判断，判断是不是原始类型，即是不是对象</p>
</li>
</ol>
<p>不是基本类型的话，就调用writeTypeString()</p>
<p>这个writeTypeString()，如果是字符串，就会调用writeString()</p>
<p>而这个writeString()往往是这样写的，字符串长度(不是大小)小于两个字节，就先写入一个字节的TC_STRING(16进制 74)，然后调用writeUTF()，写入一个signature，这好像跟jvm有关，最后一般写的是</p>
<blockquote>
<p>74 00 12 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</p>
</blockquote>
<p>“翻译”过来就是，字符串类型，占18个字节长度，变量名是 Ljava/lang/string;</p>
<p>而如果说，之前已经写过刚刚这串74 00 12…3b</p>
<p>那会调用writeHandle()，先写入一个字节的TC_REFERENCE(16进制 71)，然后调用writeInt()写入 007e0000 + handle，这个handle是之前声明过对象的位置，这里我还没弄清除这个位置是怎么定位的，一般是00 01，也就是说 writeHandle()，一般写入类似</p>
<blockquote>
<p>71 00 7e 00 XX</p>
</blockquote>
<p>这样5个字节(最后这个00 XX 还不确定，等我再弄明白，一般是 00 01)</p>
<hr>
<p>上面这些结束了，也就是我们写完了writeNonProxy()，现在再次回到writeNonProxyDesc()</p>
<p>接下来继续调用writeByte()写入一个字节的TC_ENDBLOCKDATA(16进制 78，表示块结束标志位)。</p>
<p>再调用writeCLassDesc()，参数是desc的父类。</p>
<p>这里如果父类没有实现序列化接口那就不会写入，否则回到刚才writeNonProxyDesc那一步开始写父类的类信息和变量信息(起始位72，终止位78)，类似于一个递归调用，最后如果没有实现了序列化接口的父类了，就会调用writeNull()，写入一个字节的TC_NULL(16进制 70)，表示没对象了。</p>
<hr>
<p>好了，总之writeClassDesc()这个递归调用完了之后，我们就回到了writeOrdinaryObject()</p>
<p>接下来调用writeSerialData()，准备写入序列化数据</p>
<blockquote>
<p>writeSerialData()</p>
</blockquote>
<pre><code>private void writeSerialData(Object obj, ObjectStreamClass desc)
    throws IOException
{
    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
    for (int i = 0; i &lt; slots.length; i++) {
        ObjectStreamClass slotDesc = slots[i].desc;
        if (slotDesc.hasWriteObjectMethod()) {
            PutFieldImpl oldPut = curPut;
            curPut = null;
            SerialCallbackContext oldContext = curContext;

            if (extendedDebugInfo) {
                debugInfoStack.push(
                    &quot;custom writeObject data (class \&quot;&quot; +
                    slotDesc.getName() + &quot;\&quot;)&quot;);
            }
            try {
                curContext = new SerialCallbackContext(obj, slotDesc);
                bout.setBlockDataMode(true);
                slotDesc.invokeWriteObject(obj, this);
                bout.setBlockDataMode(false);
                bout.writeByte(TC_ENDBLOCKDATA);
            } finally {
                curContext.setUsed();
                curContext = oldContext;
                if (extendedDebugInfo) {
                    debugInfoStack.pop();
                }
            }

            curPut = oldPut;
        } else {
            defaultWriteFields(obj, slotDesc);
        }
    }
}
</code></pre><p>一个循环，上限是类(包括父类)数量</p>
<p><strong>每轮循环:</strong></p>
<p>调用defaultWriteFields()</p>
<blockquote>
<p>defaultWriteFields()</p>
</blockquote>
<pre><code>private void defaultWriteFields(Object obj, ObjectStreamClass desc)
    throws IOException
{
    Class&lt;?&gt; cl = desc.forClass();
    if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
        throw new ClassCastException();
    }

    desc.checkDefaultSerialize();

    int primDataSize = desc.getPrimDataSize();
    if (primVals == null || primVals.length &lt; primDataSize) {
        primVals = new byte[primDataSize];
    }
    desc.getPrimFieldValues(obj, primVals);
    bout.write(primVals, 0, primDataSize, false);

    ObjectStreamField[] fields = desc.getFields(false);
    Object[] objVals = new Object[desc.getNumObjFields()];
    int numPrimFields = fields.length - objVals.length;
    desc.getObjFieldValues(obj, objVals);
    for (int i = 0; i &lt; objVals.length; i++) {
        if (extendedDebugInfo) {
            debugInfoStack.push(
                &quot;field (class \&quot;&quot; + desc.getName() + &quot;\&quot;, name: \&quot;&quot; +
                fields[numPrimFields + i].getName() + &quot;\&quot;, type: \&quot;&quot; +
                fields[numPrimFields + i].getType() + &quot;\&quot;)&quot;);
        }
        try {
            writeObject0(objVals[i],
                         fields[numPrimFields + i].isUnshared());
        } finally {
            if (extendedDebugInfo) {
                debugInfoStack.pop();
            }
        }
    }
}
</code></pre><p>先判断是否是基本类型，是的话调用write直接写入序列化数据</p>
<p>否则，获取该类所有变量数，开始循环</p>
<p><strong>每轮:</strong></p>
<ol>
<li>调用writeObject0()写入变量，也就是说，根据变量类型，用相应方法写入。</li>
</ol>
<p><strong>最后循环结束；</strong></p>
<p>随着所有变量的写入，先前一次循环也结束，writeSerialData()方法调用完毕，回到了writeOrdinaryObject()，执行结束回到了writeObject0()，又回到了writeObject()。</p>
<p>以上，就是序列化全过程，可能还有些细节有疏漏，因为我接触java时间不长，很多地方不明白，如有错误请指正！</p>
</li>
</ol>
<h1 id=反序列化源码解析><strong>反序列化源码解析</strong></h1>
<p>待续…</p>
<h1 id=小总结>小总结</h1>
<p>刚开始想的是，要了解反序列化，就得要知道序列化原理，因为逛网站看到很多都是java写的，所以想着先读java的序列化源码，机制应该大多类似，但具体实现我总感觉会有不同，这样子就会给反序列化带来一定困难(?)，因为一开始心里其实想的是写一个通用性反序列化工具，感觉挺有意思，但顶着发烧简单弄明白上面的流程也已经花了三四天了。</p>
<p>感觉反序列化应该是容易实现的一个东西，网站如果只单纯序列化传输数据，容易造成信息泄露，所以一般都会在关键参数加密后再序列化吧…但是不反序列化连看到加密参数的机会都没有，对吧？</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/java/>Java</a>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2017 -
2021 Sera Wang
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.5.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>