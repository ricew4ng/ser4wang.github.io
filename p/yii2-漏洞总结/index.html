<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="读书时的碎碎念"><title>Yii2 漏洞总结</title>
<link rel=canonical href=https://sera.wang/p/yii2-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Yii2 漏洞总结">
<meta property="og:description" content="读书时的碎碎念">
<meta property="og:url" content="https://sera.wang/p/yii2-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">
<meta property="og:site_name" content="Sera Wang">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Security"><meta property="article:published_time" content="2019-02-08T21:14:23+08:00"><meta property="article:modified_time" content="2019-02-08T21:14:23+08:00">
<meta name=twitter:title content="Yii2 漏洞总结">
<meta name=twitter:description content="读书时的碎碎念">
<link rel="shortcut icon" href=https://ser4wang.oss-cn-beijing.aliyuncs.com/20211204221119.png>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"dark")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://sera.wang class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/security/ style=background-color:#2a9d8f;color:#fff>
Security
</a>
</header>
<h2 class=article-title>
<a href=/p/yii2-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/>Yii2 漏洞总结</a>
</h2>
<h3 class=article-subtitle>
读书时的碎碎念
</h3>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 08, 2019</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
7 min read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<blockquote>
<p>欲寻框架之漏洞，必先用其开发一波。———— Rose家的程序喵</p>
</blockquote>
<h1 id=框架基础>框架基础</h1>
<p>Yii2 版本: 2.0.16</p>
<h2 id=应用结构>应用结构</h2>
<p>下列是框架中最重要的目录和文件</p>
<p><img src=https://i.imgur.com/KcNU0CK.png alt=img></p>
<p>Yii 实现了MVC设计模式，这点在上述目录结构中也体现了。models目录包含了所有模型类，views目录包含了所有视图脚本，controllers目录包含了所有控制机器类。</p>
<p>下图显示了一个应用的静态结构</p>
<p><img src=https://i.imgur.com/wW8fodH.png alt=img></p>
<p>每个应用都有一个入口脚本 web/index.php，这是整个应用中唯一可以访问的PHP脚本。入口脚本接受一个Web请求并创建应用实例去处理它。应用在它的组建辅助下解析请求，并分派请求至MVC元素。视图使用小部件（即各种前台标签的类）去创建复杂和动态的用户界面。</p>
<h2 id=请求生命周期>请求生命周期</h2>
<p><img src=https://i.imgur.com/pE7GRnQ.png alt=img></p>
<ol>
<li>用户向入口脚本 web/index.php 发起请求</li>
<li>入口脚本加载应用配置并创建一个应用实例去处理请求。</li>
<li>应用通过请求组件解析请求的路由。</li>
<li>应用创建一个控制器实例去处理请求。</li>
<li>控制器创建一个动作实例并针对操作执行过滤器。</li>
<li>如果任何一个过滤器返回失败，则动作取消。</li>
<li>如果所有过滤其都通过，动作将被执行。</li>
<li>动作会加载一个数据模型，或许是来自数据库。</li>
<li>动作会渲染一个视图，把数据模型提供给它。</li>
<li>渲染结果返回给响应组件。</li>
<li>响应组件发送渲染结果给用户浏览器。</li>
</ol>
<h1 id=helloworld>HelloWorld</h1>
<p>安装好Yii后，看看初始页面</p>
<p><img src=https://i.imgur.com/mOtNpfs.png alt=img></p>
<p>看上去就已经很漂亮了。</p>
<p>话说回来，要在应用中创建一个HelloWorld页面，将需要创建一个操作和一个视图：</p>
<ol>
<li>应用将会分派页面请求给动作</li>
<li>动作将会依次渲染视图呈现”Hello”给最终用户</li>
</ol>
<p>我们需要知道：</p>
<ul>
<li>如何创建一个动作去响应请求</li>
<li>如何创建一个视图去构造相应内容</li>
<li>以及一个应用如何分派请求给动作</li>
</ul>
<h2 id=创建动作>创建动作</h2>
<p>我们将要创建一个say操作，从请求中接收message参数并先显示给最终用户。如果请求没有提供message参数，操作将显示默认参数”Hello”</p>
<blockquote>
<p>操作是最终用户可以直接访问并执行的对象。操作被组织在控制器中，一个操作的执行结果就是最终用户收到的响应内容。</p>
</blockquote>
<p>操作必须声明在控制器中。为了简单起见，可以直接在SiteController控制器里生命say操作。
这个控制器是由文件 controllers/SiteController.php定义的。以下是一个操作的声明：</p>
<pre tabindex=0><code>&lt;?php

namespace app\controllers;

use yii\web\Controller;

class SiteController extends Controller{
    // ...现存的代码...

    public function actionSay($message = 'Hello'){
        return $this-&gt;render('say',['message' =&gt; $message]);
    }
}
</code></pre><p>在上述代码中，say操作被定义为actionSay方法。 Yii使用action前缀区分普通方法和操作。action前缀后面的名称被映射为操作的ID。</p>
<p>涉及到给操作命名时，我们应该理解Yii如何处理操作ID。操作ID总是被以小写处理，如果一个操作ID由多个单词组成，单词之间将由连字符连接（如create-comment）。操作ID映射为方法名时，除了连字符，将每个单词首字母大写，并加上action前缀。 例子：操作ID <code>create-comment</code>相当于方法名 <code>actionCreateComment</code></p>
<p>上述代码中的操作方法接受一个默认值为”Hello”的参数$message，当应用接收到请求并确定由say操作来响应请求时，应用将从请求的参数中寻找对应值传入进来。</p>
<p>在操作方法中，render()被用来渲染一个名为say的视图文件。 message参数也被传入视图，这样就可以在里面使用。 操作方法会返回渲染结果。 结果会被应用接收并显示给最终用户的浏览器（作为整页HTML的一部分）。</p>
<h2 id=创建视图>创建视图</h2>
<p>视图是用来生成响应内容的脚本，为了”HelloWorld”，我们需要创建一个say视图，以便显示从操作方法中传来的message参数。</p>
<pre tabindex=0><code>&lt;?php
use yii\helpers\Html;
?&gt;
&lt;?= Html::encode($message) ?&gt;
</code></pre><p>say视图应该存为 <strong><code>views/site/say.php</code></strong> 文件。</p>
<p>当一个操作中调用了render()方法时，它将会按 views/控制器ID/视图名.php路径加载PHP文件。</p>
<p>以上代码中，message参数在输出之前被HTML-encoded方法处理过，因为当参数来自于最终用户时，可能导致XSS。</p>
<p>其它内容可以自己构造，视图脚本输出的内容将会作为响应结果返回给应用。应用将依次输出结果给最终用户。</p>
<p>运行
-</p>
<p><img src=https://i.imgur.com/mKje91t.png alt=img></p>
<p>这个页面输出了包含”Hello World”的页面，页面有了自带的头部和尾部。</p>
<blockquote>
<p>render方法会自动把say视图执行的结果嵌入称为布局的文件中，本例中是 views/layouts/main.php</p>
</blockquote>
<p>图中URL的参数r代表路由，是整个应用级的。指向特定操作的独立ID。路由格式是 <code>控制器ID / 操作ID</code>。应用接受请求的时候会检查参数，使用控制器ID去确定哪个控制器应该被用来处理请求。然后相应控制器将使用操作ID去确定哪个操作方法将被用来做具体工作。</p>
<p>上面的例子中，路由site/say将被解析至Site Controller控制器和其中的say操作。因此，SiteController::actionSay()方法将被调用处理请求。</p>
<blockquote>
<p>与操作一样，一个应用中控制器同样有唯一的ID，控制器同样有唯一的ID，控制器ID和操作ID使用同样的命名规则。控制器的类名源自于控制器ID，移除了连字符，每个单词首字母大写，并加上Controller后缀。 例： 控制器ID <code>post-comment</code> 相当于 控制器类名 <code>PostCommentController</code></p>
</blockquote>
<h1 id=创建模型>创建模型</h1>
<p>这里通过表单提交，创建一个模型代表用户通过表单输入的数据。</p>
<p>模型类 EntryForm 代表从用户那请求的数据，该类存储在 models/EntryForm.php 文件中。</p>
<pre tabindex=0><code>&lt;?php

namespace app\models;

use Yii;
use yii\base\Model;

class EntryForm extends Model{
    public $name;
    public $email;

    public function rules(){
        return [
            [ ['name','email'] , 'required' ],
            [ 'email' , 'email' ],
        ];
    }
}
</code></pre><p>该类继承自Yii提供的一个基类 yii\base\Model，该基类通常用来表示数据。 它包含两个公共成员，用来储存用户输入的数据。 它还包含一个名为rules()的方法，用来返回数据验证规则。 上面声明的验证规则表示：</p>
<ol>
<li>name和email值都是必须的</li>
<li>email的值必须满足email规则验证</li>
</ol>
<blockquote>
<p>如果你有一个处理用户提交数据的EntryForm对象，可以调用它的validate()方法触发数据验证。 如果有数据验证失败，则会将hasErrors属性设为 true，想要知道具体发生什么错误就调用 getErrors.</p>
</blockquote>
<p>eg:</p>
<pre tabindex=0><code>&lt;?php

$model = new EntryForm();
$model-&gt;name = &quot;test&quot;;
$model-&gt;email = 'bad';
if($model-&gt;validate()){
    // 验证成功
}else{
    // 失败，使用 $model-&gt;getErrors() 获取错误详情
}
</code></pre><h2 id=动作方法>动作方法</h2>
<p>SiteController中</p>
<pre tabindex=0><code>use app\models\EntryForm;

...

public function actionEntry(){
    $model = new EntryForm;
    if($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;validate()){
        // 验证 $model 收到的数据

        return $this-&gt;render('entry-confirm',['model' =&gt; $model]);
    }else{
        // 无论是初始化显示还是数据验证错误
        return $this-&gt;render('entry',['model' =&gt; $model]);
    }
}
</code></pre><blockquote>
<p>表达式 Yii::$app 是应用实例，它是一个全局可访问的单例。 同时它也是一个服务定位器，能提供 request，response，db 等等特定功能的组件。 在上面的代码里就是使用request组件来访问应用实例收到的$_POST数据。（post方法返回$_POST数组）</p>
</blockquote>
<h2 id=创建视图-1>创建视图</h2>
<p>views/site/entry-confirm.php 视图显示提交的name和email数据。</p>
<pre tabindex=0><code>&lt;?php
use yii\helpers\Html;
?&gt;
&lt;p&gt;You have entered the following information: &lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;label&gt;Name&lt;/label&gt;: &lt;?= Html::encode($model-&gt;name) ?&gt;&lt;/li&gt;
    &lt;li&gt;&lt;label&gt;Email&lt;/label&gt;: &lt;?= Html::encode($model-&gt;email) ?&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>views/site/entry.php视图显示一个HTML表单</p>
<pre tabindex=0><code>&lt;?php
use yii\helpers\Html;
use yii\widgets\ActiveForm;
?&gt;
&lt;?php $form = ActiveForm::begin(); ?&gt;

    &lt;?= $form-&gt;field($model,'name') ?&gt;
    &lt;?= $form-&gt;field($model,'email') ?&gt;

    &lt;div class=&quot;form-group&quot;&gt;
        &lt;?= Html::submitButton('Submit',['class' =&gt; 'btn btn-primary']) ?&gt;
    &lt;/div&gt;

&lt;?php ActiveForm::end(); ?&gt;
</code></pre><p>上面的视图使用了小部件 ActiveForm去生成HTML表单。 其中的 begin()和end() 分别用来渲染表单的开始和关闭标签。 在这两个方法之间使用了field()方法去创建输入框。 之后使用 yii\helpers\Html::submitButton() 方法生成提交按钮。</p>
<p><img src=https://i.imgur.com/nsFd5nM.png alt=img></p>
<p>ActiveForm会自动将我们在模型中声明的验证规则转化成客户端js脚本执行验证。 但后台我们依旧要再进行一遍验证。</p>
<h1 id=数据库的使用>数据库的使用</h1>
<p>config/db.php 配置数据库参数，这个文件配置了数据库连接 yii\db\Connection的创建和初始化参数，应用的SQL查询正是基于这个数据库。</p>
<p>数据库连接可以在应用中通过Yii::$app->db表达式访问。</p>
<p>接下来，我们比如要展示数据库中的一个country表。我们要自己写脚本创建表等等。</p>
<h2 id=创建activerecord>创建ActiveRecord</h2>
<p>创建一个Country类，存储在models/Country.php，去代表和读取country表的数据</p>
<pre tabindex=0><code>&lt;?php

namespace app\models;

use yii\db\ActiveRecord;

class Country extends ActiveRecord{}
</code></pre><blockquote>
<p>注:如果用Gii生成代码时，报错了，可以覆写tableName()方法去显式指定相关表名</p>
</blockquote>
<p>ActiveRecord（活动记录）是面向对象、功能强大的访问和操作数据库数据的方式</p>
<h2 id=controller>Controller</h2>
<p>controllers/CountryController.php</p>
<pre tabindex=0><code>&lt;?php

namespace app\controllers;

use yii\web\Controller;
use yii\data\Pagination;
use app\models\Country;

class CountryController extends Controller
{
    public function actionIndex()
    {
        $query = Country::find();

        $pagination = new Pagination([
            'defaultPageSize' =&gt; 5,
            'totalCount' =&gt; $query-&gt;count(),
        ]);

        $countries = $query-&gt;orderBy('name')
            -&gt;offset($pagination-&gt;offset)
            -&gt;limit($pagination-&gt;limit)
            -&gt;all();

        return $this-&gt;render('index', [
            'countries' =&gt; $countries,
            'pagination' =&gt; $pagination,
        ]);
    }
}
</code></pre><h2 id=视图>视图</h2>
<p>views/country/index.php</p>
<pre tabindex=0><code>&lt;?php
use yii\helpers\Html;
use yii\widgets\LinkPager;
?&gt;
&lt;h1&gt;Countries&lt;/h1&gt;
&lt;ul&gt;
&lt;?php foreach ($countries as $country): ?&gt;
    &lt;li&gt;
        &lt;?= Html::encode(&quot;{$country-&gt;name} ({$country-&gt;code})&quot;) ?&gt;:
        &lt;?= $country-&gt;population ?&gt;
    &lt;/li&gt;
&lt;?php endforeach; ?&gt;
&lt;/ul&gt;

&lt;?= LinkPager::widget(['pagination' =&gt; $pagination]) ?&gt;
</code></pre><p>访问URL查看效果</p>
<blockquote>
<p>http://localhost/yii2/index.php?r=country/index</p>
</blockquote>
<h1 id=gii>Gii</h1>
<p>这里不多赘述，它可以帮助我们生成代码，主要注意的内容在上文中有提到，就是有时候找不到对应的数据表，我们需要在模型类中添加静态的tableName()方法。</p>
<h1 id=进阶总览>进阶总览</h1>
<p>除了MVC，Yii应用还有以下部分：</p>
<ol>
<li><strong>入口脚本</strong>：终端用户能直接访问的PHP脚本，负责启动一个请求处理周期</li>
<li><strong>应用</strong>：能全局范围内访问的对象，管理协调组件来完成请求。</li>
<li><strong>应用组件</strong>：在应用中注册的对象，提供不同的功能来完成请求。</li>
<li><strong>模块</strong>：包含完整MVC结构的独立包，一个应用可以由多个模块组建。</li>
<li><strong>过滤器</strong>：控制器在处理请求之前或之后需要触发执行的代码</li>
<li><strong>小部件</strong>：可嵌入到试图中的对象，可包含控制器逻辑，可被不同视图重复调用</li>
</ol>
<h1 id=入口脚本>入口脚本</h1>
<p>一个应用（网页应用或是控制台应用）只有一个入口脚本，终端用户的请求通过入口脚本实例化应用并将请求转发到应用。</p>
<p>控制台应用的入口脚本一般在应用根目录下命名为yii，该文件需要有执行权限，这样用户就能通过命令 <code>./yii &lt;route> [arguments][options]</code>来运行控制台应用</p>
<p><strong>入口脚本主要完成以下工作：</strong></p>
<ol>
<li>定义全局常量</li>
<li>注册Composer自动加载器</li>
<li>包含Yii类文件</li>
<li>加载应用配置</li>
<li>创建一个应用实例并配置</li>
<li>调用yii\base\Application::run()来处理请求</li>
</ol>
<hr>
<h2 id=定义常量>定义常量</h2>
<p>入口脚本是定义全局常量的最好地方，Yii支持以下三个常量：</p>
<ol>
<li>YII_DEBUG：表示应用是否运行在调试模式，默认false</li>
<li>YII_ENV：表示应用运行的环境，默认 dev ，表示线上产品环境</li>
<li>YII_ENABLE_ERROR_HANDLER：标识是否启用Yii提供的错误处理，默认true</li>
</ol>
<h1 id=应用主体>应用主体</h1>
<p><strong>应用主体</strong>是管理Yii应用系统整体结构和生命周期的对象。每个Yii应用系统只能包含一个应用主体，应用主体在入口脚本中创建并能通过表达式 \Yii::$app全局范围内访问。</p>
<h2 id=应用主体配置>应用主体配置</h2>
<p>入口脚本index.php代码</p>
<pre tabindex=0><code>require __DIR__ . '/../vendor/autoload.php';
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

$config = require __DIR__ . '/../config/web.php';

(new yii\web\Application($config))-&gt;run();
</code></pre><p>当入口脚本创建了一个应用主体，它会加载一个配置文件并传给应用主体。</p>
<p>类似其它配置文件，应用主体配置文件标明如何设置应用对象初始属性。由于应用主体配置比较复杂，一般保存在多个类似如上web.php的配置文件中。</p>
<p>关于web.php配置文件属性的介绍内容也比较多，可以直接参照官方文档。</p>
<p><a class=link href=https://www.yiichina.com/doc/guide/2.0/structure-applications target=_blank rel=noopener>https://www.yiichina.com/doc/guide/2.0/structure-applications</a></p>
<p>注:</p>
<ol>
<li>所谓注册组件，就是注册以后，可以通过一个表达式进行全局访问。</li>
</ol>
<h2 id=应用事件>应用事件</h2>
<p>配置文件中，还可以写入请求事件的函数，比如发起请求前先如何处理，后如何处理。</p>
<h2 id=应用主体生命周期>应用主体生命周期</h2>
<p><img src=https://i.imgur.com/IHX4boN.png alt=img></p>
<p>当运行入口脚本处理请求时，应用主体会经历以下生命周期：</p>
<ol>
<li>入口脚本加载应用主体配置数组</li>
<li>入口脚本创建一个应用主体实例：
<ol>
<li>调用preInit()配置几个高级别应用主体属性，比如basePath。</li>
<li>注册error handler 错误处理方法</li>
<li>配置应用主体属性</li>
<li>调用init()初始化，该函数会调用bootstrap()运行引导启动组件</li>
</ol>
</li>
<li>入口脚本调用 yii\base\Application::run()运行应用主体
<ol>
<li>触发 <code>EVENT_BEFORE_REQUEST</code>事件</li>
<li>处理请求：解析请求路由和相关参数；创建路由指定的模块、控制器和动作对应的类，并运行动作</li>
<li>触发 <code>EVENT_AFTER_REQUEST</code>事件</li>
<li>发送响应到终端用户</li>
</ol>
</li>
<li>入口脚本接收应用主体传来的退出状态并完成请求的处理</li>
</ol>
<h1 id=应用组件>应用组件</h1>
<p>应用主体是服务定位器，它部署一组提供各种不同功能的应用组件来处理请求。 例如，urlManager组件负责处理网页请求路由到对应的控制器。db组件提供数据库相关服务等等。</p>
<p>在同一个应用中，每个应用组件都有一个独一无二的ID用来区分其它应用组件，你可以通过如下表达式访问应用组件。</p>
<blockquote>
<p>\Yii::$app->componentID</p>
</blockquote>
<p>例如，可以使用 \Yii::$app->db来获取到已注册应用的DB connection，使用\Yii::$app->cache来获取到已注册到应用的primary cache</p>
<p>注：</p>
<ol>
<li>
<p>第一次使用以上表达式的时候会创建应用组件实例，后续再次访问会返回此实例，无需创建。</p>
</li>
<li>
<p>应用组件可以是任意对象，可以在 应用主体配置 配置 yii\base\Application::$components属性。</p>
<p>eg:</p>
<pre tabindex=0><code>[
    'components' =&gt; [
        // 使用类名注册 &quot;cache&quot; 组件
        'cache' =&gt; 'yii\caching\ApcCache',

        // 使用配置数组注册 &quot;db&quot; 组件
        'db' =&gt; [
            'class' =&gt; 'yii\db\Connection',
            'dsn' =&gt; 'mysql:host=localhost;dbname=demo',
            'username' =&gt; 'root',
            'password' =&gt; '',
        ],

        // 使用函数注册&quot;search&quot; 组件
        'search' =&gt; function () {
            return new app\components\SolrService;
        },
    ],
]
</code></pre></li>
<li>
<p>应用组件就像全局变量， 使用太多可能加大测试和维护的难度。 一般情况下可以在需要时再创建本地组件。</p>
</li>
</ol>
<p><strong>核心应用组件</strong></p>
<p>Yii定义了一组固定ID和默认配置的核心组件，例如request组件用来收集用户请求并解析路由；db代表一个可以执行数据库操作的数据库连接。通过这些组件，Yii应用主体能处理用户请求。</p>
<h1 id=控制器>控制器</h1>
<p>控制器是继承 <code>yii\base\Controller</code> 类的对象，负责处理请求和生成响应。 具体来说，控制器从<strong>应用主体</strong>接管控制后会分析请求数据并传送到<strong>模型</strong>，传送模型结果到<strong>视图</strong>，最后生成输出响应信息。</p>
<h2 id=动作><strong>动作</strong></h2>
<p>控制器由 <strong>操作</strong> 组成，如action+操作名ID</p>
<h2 id=路由><strong>路由</strong></h2>
<p>用户通过 <strong>路由</strong> 寻找到动作，路由是包含以下部分的字符串：</p>
<ol>
<li>模块ID：仅存在于控制器属于非应用的模块</li>
<li>控制器ID：同应用下唯一标识控制器的字符串</li>
<li>操作ID：同控制器下唯一标识操作的字符串</li>
</ol>
<p>路由格式：</p>
<blockquote>
<p>ControllerID/ActionID</p>
</blockquote>
<p>如果属于模块下的控制器，格式：</p>
<p>ModuleID/ControllerID/ActionID</p>
<p>如果用户的请求地址为 <code>http://hostname/index.php?r=site/index</code>，会执行site控制器的index操作</p>
<h2 id=控制器id><strong>控制器ID</strong></h2>
<p>控制器ID应仅包含英文小写字母、数字、下划线、中横杠和正斜杠</p>
<p>控制器ID可包含子目录前缀，例如admin/article代表<code>controller namespace</code> 控制器命名空间下<code>admin</code>子目录中<code>article</code>控制器。子目录前缀可为英文大小写字母、数字、下划线、正斜杠，其中正斜杠用来区分多级子目录（如<code>panels/admin</code>）</p>
<h2 id=控制器类命名><strong>控制器类命名</strong></h2>
<p>控制器ID遵循以下规则<strong>衍生</strong>控制器类名：</p>
<ol>
<li>将用正斜杠区分的每个单词第一个字母转为大写。 注意如果控制器ID包含正斜杠，只将最后的正斜杠后的部分第一个字母转为大写</li>
<li>去掉中横杠，将正斜杠替换为反斜杠</li>
<li>增加Controller后缀</li>
<li>在前面增加controller namespace控制器命名控件</li>
</ol>
<p>示例（假设<code>controller namespace</code>控制器命名空间为<code>app\controllers</code>）：</p>
<ul>
<li>article 对应 app\controllers\ArticleController</li>
<li>post-comment 对应 app\controllers\PostCommentController</li>
<li>admin/post-comment 对应 app\controllers\admin\PostCommentController</li>
<li>adminPanels/post-comment 对应 app\controllers\adminPanels\PostCommentController</li>
</ul>
<p>控制器类必须能被<strong>自动加载</strong>，所以在上面的例子中，控制器article类应在<strong>别名</strong>为 <code>@app/controllers/ArticleController.php</code>的文件中定义，控制器 <code>admin/post-comment</code>应在 <code>@app/controllers/admin/PostCommentController.php</code>文件中</p>
<h2 id=控制器部署><strong>控制器部署</strong></h2>
<p>可通过配置<code>controller map</code>来强制上述的控制器ID和类名对应，通常用在使用第三方不能掌控类名的控制器上</p>
<p>eg:</p>
<pre tabindex=0><code>[
    'controllerMap' =&gt; [
        // 用类名申明 &quot;account&quot; 控制器
        'account' =&gt; 'app\controllers\UserController',

        // 用配置数组申明 &quot;article&quot; 控制器
        'article' =&gt; [
            'class' =&gt; 'app\controllers\PostController',
            'enableCsrfValidation' =&gt; false,
        ],
    ],
]
</code></pre><h2 id=创建动作-1>创建动作</h2>
<ol>
<li>
<p>动作ID</p>
<p>操作ID应仅包含英文小写字母、苏子、下划线和中横杠，操作ID中的中横杠用来分割单词。</p>
<p>可通过两种方式创建操作ID，</p>
<ul>
<li>
<p>内联操作：在控制器类中定义为方法</p>
</li>
<li>
<p>独立操作：是继承yii\base\Action或它的子类的类</p>
<p>内联操作容易创建，在无需重用的情况下优先使用，独立操作相反，主要用于多个控制器重用，或重构为<strong>扩展</strong></p>
</li>
</ul>
</li>
<li>
<p>内联动作</p>
<p>动作方法的名字是根据操作ID遵循如下规则生成:</p>
<ol>
<li>
<p>将每个单词的第一个字母转为大写</p>
</li>
<li>
<p>去掉中横杠</p>
</li>
<li>
<p>增加action前缀</p>
<p>eg: index转成actionIndex, hello-world 转成 actionHelloWorld</p>
<blockquote>
<p>注： 操作方法的名字大小写敏感，如果方法名称为ActionIndex不会认为是操作方法，所以请求index操作会返回一个异常，也要注意操作方法必须是公有的，私有或受保护的方法不能定义为内联操作。</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>独立动作</p>
<p>独立操作通过继承 <code>yii\base\Action</code> 或它的子类来定义。 例如Yii发布的 <code>yii\web\ViewAction</code> 和 <code>yii\web\ErrorAction</code> 都是独立操作</p>
<p>要使用独立操作，需要通过控制器中覆盖 <code>yii\base\Controller::actions()</code> 方法在 action map中声明，如下例所示：</p>
<pre tabindex=0><code>public function actions()
{
    return [
        // 用类来申明&quot;error&quot; 动作
        'error' =&gt; 'yii\web\ErrorAction',

        // 用配置数组申明 &quot;view&quot; 动作
        'view' =&gt; [
            'class' =&gt; 'yii\web\ViewAction',
            'viewPrefix' =&gt; '',
        ],
    ];
}
</code></pre><p>如上所示，actions()方法返回 键为操作ID、值为对应操作类名或数组 configurations 的数组。 和内联操作不同，独立操作ID可包含任意字符，只要在actions()方法中声明。</p>
<p>为创建一个独立操作类，需要继承 <code>yii\base\Action</code> 或它的子类，并实现公有的名称为run()的方法，run()方法的角色和操作方法类似，例如：</p>
<pre tabindex=0><code>&lt;?php
namespace app\components;

use yii\base\Action;

class HelloWorldAction extends Action
{
    public function run()
    {
        return &quot;Hello World&quot;;
    }
}
</code></pre></li>
<li>
<p>动作结果</p>
<p>操作方法或独立操作的run()方法的返回值非常重要，它表示对应操作结果</p>
<p>返回值可为响应对象，作为响应发送给终端用户。</p>
<ul>
<li>
<p>对于网页应用，返回值可为任意数据，它复制给 <code>yii\web\Respinse::$data</code>，最终转换为字符串来展示响应内容</p>
</li>
<li>
<p>对于控制台应用，返回值可为整数，表示命令行下执行的exit status 退出状态</p>
<p>在上面的例子中，操作结果都为字符串，作为响应数据发送给终端用户，下例显示一个操作通过返回响应对象（因为redirect()方法返回一个响应对象）可将用户浏览器跳转到新的URL</p>
<p>public function actionForward()
{</p>
<pre tabindex=0><code>// 用户浏览器跳转到 http://example.com
return $this-&gt;redirect('http://example.com');
</code></pre><p>}</p>
</li>
</ul>
</li>
<li>
<p>动作参数</p>
<p>内联动作的操作方法和独立动作的run()方法可以带参数，成为动作参数。 参数值从请求中获取，对于 网页应用，每个动作参数的值从$_GET中获得，参数名作为键；对于控制台应用，动作参数对应命令行参数。</p>
<p>如下例，动作view（内联动作）声明了两个参数 $id 和 $version</p>
<pre tabindex=0><code>namespace app\controllers;

use yii\web\Controller;

class PostController extends Controller
{
    public function actionView($id, $version = null)
    {
        // ...
    }
}
</code></pre><p>动作参数会被不同的参数填入，如下所示：</p>
</li>
</ol>
<pre tabindex=0><code>+ http://hostname/index.php?r=post/view&amp;id=123: $id 会填入'123'， $version 仍为 null 空因为没有version请求参数;
+ http://hostname/index.php?r=post/view&amp;id=123&amp;version=2: $id 和 $version 分别填入 '123' 和 '2'`；
+ http://hostname/index.php?r=post/view: 会抛出yii\web\BadRequestHttpException 异常 因为请求没有提供参数给必须赋值参数$id；
+ http://hostname/index.php?r=post/view&amp;id[]=123: 会抛出yii\web\BadRequestHttpException 异常 因为 $id 参数收到数组值 ['123'] 而不是字符串.

如果你想要一个动作参数来接收数组值，你应该使用array来提示它，如下所示：

    public function actionView(array $id, $version = null)
    {
        // ...
    }

现在如果请求为 http://hostname/index.php?r=post/view&amp;id[]=123, 参数 $id 会使用数组值 ['123']， 如果请求为 http://hostname/index.php?r=post/view&amp;id=123， 参数 $id 会获取相同数组值，因为无类型的 '123' 会自动转成数组。
</code></pre><h2 id=控制器生命周期>控制器生命周期</h2>
<p>处理一个请求时，应用主体 会根据请求 路由创建一个控制器， 控制器经过以下生命周期来完成请求：</p>
<ol>
<li>在控制器创建和配置后，yii\base\Controller::init() 方法会被调用。</li>
<li>控制器根据请求操作ID创建一个操作对象:
<ul>
<li>如果操作ID没有指定，会使用default action ID默认操作ID；</li>
<li>如果在action map找到操作ID， 会创建一个独立操作；</li>
<li>如果操作ID对应操作方法，会创建一个内联操作；</li>
<li>否则会抛出yii\base\InvalidRouteException异常。</li>
</ul>
</li>
<li>控制器按顺序调用应用主体、模块（如果控制器属于模块）、 控制器的 beforeAction() 方法；
<ul>
<li>如果任意一个调用返回false，后面未调用的beforeAction()会跳过并且操作执行会被取消； action execution will be cancelled.</li>
<li>默认情况下每个 beforeAction() 方法会触发一个 beforeAction 事件，在事件中你可以追加事件处理操作；</li>
</ul>
</li>
<li>控制器执行操作:
<ul>
<li>请求数据解析和填入到操作参数；</li>
</ul>
</li>
<li>控制器按顺序调用控制器、模块（如果控制器属于模块）、应用主体的 afterAction() 方法；
<ul>
<li>默认情况下每个 afterAction() 方法会触发一个 afterAction 事件， 在事件中你可以追加事件处理操作；</li>
</ul>
</li>
<li>应用主体获取操作结果并赋值给响应.</li>
</ol>
<p>注： 在设计良好的应用中，控制器很精炼，包含的操作代码简短；如果你的控制器很复杂，通常意味着需要重构，转移一些代码到其它类中。</p>
<p>归纳起来，控制器</p>
<ul>
<li>可访问请求数据</li>
<li>可根据请求数据调用 模型 的方法和其它服务组件</li>
<li>可使用视图构造响应</li>
<li>不应处理应被模型处理的请求数据</li>
<li>应避免嵌入HTML或其它展示代码，这些代码最好在视图中处理。</li>
</ul>
<h1 id=模型>模型</h1>
<p>模型是MVC模式中的一部分，代表了业务数据、规则和逻辑的对象。</p>
<p>可通过继承 yii\base\Model 或 它的子类定义模型类，基类 yii\base\Model 支持许多实用的特性：</p>
<ul>
<li>属性: 代表可像普通类属性或数组 一样被访问的业务数据;</li>
<li>属性标签: 指定属性显示出来的标签;</li>
<li>块赋值: 支持一步给许多属性赋值;</li>
<li>验证规则: 确保输入数据符合所申明的验证规则;</li>
<li>数据导出: 允许模型数据导出为自定义格式的数组。</li>
</ul>
<h2 id=块赋值>块赋值</h2>
<p>块赋值只用一行代码将用户所有输入填充到一个模型，非常方便，它直接将输入数据对应填充到 <code>yii\base\Model::attributes()</code> 属性。</p>
<pre tabindex=0><code>$model = new \app\models\ContactForm;
$model-&gt;attributes = \Yii::$app-&gt;request-&gt;post('ContactForm'); # ContactForm是定义好的模型名称
</code></pre><h2 id=practice>PRACTICE</h2>
<p>模型是代表业务数据、规则和逻辑的中心地方，通常在很多地方重用，在一个设计良好的应用中，模型通常比<strong>控制器</strong>代码多。</p>
<p>关于Yii的模型：</p>
<ul>
<li>可包含属性来展示业务数据;</li>
<li>可包含验证规则确保数据有效和完整;</li>
<li>可包含方法实现业务逻辑;</li>
<li>不应直接访问请求，session和其他环境数据， 这些数据应该由控制器传入到模型;</li>
<li>应避免嵌入HTML或其他展示代码，这些代码最好在 视图中处理;</li>
<li>单个模型中避免太多的场景</li>
</ul>
<p>在开发大型复杂系统时应经常考虑最后一条建议， 在这些系统中，模型会很大并在很多地方使用，因此会包含需要规则集和业务逻辑， 最后维护这些模型代码成为一个噩梦， 因为一个简单修改会影响好多地方， 为确保模型好维护，最好使用以下策略：</p>
<ul>
<li>定义可被多个 应用主体 或 模块 共享的模型基类集合。 这些模型类应包含通用的最小规则集合和逻辑。</li>
<li>在每个使用模型的 应用主体 或 模块中， 通过继承对应的模型基类来定义具体的模型类， 具体模型类包含应用主体或模块指定的规则和逻辑。</li>
</ul>
<p>例如，在高级应用模板， 你可以定义一个模型基类<code>common\models\Post</code>， 然后在前台应用中，定义并使用一个继承<code>common\models\Post</code>的具体模型类<code>frontend\models\Post</code>， 在后台应用中可以类似地定义<code>backend\models\Post</code>。 通过这种策略，你清楚<code>frontend\models\Post</code>只对应前台应用，如果你修改它， 就无需担忧修改会影响后台应用。</p>
<h1 id=视图-1>视图</h1>
<h2 id=组织视图>组织视图</h2>
<ul>
<li>控制器渲染的视图文件默认放在 <code>@app/views/ControllerID</code> 目录下， 其中 <code>ControllerID</code> 对应 控制器 ID, 例如控制器类为 <code>PostController</code>，视图文件目录应为 <code>@app/views/post</code>， 控制器类 <code>PostCommentController</code>对应的目录为 <code>@app/views/post-comment</code>， 如果是模块中的控制器，目录应为 <code>module directory</code> 模块目录下的 <code>views/ControllerID</code> 目录；</li>
<li>对于 小部件 渲染的视图文件默认放在 <code>WidgetPath/views</code> 目录， 其中 <code>WidgetPath</code> 代表小部件类文件所在的目录；</li>
</ul>
<h2 id=渲染视图>渲染视图</h2>
<pre tabindex=0><code>namespace app\controllers;

use Yii;
use app\models\Post;
use yii\web\Controller;
use yii\web\NotFoundHttpException;

class PostController extends Controller
{
    public function actionView($id)
    {
        $model = Post::findOne($id);
        if ($model === null) {
            throw new NotFoundHttpException;
        }

        // 渲染一个名称为&quot;view&quot;的视图并使用布局
        return $this-&gt;render('view', [
            'model' =&gt; $model,
        ]);
    }
}
</code></pre><h2 id=practice-1>PRACTICE</h2>
<p>视图负责将模型的数据展示用户想要的格式，总之，视图</p>
<ul>
<li>应主要包含展示代码，如HTML, 和简单的PHP代码来控制、格式化和渲染数据；</li>
<li>不应包含执行数据查询代码，这种代码放在模型中；</li>
<li>应避免直接访问请求数据，如 $_GET, $_POST，这种应在控制器中执行， 如果需要请求数据，应由控制器推送到视图。</li>
<li>可读取模型属性，但不应修改它们。</li>
</ul>
<p>为使模型更易于维护，避免创建太复杂或包含太多冗余代码的视图， 可遵循以下方法达到这个目标：</p>
<ul>
<li>使用<strong>布局</strong>来展示公共代码（如，页面头部、尾部）；</li>
<li>将复杂的视图分成几个小视图，可使用上面描述的渲染方法将这些小视图渲染并组装成大视图；</li>
<li>创建并使用<strong>小部件</strong>作为视图的数据块；</li>
<li>创建并使用助手类在视图中转换和格式化数据。</li>
</ul>
<h1 id=模块>模块</h1>
<h2 id=practice-2>PRACTICE</h2>
<p>模块在大型项目中常备使用，这些项目的特性可分组， 每个组包含一些强相关的特性， 每个特性组可以做成一个模块由特定的开发人员和开发组来开发和维护。</p>
<p>在特性组上，使用模块也是重用代码的好方式， 一些常用特性，如用户管理，评论管理，可以开发成模块， 这样在相关项目中非常容易被重用。</p>
<h1 id=请求处理重点>请求处理（重点）</h1>
<p>这块的逻辑我感觉是重点，值得一看</p>
<h2 id=启动引导bootstrapping>启动引导（Bootstrapping）</h2>
<p>启动引导指在应用开始解析并处理新接受请求之前，一个预先准备环境的过程。 启动引导会在两个地方具体进行：<strong>入口脚本（Entry Script）</strong> 和 <strong>应用主体（application）</strong></p>
<p>在<strong>入口脚本</strong>里，需注册各个类库的类文件自动加载器（Class Autoloader），主要包括通过其autoload.php文件加载的Composer自动加载器，以及通过Yii类加载的Yii自动加载器。 之后，入口脚本会加载应用的配置并创建一个应用主体的实例。</p>
<p>在应用主体的构造函数中，会执行以下引导工作：</p>
<ol>
<li>调用 preInit()（预初始化）方法，配置一些高优先级的应用属性， 比如 basePath 属性。</li>
<li>注册错误处理器（ErrorHandler）。</li>
<li>通过给定的应用配置初始化应用的各属性。</li>
<li>通过调用 init()（初始化）方法，它会顺次调用 bootstrap() 从而运行引导组件。
<ul>
<li>加载扩展清单文件(extension manifest file) vendor/yiisoft/extensions.php。</li>
<li>创建并运行各个扩展声明的 引导组件（bootstrap components）。</li>
<li>创建并运行各个 应用组件 以及在应用的 Bootstrap 属性中声明的各个 模块（modules）组件（如果有）。</li>
</ul>
</li>
</ol>
<h2 id=路由-1>路由</h2>
<p>当入口脚本在调用 <code>run()</code> 方法时，它进行的第一个操作就是解析输入的请求，然后实例化对应的控制器动作处理这个请求。 该过程就被称为<strong>引导路由（routing）</strong>。 路由相反的操作会将给定的路由和参数生成一个可访问的URL地址， 这个操作叫做创建URL。 创建出来的URL被请求的时候，路由处理器可以解析成原始的路由信息和参数。</p>
<p>负责路由解析和创建URL的组件是 URL管理器, URL管理器在程序组件中被注册成 urlManager。 URL管理器 提供方法 parseRequest() 来 解析请求的URL并返回路由信息和参数， 方法 createUrl() 用来根据提供的路由和参数创建一个可访问的URL。</p>
<p>urlManager可以配置路由格式</p>
<ol>
<li>
<p>URL格式化</p>
<p>URL管理器提供两种URL格式：</p>
<ul>
<li>
<p>默认URL格式；</p>
</li>
<li>
<p>美化URL格式。</p>
<p>默认URL格式使用一个参数r表示路由， 并且使用一般的参数格式表示请求参数。例如，<code>/index.php?r=post/view&id=100</code>表示路由为<code>post/view</code>，参数id为100。 默认URL格式不需要为URL管理器做任何配置， 并且在任何Web服务器都可以正常使用。</p>
<p>美化URL格式在脚本名称后面使用更多的路径信息表示路由和参数信息。 例如，用适当的URL规则，<code>/index.php/post/100</code>中附加的路径信息<code>/post/100</code>表示 路由为<code>post/view</code>，参数id为100。 要使用美化的URL格式，你需要根据实际的需求 设计一组URL规则来规定URL的样式。</p>
</li>
</ul>
</li>
<li>
<p>路由</p>
<p>路由处理包含两个步骤：</p>
<ul>
<li>
<p>请求被解析成一个路由和关联的参数；</p>
</li>
<li>
<p>路由相关的一个控制器动作被创建出来处理这个请求。</p>
<p>如果使用默认URL格式，解析请求到路由只是简单的从GET请求中得到命名为r的参数。</p>
<p>当使用用美化URL格式时，URL管理器将检查注册的URL规则， 找到一条可以匹配的将请求转到路由的规则。 如果找不到任何匹配的规则，系统将抛出<code>yii\web\NotFoundHttpException</code>异常。</p>
<p>一旦请求解析成路由，系统将马上根据路由信息创建一个控制器动作。 路由信息根据 <code>/（正斜杠）</code>分解成多个部分。例如，<code>site/index</code>将被分解成<code>site</code>和<code>index</code>两部分。 每个部分都可能被认为是一个模块、控制器或动作的ID。 从路由的第一个部分开始，系统将执行以下步骤创建所需模块（如果有模块的话）、控制器和动作：</p>
</li>
</ul>
<ol>
<li>设置应用系统作为当前的模块。</li>
<li>检查当前模块中的控制器映射是否存在当前ID。 如果存在，根据控制器映射中的定义创建一个控制器实例， 跳到步骤5处理路由剩下的部分。</li>
<li>检查ID是否为当前模块下modules定义的子模块 如果是，创建对应子模块， 跳到步骤2使用刚创建的子模块处理路由下一部分。</li>
<li>将ID作为一个控制器ID并创建一个控制器实例， 并用来处理路由剩下的部分。</li>
<li>控制器在自己的动作映射中查找当前ID。 如果找到，根据映射中的定义创建一个动作。 如果没找到，控制器将尝试根据动作ID定义的动作方法创建一个行内动作。</li>
</ol>
</li>
<li>
<p>缺省路由</p>
<p>可以在应用配置中设置缺省值</p>
</li>
<li>
<p>创建URL</p>
<p>Yii提供了一个助手方法yii\helpers\Url::to()，用来根据提供的路由和参数创建各种各样的URL。 例如：</p>
<pre tabindex=0><code>use yii\helpers\Url;

// 创建一个普通的路由URL：/index.php?r=post%2Findex
echo Url::to(['post/index']);

// 创建一个带路由参数的URL：/index.php?r=post%2Fview&amp;id=100
echo Url::to(['post/view', 'id' =&gt; 100]);

// 创建一个带锚定的URL：/index.php?r=post%2Fview&amp;id=100#content
echo Url::to(['post/view', 'id' =&gt; 100, '#' =&gt; 'content']);

// 创建一个绝对路径URL：http://www.example.com/index.php?r=post%2Findex
echo Url::to(['post/index'], true);

// 创建一个带https协议的绝对路径URL：https://www.example.com/index.php?r=post%2Findex
echo Url::to(['post/index'], 'https');
</code></pre><p>方法<code>yii\helpers\Url::to()</code>传入的路由是上下文相关的。 根据以下规则确认传入的路由是一个相对的路由还是绝对的路由：</p>
<ul>
<li>如果路由是一个空字符串，则使用当前请求的路由；</li>
<li>如果路由中不存在/，则被认为是一个当前控制器下的动作ID， 且路由被附加到当前控制器的唯一ID后面；</li>
<li>如果路由不以/开头，被认为是当前模块下的路由， 路由将被附加到当前模块的唯一ID后面。</li>
</ul>
</li>
<li>
<p>命名参数</p>
<p>一条URL规则可以对匹配模式中的参数设置格式为 <code>&lt;ParamName:RegExp></code> 的命名， 其中 <code>ParamName</code> 指定参数的名称，<code>RegExp</code> 是可选的用来匹配参数值得正则表达式。 如果没有设置 <code>RegExp</code>，表示参数值为不包含 <code>/</code> 的字符串。</p>
<p>当一条规则用来匹配<code>URL</code>时，符合匹配规则的相关的参数值被填充到规则中， 并且这些参数可以在 <code>request</code> 组件中使用 <code>$_GET</code> 获取到。 当规则用来创建 <code>URL</code> 时， 提供的参数值将被插入到规则定义的指定位置。</p>
<p>让我们使用一些例子来说明命名参数是如何工作的。假设我们定义了以下三条 <code>URL</code> 规则：</p>
<pre tabindex=0><code>[
    'posts/&lt;year:\d{4}&gt;/&lt;category&gt;' =&gt; 'post/index',
    'posts' =&gt; 'post/index',
    'post/&lt;id:\d+&gt;' =&gt; 'post/view',
]
</code></pre><p>当规则用来解析 <code>URL</code> 时：</p>
<ul>
<li>
<p>根据第二条规则，<code>/index.php/posts</code> 被解析成路由 <code>post/index</code>；</p>
</li>
<li>
<p>根据第一条规则，<code>/index.php/posts/2014/php</code> 被解析成路由 <code>post/index</code>， 参数 <code>year</code> 的值是 <code>2014</code>，参数 <code>category</code> 的值是 <code>php</code>；</p>
</li>
<li>
<p>根据第三条规则，<code>/index.php/post/100</code> 被解析成路由 <code>post/view</code>， 参数 <code>id</code> 的值是 <code>100</code>；</p>
</li>
<li>
<p>当<code>yii\web\UrlManager::$enableStrictParsing</code> 设置为 <code>true</code> 时，<code>/index.php/posts/php</code> 将导致一个<code>yii\web\NotFoundHttpException</code> 异常， 因为无法匹配任何规则。如果 <code>yii\web\UrlManager::$enableStrictParsing</code> 设为 <code>false</code>（默认值）， 路径部分 <code>posts/php</code> 将被作为路由。</p>
<p>当规则用来生成 URL 时：</p>
</li>
<li>
<p>根据第二条规则 Url::to([‘post/index’]) 生成 /index.php/posts；</p>
</li>
<li>
<p>根据第一条规则 Url::to([‘post/index’, ‘year’ => 2014, ‘category’ => ‘php’]) 生成 /index.php/posts/2014/php；</p>
</li>
<li>
<p>根据第三条规则 Url::to([‘post/view’, ‘id’ => 100]) 生成 /index.php/post/100；</p>
</li>
<li>
<p>根据第三条规则 Url::to([‘post/view’, ‘id’ => 100, ‘source’ => ‘ad’]) 生成 /index.php/post/100?source=ad。 因为参数 source 在规则中没有指定，将被作为普通请求参数附加到生成的 URL 后面。</p>
</li>
<li>
<p>Url::to([‘post/index’, ‘category’ => ‘php’]) 生成 /index.php/post/index?category=php。 注意因为没有任何规则适用，将把路由信息当做路径信息来生成URL， 并且所有参数作为请求查询参数附加到 URL 后面。</p>
</li>
</ul>
</li>
</ol>
<h2 id=practice-3>PRACTICE</h2>
<pre tabindex=0><code>在开发复杂的 Web 应用程序时，优化 URL 规则非常重要，以便解析请求和创建 URL 所需 的时间更少。

通过使用参数化路由，您可以减少 URL 规则的数量，这可以显著提高性能。

当解析或创建URL时，URL manager 按照它们声明的顺序检查 URL 规则。 因此，您可以考虑调整 URL 规则的顺序，以便在较少使用的规则之前放置更具体和/或更常用的规则。

如果多个 URL 规则使用相同的前缀，你可以考虑使用 yii\web\GroupUrlRule， 这样作为一个组合，URL管理器会更高效。 特别是当应用程序由模块组合而成时，每个模块都有各自的 URL 规则且都有各自的模块 ID 作为前缀。
</code></pre><h1 id=关于安装搭建测试环境>关于安装搭建测试环境</h1>
<p>没想到这个也要费点篇幅，那我们先开始搭建吧</p>
<ol>
<li>
<p>在github上找到对应的release版本，我们以2.0.4为例</p>
<p><img src=https://i.imgur.com/JdTclLe.png alt=img></p>
<p>下载 两个文件，<code>yii-advanced-app-2.0.4.tgz</code> 和 <code>yii-basic-app-2.0.4.tgz</code></p>
</li>
<li>
<p>解压basic到web目录</p>
</li>
<li>
<p>解压advanced并覆盖之前basic中的内容</p>
</li>
<li>
<p>配置 config/web.php中的cookieValidationKey</p>
<p><img src=https://i.imgur.com/76q2XKU.png alt=img></p>
</li>
<li>
<p>测试安装是否成功，输入URL</p>
<blockquote>
<p>http://localhost/yii2/web/index.php</p>
</blockquote>
<p><img src=https://i.imgur.com/zIAOMty.png alt=img></p>
</li>
</ol>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/security/>security</a>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/p/spring-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/>
<div class=article-details>
<h2 class=article-title>Spring 漏洞总结</h2>
</div>
</a>
</article>
<article>
<a href=/p/thinkphp-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/>
<div class=article-details>
<h2 class=article-title>ThinkPHP 漏洞总结</h2>
</div>
</a>
</article>
<article>
<a href=/p/%E5%88%A9%E7%94%A8%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%B8%8B%E8%BD%BDvol.moe%E7%9A%84%E6%89%80%E6%9C%89%E6%BC%AB%E7%94%BB/>
<div class=article-details>
<h2 class=article-title>利用越权漏洞下载vol.moe的所有漫画</h2>
</div>
</a>
</article>
<article>
<a href=/p/php-fileinclusion/>
<div class=article-details>
<h2 class=article-title>PHP-FileInclusion</h2>
</div>
</a>
</article>
<article>
<a href=/p/sql%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/>
<div class=article-details>
<h2 class=article-title>SQL注入-报错注入原理</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2017 -
2021 Sera Wang
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.5.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#应用结构>应用结构</a></li>
<li><a href=#请求生命周期>请求生命周期</a></li>
</ol>
<ol>
<li><a href=#创建动作>创建动作</a></li>
<li><a href=#创建视图>创建视图</a></li>
</ol>
<ol>
<li><a href=#动作方法>动作方法</a></li>
<li><a href=#创建视图-1>创建视图</a></li>
</ol>
<ol>
<li><a href=#创建activerecord>创建ActiveRecord</a></li>
<li><a href=#controller>Controller</a></li>
<li><a href=#视图>视图</a></li>
</ol>
<ol>
<li><a href=#定义常量>定义常量</a></li>
</ol>
<ol>
<li><a href=#应用主体配置>应用主体配置</a></li>
<li><a href=#应用事件>应用事件</a></li>
<li><a href=#应用主体生命周期>应用主体生命周期</a></li>
</ol>
<ol>
<li><a href=#动作><strong>动作</strong></a></li>
<li><a href=#路由><strong>路由</strong></a></li>
<li><a href=#控制器id><strong>控制器ID</strong></a></li>
<li><a href=#控制器类命名><strong>控制器类命名</strong></a></li>
<li><a href=#控制器部署><strong>控制器部署</strong></a></li>
<li><a href=#创建动作-1>创建动作</a></li>
<li><a href=#控制器生命周期>控制器生命周期</a></li>
</ol>
<ol>
<li><a href=#块赋值>块赋值</a></li>
<li><a href=#practice>PRACTICE</a></li>
</ol>
<ol>
<li><a href=#组织视图>组织视图</a></li>
<li><a href=#渲染视图>渲染视图</a></li>
<li><a href=#practice-1>PRACTICE</a></li>
</ol>
<ol>
<li><a href=#practice-2>PRACTICE</a></li>
</ol>
<ol>
<li><a href=#启动引导bootstrapping>启动引导（Bootstrapping）</a></li>
<li><a href=#路由-1>路由</a></li>
<li><a href=#practice-3>PRACTICE</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>