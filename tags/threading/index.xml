<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>threading on Sera Wang</title><link>https://selfsolo.com/tags/threading/</link><description>Recent content in threading on Sera Wang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 27 Jan 2018 21:14:23 +0800</lastBuildDate><atom:link href="https://selfsolo.com/tags/threading/index.xml" rel="self" type="application/rss+xml"/><item><title>Python-threading库的使用</title><link>https://selfsolo.com/p/python-threading%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 27 Jan 2018 21:14:23 +0800</pubDate><guid>https://selfsolo.com/p/python-threading%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>之前看过的多线程相关的记不大清了，重新学习吧。
线程的概念
线程是CPU分配资源的基本单位。但一个程序开始运行，这个程序就变成了一个进程，而一个进程有至少一个线程。
当没有多线程编程时，一个进程也是一个主线程，但有多线程编程时，一个进程包含多个线程，包括主线程。
使用线程可以实现程序的并发。
创建线程
第一种，创建thread.Thread实例
import threading def func_thread(x,y): #定义线程运行函数 for i in range(x,y): print(i) #创建线程t1，用来跑func_thread(1,6) t1 = threading.Thread(target=func_thread,args=(1,6)) #创建线程t2,用来跑func_thread(10,15) t2 = threading.Thread(target=func_thread,args=(10,15)) t1.start() #调用start(),启动t1 t2.start() #调用start(),启动t2 刚接触，实际过程中，除了能传参，其它感觉不是特别方便.. 第二种，继承thread.Thread类 要点是是要重载threading.THread类的run方法，然后调用start()启动线程
import threading class mythread(threading.Thread): def run(self): #这里写要运行的代码 print(111) t1 = mythread() #创建mythread()实例t1 t2 = mythread() #创建mythread()实例t2 t1.start() #启动mythread t2.start() #启动mythread threading.Thread类的一些相关属性
join()方法：调用join()后，直到调用join的线程运行完了其他线程才能运行
import threading class mythread(threading.Thread): def run(self): for i in range(30): print(i) t1 = mythread() t2 = mythread() t1.</description></item></channel></rss>