<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>学习笔记 on Sera Wang</title><link>https://sera.wang/categories/study_notes/</link><description>Recent content in 学习笔记 on Sera Wang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 30 May 2020 11:04:06 +0000</lastBuildDate><atom:link href="https://sera.wang/categories/study_notes/index.xml" rel="self" type="application/rss+xml"/><item><title>机器学习 - 入门</title><link>https://sera.wang/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 30 May 2020 11:04:06 +0000</pubDate><guid>https://sera.wang/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/</guid><description>相关资料 课程 Machine Learning - Andrew Ng 课程地址
书籍 《Python机器学习》— Sebastian Raschka
师兄当年安利 《数学之美》— 吴军
一些振奋人心的话和介绍
无需多言，大家都已知道，机器学习已发展成为当前最能激发人们兴趣的技术之一。出于各种考虑，Google、Facebook、Apple、Amazon、IBM等众多公司都投入了巨资用于机器学习理论和应用的研究。机器学习看起来已经成为当前的一个流行语，但这绝对不是炒作。这一令人兴奋的技术为我们带来了全新的可能，并已成为我们日常生活中不可或缺的一部分。例如，与智能手机的语音助手对话、向客户推荐合适的商品、防止信用卡诈骗、过滤垃圾邮件，以及检测与诊断疾病等，这样的例子不胜枚举。—— Sebastian Raschka
Python机器学习 第一章 机器学习 机器学习的概念 当前的时代拥有大量的结构化和非结构化的数据，20世纪下半叶，机器学习逐渐演化为人工智能的一个分支，其目的是通过对自学习算法的开发，从数据中获取知识，进而对未来进行预测。与传统的通过大量数据分析然后人工推导规则（如WAF规则）并构造模型不同，机器学习提供了一种从数据中获取知识的方法，同时能够逐步提高预测模型的性能，并将模型应用于基于数据驱动的决策中去。
机器学习的三种方法 监督学习 - Supervised Learning 简介 监督学习的目的是使用有类标的训练数据构建模型，我们可以使用经训练得到的模型对未来数据进行预测。
监督是指训练数据集中的每个样本均有一个已知的输出项。
示例：过滤垃圾邮件
基于有类标的电子邮件样本库（每一个样本都已被准确地标记是否为垃圾邮件），可以使用监督学习算法训练生成一个判定模型，用来判定一封新的电子邮件是否为垃圾邮件。
类似过滤垃圾邮件的这类问题也被称为分类（classfication），监督学习的另一个子类是回归（regression）。
利用分类对类标进行预测 分类是基于对过往类标已知示例的观察与学习，实现对新样本类标的预测。这些类标是离散的、无序的值，它们可以视为样本的组别信息（group membership）。上文检测垃圾邮件的例子是一个典型的二类别分类（binary classification）任务，机器学习算法会生成一系列的规则用以判定邮件是否属于垃圾邮件。
然而，类标集合并非一定是二类别分类的。通过监督学习算法构造的预测模型可以将训练样本库中出现的任何类标赋给一个尚未被标记的新样本。
比如手写字符识别就是一个典型的多类别分类（multi-class classfication）的例子。我们可以将字母表中每个字母的多个不同的手写样本收集起来作为训练数据集。此时，若用户给出一个新的手写字符，我们的预测模型能够以一定的准确率将其判定为字母表中的某个字母。然而，如果我们的训练样本库中没有出现0～9的数字字符，那么模型将无法正确辨别任何输入的数字。
下图通过一个具有30个训练样本的示例说明二类别分类任务的概念：15个样本被标记为负类别（negative class - 圆圈）；15个被标记为正类别（positive class - 加号）。此时，我们的数据集是二维的，这意味着每个样本都有两个与其关联的值：x1和x2。现在，我们可以通过监督学习算法获得一条规则，并将其表示为一条黑色虚线标识的分界线。可以根据给定的x1、x2值将新样本划分到某个类别中。
使用回归预测连续输出值 回归分析（regression analysis）的目的是针对连续型输出变量进行预测。在回归分析中，数据会给出大量的自变量（解释变量）和因变量（输出结果），通过尝试寻找这两种变量之间的关系，就能够预测输出变量。
例如，如果我们想预测学生的数学考试成绩，如果花费在学习上的时间和最终的考试成绩有关联，则可以将其作为训练数据来训练模型，以根据学习时间预测将来要参加考试的学生的成绩。
下图用图例阐述了线性回归（linear regression）的概念：给定一个自变量x和因变量y，拟合一条直线使得样例数据点与拟合直线之间的距离最短，最常用的就是采用平均平方距离来计算。这样，我们就可以通过对样本数据的训练来获得拟合直线的截距和斜率，从而对新的输入变量值所对应的输出变量值进行预测。
强化学习 - Reinforcement Learning 强化学习的目的是构建一个系统（Agent），在于环境（environment）交互的国策和观念中提高系统的性能。环境的当前状态信息中通常包含一个反馈（reward）信号，我们可以将强化学习视为与监督学习相关的一个领域。然而，在强化学习中，这个反馈值不是一个确定的类标或连续的值，而是一个通过反馈函数产生的对当前系统行为的评价。通过与环境的交互，Agent可以通过强化学习来得到一系列行为，通过探索性的试错或者借助精心设计的激励系统使得正向反馈最大化。
一个最常见的例子就是围棋对弈的游戏（还有Dota的Open AI）。在此，Agent根据棋盘上的当前局势（environment）决定落子的位置，而游戏结束时胜负的判定可以作为激励信号。
无监督学习 - Unsupervised Learning 无监督学习的目的是在没有已知输出变量和反馈函数指导的情况下提取有效信息来探索数据的整体结构。</description></item><item><title>入门逆向</title><link>https://sera.wang/p/%E5%85%A5%E9%97%A8%E9%80%86%E5%90%91/</link><pubDate>Mon, 19 Nov 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E5%85%A5%E9%97%A8%E9%80%86%E5%90%91/</guid><description>我想成为魔法师！ 这个逆向专题用来记录自己学习逆向魔法的过程。
关于魔法 有人问教主: “ 现在都是win10了，win7连debug都没有，学习汇编有什么用，对于手机app开发有什么帮助？ “
教主:
“ 学习魔法辛苦又困难， 而且似乎对当个铁匠、农夫、牧羊人也毫无帮助。 “ ———— 2016-01-18
作为入门篇，这次逆向的是一个小pe，目标是改变它的执行逻辑，从而达到我们想要的效果（比如破解）。
用C写一个小程序 crack.c 代码如下:
#include &amp;lt;stdio.h&amp;gt; #define PASSWORD &amp;quot;1234567&amp;quot; int verify_password(char *password){ int authenticated; authenticated = strcmp(password,PASSWORD); return authenticated; } main(){ int valid_flag = 0; char password[1024]; while(1){ printf(&amp;quot;please input password: &amp;quot;); scanf(&amp;quot;%s&amp;quot;,password); valid_flag = verify_password(password); if(valid_flag){ printf(&amp;quot;incorrect password!\n\n&amp;quot;); }else{ printf(&amp;quot;Congradulation! You have passed the vrification\n&amp;quot;); break; } } } 编译获得 crack.exe ，也就是今天要破解的目标了。
IDA PRO静态分析 打开ida pro，把这个exe拖进去，就获得了一张清晰的执行逻辑结构图</description></item><item><title>常见摘要/加密算法总结</title><link>https://sera.wang/p/%E5%B8%B8%E8%A7%81%E6%91%98%E8%A6%81/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 18 Aug 2018 21:14:23 +0800</pubDate><guid>https://sera.wang/p/%E5%B8%B8%E8%A7%81%E6%91%98%E8%A6%81/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>最近逛到某网站碰到一个叫JWTtoken的验证机制，然后百度了一波jwt，再解码此jwttoken后看到是RSA256加密，明明最近才看过现在又忘光了…于是对常见算法做个总结吧！原理不会特别详细，只会介绍简单原理，让我以后再碰上不至于太懵逼。
基本概念 安全性原则：
保密性 完整性(内容不被篡改) 身份认证 不可抵赖性 对称/非对称加密
若加解密使用相同密钥，则称为对称密钥加密，否则称为非对称密钥加密。
对称密钥加密:Diffie-Hellman算法
因为密钥发布和密钥交换存在很多问题，所以要知道Diffie-Hellman密钥交换协议/算法。
通信双发可用此方法确定对称密钥，此方法只能用于密钥交换，而非加解密消息。
算法描述: 设A与B要确定密钥 1) A与B确定2个大素数 n 和 g 。 不必保密 2) A选择另一个大随机数X，计算: k1 = g^X mod n 后将k1发给B 3) B选择另一个大随机数Y，计算: k2 = g^Y mod n 后将k2发给A 4) 则密钥即为: kA = k2^X mod n kB = k1^Y mod n 且kA = kB 原理:
kA = (g^Y mod n)^X mod n = g^YX mod n</description></item></channel></rss>