---
title: "常见摘要/加密算法总结"
description: 读书时的碎碎念
date: 2018-08-18T21:14:23+08:00
tags:
    - Security
Categories:
    - Security
---



最近逛到某网站碰到一个叫JWTtoken的验证机制，然后百度了一波jwt，再解码此jwttoken后看到是RSA256加密，明明最近才看过现在又忘光了…于是对常见算法做个总结吧！原理不会特别详细，只会介绍简单原理，让我以后再碰上不至于太懵逼。



# 基本概念



> 安全性原则：

1. 保密性
2. 完整性(内容不被篡改)
3. 身份认证
4. 不可抵赖性

> 对称/非对称加密

若加解密使用相同密钥，则称为对称密钥加密，否则称为非对称密钥加密。

> 对称密钥加密:Diffie-Hellman算法

因为密钥发布和密钥交换存在很多问题，所以要知道Diffie-Hellman密钥交换协议/算法。

通信双发可用此方法确定对称密钥，此方法只能用于密钥交换，而非加解密消息。

```
算法描述: 

设A与B要确定密钥
1) A与B确定2个大素数 n 和 g 。 不必保密

2) A选择另一个大随机数X，计算:
   k1 = g^X mod n 后将k1发给B

3) B选择另一个大随机数Y，计算:
   k2 = g^Y mod n 后将k2发给A

4) 则密钥即为: 
   kA = k2^X mod n
   kB = k1^Y mod n

   且kA = kB
```

原理:

kA = (g^Y mod n)^X mod n = g^YX mod n

kB = (g^X mod n)^Y mod n = g^XY mod n

当然，这个容易受中间人攻击，攻击者可以同时与两方通信交换密钥，因为此方法没有身份认证。（于是考虑CA）

> 非对称密钥加密

此模式中，A和B不用同时访问可信任第三方以求出锁与密钥对

B有密钥对私钥与公钥，公钥用于封箱，私钥用于开锁。B将公钥和锁(某个加密算法)发给任何人(如A)，使其可以安全地向B发送消息(公钥加密只有私钥能解密，保密性)。而B可以用私钥开锁得到内容。

一方从另一方接收安全消息时，就将锁与密钥对发给另一方。

> 算法模式

ECB,CBC,CFB,OFB,CTR

# DES



数据加密标准 (Data Encryption Standard)

> 工作原理:

DES是个块加密法，按64位块长加密数据，即把64位明文作为DES的输入，输入64位密文。

加密与解密使用相同的算法和密钥，密钥长度为56位。

> 加密步骤:

1) 将64位明文块输入初始置换函数(IP)对明文进行初始置换(按某个表进行 位变换，比如第1位和第xx位交换)

2) 产生转换块的2半(左明文LPT和右明文RPT，各32位)

3) 每个LPT和RPT经过16轮加密（每轮: 各有自己的密钥，56位密钥移位后用一个位变换表产生不同的48位子密钥，然后将32位RPT进行拓展置换(就是某些位冗余)到48位，再进行S盒替换(复杂)，输出32位，再进行p盒替换，类似ip的简单置换，然后将LPT与p盒置换结果进行异或得到新的RPT，旧的RPT变成新的LPT）

4) 最后将LPT和RPT重接起来，对组成的块进行最终置换FP输出64位密文

> DES变体:

双重DES，就是使用两密钥，密钥1对原文加密，结果再用密钥2加密。
三重DES，同上。

# RSA



RSA是一种非对称密钥算法，基于这样的数学事实:两个大素数相乘很容易，而对得到的积求因子则很难，算法本身很简单，实际难度在于RSA选择和生成的密钥与公钥。

```
算法描述:

为了生成RSA公钥和私钥，B需要执行如下:

1) 选择2个大素数p和q (值越大，破解RSA越困难，执行加解密时间越长，因为指数运算很费时)

2) 计算 n = p*q 和 z = (p-1)*(q-1)

3) 选择小于n的一个数e，且使e和z没有公因数(即e和z互素)，e将被用于加密

4) 求一个数d，使ed-1可以被z整除，即 ed mod z = 1

   d将被用于解密

5) B的公钥kB+是一对数(n,e)
   B的私钥kB-是一对数(n,d)
```

> A加密和B解密的过程如下

设A要发给一个由整数m表示的比特报文(万物皆比特啊)，

A有公钥(n,e) , 且m < n

A计算，得加密值C，发给B

C = m^e mod n

B有私钥(n,d)

收到C后解密得到m

m = C^d mod n

> 工作原理

报文m加密

C = m^e mod n

解密

m = C^d mod n
= (m^e mod n)^d mod n

因为 (a mod n)^d mod n = a^d mod n
所以

m = m^(e*d) mod n

即，只要证明上式即可

而根据数论中的一个结论:

如果p和q是素数，且有n=pq和z=(p-1)(q-1)，则

x^y mod n = x^(y mod z)mod n

所以

m^(e*d) mod n = m^(e*d mod z) mod n = m^1 mod n = m

# MAC



在讲HMAC之前，先得介绍消息认证码MAC(Message Authentication Code)，它和MD5，SHA之类的摘要算法区别在于它需要通信双方知道共享对称密钥(秘密)，因此MAC涉及加密过程

> MAC工作原理

1. A与B共享一个对称密钥K，是别人不知道的。
2. A计算MAC时，要将密钥K作用于消息M。A将消息M和计算后的H1发给B
3. B收到M，也用K对M求出H2
4. B比较H1和H2，相同则验证了消息的完整性，表明其未被篡改

# HMAC



HMAC是指基于hash的消息认证码(Hash-based Message Authentication Code)，基本思想是服用MD5与SHA-1之类现有消息摘要算法，把消息摘要看成一个黑盒子，用共享秘密密钥加密消息摘要，从而输出MAC。

即 报文M → hash(M) → K(hash(M))

具体加密过程不表…

…

…

其实按内容来说这个应该叫密码学入门比较好…但以后再碰上别的算法就会把它们陆续加进来。